// node_modules/gsplat/dist/index.js
var A = class _A {
  constructor(A2 = 0, Q2 = 0, F2 = 0) {
    this.x = A2, this.y = Q2, this.z = F2;
  }
  equals(A2) {
    return this.x === A2.x && (this.y === A2.y && this.z === A2.z);
  }
  add(Q2) {
    return "number" == typeof Q2 ? new _A(this.x + Q2, this.y + Q2, this.z + Q2) : new _A(this.x + Q2.x, this.y + Q2.y, this.z + Q2.z);
  }
  subtract(Q2) {
    return "number" == typeof Q2 ? new _A(this.x - Q2, this.y - Q2, this.z - Q2) : new _A(this.x - Q2.x, this.y - Q2.y, this.z - Q2.z);
  }
  multiply(Q2) {
    return "number" == typeof Q2 ? new _A(this.x * Q2, this.y * Q2, this.z * Q2) : Q2 instanceof _A ? new _A(this.x * Q2.x, this.y * Q2.y, this.z * Q2.z) : new _A(this.x * Q2.buffer[0] + this.y * Q2.buffer[4] + this.z * Q2.buffer[8] + Q2.buffer[12], this.x * Q2.buffer[1] + this.y * Q2.buffer[5] + this.z * Q2.buffer[9] + Q2.buffer[13], this.x * Q2.buffer[2] + this.y * Q2.buffer[6] + this.z * Q2.buffer[10] + Q2.buffer[14]);
  }
  cross(Q2) {
    const F2 = this.y * Q2.z - this.z * Q2.y, U2 = this.z * Q2.x - this.x * Q2.z, B2 = this.x * Q2.y - this.y * Q2.x;
    return new _A(F2, U2, B2);
  }
  dot(A2) {
    return this.x * A2.x + this.y * A2.y + this.z * A2.z;
  }
  lerp(Q2, F2) {
    return new _A(this.x + (Q2.x - this.x) * F2, this.y + (Q2.y - this.y) * F2, this.z + (Q2.z - this.z) * F2);
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  distanceTo(A2) {
    return Math.sqrt((this.x - A2.x) ** 2 + (this.y - A2.y) ** 2 + (this.z - A2.z) ** 2);
  }
  normalize() {
    const Q2 = this.magnitude();
    return new _A(this.x / Q2, this.y / Q2, this.z / Q2);
  }
  flat() {
    return [this.x, this.y, this.z];
  }
  clone() {
    return new _A(this.x, this.y, this.z);
  }
  toString() {
    return `[${this.flat().join(", ")}]`;
  }
  static One(Q2 = 1) {
    return new _A(Q2, Q2, Q2);
  }
};
var Q = class _Q {
  constructor(A2 = 0, Q2 = 0, F2 = 0, U2 = 1) {
    this.x = A2, this.y = Q2, this.z = F2, this.w = U2;
  }
  equals(A2) {
    return this.x === A2.x && (this.y === A2.y && (this.z === A2.z && this.w === A2.w));
  }
  normalize() {
    const A2 = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    return new _Q(this.x / A2, this.y / A2, this.z / A2, this.w / A2);
  }
  multiply(A2) {
    const F2 = this.w, U2 = this.x, B2 = this.y, l2 = this.z, t2 = A2.w, d2 = A2.x, n2 = A2.y, V2 = A2.z;
    return new _Q(F2 * d2 + U2 * t2 + B2 * V2 - l2 * n2, F2 * n2 - U2 * V2 + B2 * t2 + l2 * d2, F2 * V2 + U2 * n2 - B2 * d2 + l2 * t2, F2 * t2 - U2 * d2 - B2 * n2 - l2 * V2);
  }
  inverse() {
    const A2 = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    return new _Q(-this.x / A2, -this.y / A2, -this.z / A2, this.w / A2);
  }
  apply(F2) {
    const U2 = new _Q(F2.x, F2.y, F2.z, 0), B2 = new _Q(-this.x, -this.y, -this.z, this.w), l2 = this.multiply(U2).multiply(B2);
    return new A(l2.x, l2.y, l2.z);
  }
  flat() {
    return [this.x, this.y, this.z, this.w];
  }
  clone() {
    return new _Q(this.x, this.y, this.z, this.w);
  }
  static FromEuler(A2) {
    const F2 = A2.x / 2, U2 = A2.y / 2, B2 = A2.z / 2, l2 = Math.cos(U2), t2 = Math.sin(U2), d2 = Math.cos(F2), n2 = Math.sin(F2), V2 = Math.cos(B2), Z2 = Math.sin(B2);
    return new _Q(l2 * n2 * V2 + t2 * d2 * Z2, t2 * d2 * V2 - l2 * n2 * Z2, l2 * d2 * Z2 - t2 * n2 * V2, l2 * d2 * V2 + t2 * n2 * Z2);
  }
  toEuler() {
    const Q2 = 2 * (this.w * this.x + this.y * this.z), F2 = 1 - 2 * (this.x * this.x + this.y * this.y), U2 = Math.atan2(Q2, F2);
    let B2;
    const l2 = 2 * (this.w * this.y - this.z * this.x);
    B2 = Math.abs(l2) >= 1 ? Math.sign(l2) * Math.PI / 2 : Math.asin(l2);
    const t2 = 2 * (this.w * this.z + this.x * this.y), d2 = 1 - 2 * (this.y * this.y + this.z * this.z), n2 = Math.atan2(t2, d2);
    return new A(U2, B2, n2);
  }
  static FromMatrix3(A2) {
    const F2 = A2.buffer, U2 = F2[0] + F2[4] + F2[8];
    let B2, l2, t2, d2;
    if (U2 > 0) {
      const A3 = 0.5 / Math.sqrt(U2 + 1);
      d2 = 0.25 / A3, B2 = (F2[7] - F2[5]) * A3, l2 = (F2[2] - F2[6]) * A3, t2 = (F2[3] - F2[1]) * A3;
    } else if (F2[0] > F2[4] && F2[0] > F2[8]) {
      const A3 = 2 * Math.sqrt(1 + F2[0] - F2[4] - F2[8]);
      d2 = (F2[7] - F2[5]) / A3, B2 = 0.25 * A3, l2 = (F2[1] + F2[3]) / A3, t2 = (F2[2] + F2[6]) / A3;
    } else if (F2[4] > F2[8]) {
      const A3 = 2 * Math.sqrt(1 + F2[4] - F2[0] - F2[8]);
      d2 = (F2[2] - F2[6]) / A3, B2 = (F2[1] + F2[3]) / A3, l2 = 0.25 * A3, t2 = (F2[5] + F2[7]) / A3;
    } else {
      const A3 = 2 * Math.sqrt(1 + F2[8] - F2[0] - F2[4]);
      d2 = (F2[3] - F2[1]) / A3, B2 = (F2[2] + F2[6]) / A3, l2 = (F2[5] + F2[7]) / A3, t2 = 0.25 * A3;
    }
    return new _Q(B2, l2, t2, d2);
  }
  static FromAxisAngle(A2, F2) {
    const U2 = F2 / 2, B2 = Math.sin(U2), l2 = Math.cos(U2);
    return new _Q(A2.x * B2, A2.y * B2, A2.z * B2, l2);
  }
  toString() {
    return `[${this.flat().join(", ")}]`;
  }
};
var F = class {
  constructor() {
    const A2 = /* @__PURE__ */ new Map();
    this.addEventListener = (Q2, F2) => {
      A2.has(Q2) || A2.set(Q2, /* @__PURE__ */ new Set()), A2.get(Q2).add(F2);
    }, this.removeEventListener = (Q2, F2) => {
      A2.has(Q2) && A2.get(Q2).delete(F2);
    }, this.hasEventListener = (Q2, F2) => !!A2.has(Q2) && A2.get(Q2).has(F2), this.dispatchEvent = (Q2) => {
      if (A2.has(Q2.type))
        for (const F2 of A2.get(Q2.type))
          F2(Q2);
    };
  }
};
var U = class _U {
  constructor(A2 = 1, Q2 = 0, F2 = 0, U2 = 0, B2 = 0, l2 = 1, t2 = 0, d2 = 0, n2 = 0, V2 = 0, Z2 = 1, I2 = 0, e2 = 0, R2 = 0, a2 = 0, g2 = 1) {
    this.buffer = [A2, Q2, F2, U2, B2, l2, t2, d2, n2, V2, Z2, I2, e2, R2, a2, g2];
  }
  equals(A2) {
    if (this.buffer.length !== A2.buffer.length)
      return false;
    if (this.buffer === A2.buffer)
      return true;
    for (let Q2 = 0; Q2 < this.buffer.length; Q2++)
      if (this.buffer[Q2] !== A2.buffer[Q2])
        return false;
    return true;
  }
  multiply(A2) {
    const Q2 = this.buffer, F2 = A2.buffer;
    return new _U(F2[0] * Q2[0] + F2[1] * Q2[4] + F2[2] * Q2[8] + F2[3] * Q2[12], F2[0] * Q2[1] + F2[1] * Q2[5] + F2[2] * Q2[9] + F2[3] * Q2[13], F2[0] * Q2[2] + F2[1] * Q2[6] + F2[2] * Q2[10] + F2[3] * Q2[14], F2[0] * Q2[3] + F2[1] * Q2[7] + F2[2] * Q2[11] + F2[3] * Q2[15], F2[4] * Q2[0] + F2[5] * Q2[4] + F2[6] * Q2[8] + F2[7] * Q2[12], F2[4] * Q2[1] + F2[5] * Q2[5] + F2[6] * Q2[9] + F2[7] * Q2[13], F2[4] * Q2[2] + F2[5] * Q2[6] + F2[6] * Q2[10] + F2[7] * Q2[14], F2[4] * Q2[3] + F2[5] * Q2[7] + F2[6] * Q2[11] + F2[7] * Q2[15], F2[8] * Q2[0] + F2[9] * Q2[4] + F2[10] * Q2[8] + F2[11] * Q2[12], F2[8] * Q2[1] + F2[9] * Q2[5] + F2[10] * Q2[9] + F2[11] * Q2[13], F2[8] * Q2[2] + F2[9] * Q2[6] + F2[10] * Q2[10] + F2[11] * Q2[14], F2[8] * Q2[3] + F2[9] * Q2[7] + F2[10] * Q2[11] + F2[11] * Q2[15], F2[12] * Q2[0] + F2[13] * Q2[4] + F2[14] * Q2[8] + F2[15] * Q2[12], F2[12] * Q2[1] + F2[13] * Q2[5] + F2[14] * Q2[9] + F2[15] * Q2[13], F2[12] * Q2[2] + F2[13] * Q2[6] + F2[14] * Q2[10] + F2[15] * Q2[14], F2[12] * Q2[3] + F2[13] * Q2[7] + F2[14] * Q2[11] + F2[15] * Q2[15]);
  }
  clone() {
    const A2 = this.buffer;
    return new _U(A2[0], A2[1], A2[2], A2[3], A2[4], A2[5], A2[6], A2[7], A2[8], A2[9], A2[10], A2[11], A2[12], A2[13], A2[14], A2[15]);
  }
  determinant() {
    const A2 = this.buffer;
    return A2[12] * A2[9] * A2[6] * A2[3] - A2[8] * A2[13] * A2[6] * A2[3] - A2[12] * A2[5] * A2[10] * A2[3] + A2[4] * A2[13] * A2[10] * A2[3] + A2[8] * A2[5] * A2[14] * A2[3] - A2[4] * A2[9] * A2[14] * A2[3] - A2[12] * A2[9] * A2[2] * A2[7] + A2[8] * A2[13] * A2[2] * A2[7] + A2[12] * A2[1] * A2[10] * A2[7] - A2[0] * A2[13] * A2[10] * A2[7] - A2[8] * A2[1] * A2[14] * A2[7] + A2[0] * A2[9] * A2[14] * A2[7] + A2[12] * A2[5] * A2[2] * A2[11] - A2[4] * A2[13] * A2[2] * A2[11] - A2[12] * A2[1] * A2[6] * A2[11] + A2[0] * A2[13] * A2[6] * A2[11] + A2[4] * A2[1] * A2[14] * A2[11] - A2[0] * A2[5] * A2[14] * A2[11] - A2[8] * A2[5] * A2[2] * A2[15] + A2[4] * A2[9] * A2[2] * A2[15] + A2[8] * A2[1] * A2[6] * A2[15] - A2[0] * A2[9] * A2[6] * A2[15] - A2[4] * A2[1] * A2[10] * A2[15] + A2[0] * A2[5] * A2[10] * A2[15];
  }
  invert() {
    const A2 = this.buffer, Q2 = this.determinant();
    if (0 === Q2)
      throw new Error("Matrix is not invertible.");
    const F2 = 1 / Q2;
    return new _U(F2 * (A2[5] * A2[10] * A2[15] - A2[5] * A2[11] * A2[14] - A2[9] * A2[6] * A2[15] + A2[9] * A2[7] * A2[14] + A2[13] * A2[6] * A2[11] - A2[13] * A2[7] * A2[10]), F2 * (-A2[1] * A2[10] * A2[15] + A2[1] * A2[11] * A2[14] + A2[9] * A2[2] * A2[15] - A2[9] * A2[3] * A2[14] - A2[13] * A2[2] * A2[11] + A2[13] * A2[3] * A2[10]), F2 * (A2[1] * A2[6] * A2[15] - A2[1] * A2[7] * A2[14] - A2[5] * A2[2] * A2[15] + A2[5] * A2[3] * A2[14] + A2[13] * A2[2] * A2[7] - A2[13] * A2[3] * A2[6]), F2 * (-A2[1] * A2[6] * A2[11] + A2[1] * A2[7] * A2[10] + A2[5] * A2[2] * A2[11] - A2[5] * A2[3] * A2[10] - A2[9] * A2[2] * A2[7] + A2[9] * A2[3] * A2[6]), F2 * (-A2[4] * A2[10] * A2[15] + A2[4] * A2[11] * A2[14] + A2[8] * A2[6] * A2[15] - A2[8] * A2[7] * A2[14] - A2[12] * A2[6] * A2[11] + A2[12] * A2[7] * A2[10]), F2 * (A2[0] * A2[10] * A2[15] - A2[0] * A2[11] * A2[14] - A2[8] * A2[2] * A2[15] + A2[8] * A2[3] * A2[14] + A2[12] * A2[2] * A2[11] - A2[12] * A2[3] * A2[10]), F2 * (-A2[0] * A2[6] * A2[15] + A2[0] * A2[7] * A2[14] + A2[4] * A2[2] * A2[15] - A2[4] * A2[3] * A2[14] - A2[12] * A2[2] * A2[7] + A2[12] * A2[3] * A2[6]), F2 * (A2[0] * A2[6] * A2[11] - A2[0] * A2[7] * A2[10] - A2[4] * A2[2] * A2[11] + A2[4] * A2[3] * A2[10] + A2[8] * A2[2] * A2[7] - A2[8] * A2[3] * A2[6]), F2 * (A2[4] * A2[9] * A2[15] - A2[4] * A2[11] * A2[13] - A2[8] * A2[5] * A2[15] + A2[8] * A2[7] * A2[13] + A2[12] * A2[5] * A2[11] - A2[12] * A2[7] * A2[9]), F2 * (-A2[0] * A2[9] * A2[15] + A2[0] * A2[11] * A2[13] + A2[8] * A2[1] * A2[15] - A2[8] * A2[3] * A2[13] - A2[12] * A2[1] * A2[11] + A2[12] * A2[3] * A2[9]), F2 * (A2[0] * A2[5] * A2[15] - A2[0] * A2[7] * A2[13] - A2[4] * A2[1] * A2[15] + A2[4] * A2[3] * A2[13] + A2[12] * A2[1] * A2[7] - A2[12] * A2[3] * A2[5]), F2 * (-A2[0] * A2[5] * A2[11] + A2[0] * A2[7] * A2[9] + A2[4] * A2[1] * A2[11] - A2[4] * A2[3] * A2[9] - A2[8] * A2[1] * A2[7] + A2[8] * A2[3] * A2[5]), F2 * (-A2[4] * A2[9] * A2[14] + A2[4] * A2[10] * A2[13] + A2[8] * A2[5] * A2[14] - A2[8] * A2[6] * A2[13] - A2[12] * A2[5] * A2[10] + A2[12] * A2[6] * A2[9]), F2 * (A2[0] * A2[9] * A2[14] - A2[0] * A2[10] * A2[13] - A2[8] * A2[1] * A2[14] + A2[8] * A2[2] * A2[13] + A2[12] * A2[1] * A2[10] - A2[12] * A2[2] * A2[9]), F2 * (-A2[0] * A2[5] * A2[14] + A2[0] * A2[6] * A2[13] + A2[4] * A2[1] * A2[14] - A2[4] * A2[2] * A2[13] - A2[12] * A2[1] * A2[6] + A2[12] * A2[2] * A2[5]), F2 * (A2[0] * A2[5] * A2[10] - A2[0] * A2[6] * A2[9] - A2[4] * A2[1] * A2[10] + A2[4] * A2[2] * A2[9] + A2[8] * A2[1] * A2[6] - A2[8] * A2[2] * A2[5]));
  }
  static Compose(A2, Q2, F2) {
    const B2 = Q2.x, l2 = Q2.y, t2 = Q2.z, d2 = Q2.w, n2 = B2 + B2, V2 = l2 + l2, Z2 = t2 + t2, I2 = B2 * n2, e2 = B2 * V2, R2 = B2 * Z2, a2 = l2 * V2, g2 = l2 * Z2, i2 = t2 * Z2, c2 = d2 * n2, C2 = d2 * V2, W2 = d2 * Z2, h2 = F2.x, s2 = F2.y, o2 = F2.z;
    return new _U((1 - (a2 + i2)) * h2, (e2 + W2) * h2, (R2 - C2) * h2, 0, (e2 - W2) * s2, (1 - (I2 + i2)) * s2, (g2 + c2) * s2, 0, (R2 + C2) * o2, (g2 - c2) * o2, (1 - (I2 + a2)) * o2, 0, A2.x, A2.y, A2.z, 1);
  }
  toString() {
    return `[${this.buffer.join(", ")}]`;
  }
};
var B = class extends Event {
  constructor(A2) {
    super("objectAdded"), this.object = A2;
  }
};
var l = class extends Event {
  constructor(A2) {
    super("objectRemoved"), this.object = A2;
  }
};
var t = class extends Event {
  constructor(A2) {
    super("objectChanged"), this.object = A2;
  }
};
var d = class extends F {
  constructor() {
    super(), this.positionChanged = false, this.rotationChanged = false, this.scaleChanged = false, this._position = new A(), this._rotation = new Q(), this._scale = new A(1, 1, 1), this._transform = new U(), this._changeEvent = new t(this), this.update = () => {
    }, this.applyPosition = () => {
      this.position = new A();
    }, this.applyRotation = () => {
      this.rotation = new Q();
    }, this.applyScale = () => {
      this.scale = new A(1, 1, 1);
    };
  }
  _updateMatrix() {
    this._transform = U.Compose(this._position, this._rotation, this._scale);
  }
  get position() {
    return this._position;
  }
  set position(A2) {
    this._position.equals(A2) || (this._position = A2, this.positionChanged = true, this._updateMatrix(), this.dispatchEvent(this._changeEvent));
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(A2) {
    this._rotation.equals(A2) || (this._rotation = A2, this.rotationChanged = true, this._updateMatrix(), this.dispatchEvent(this._changeEvent));
  }
  get scale() {
    return this._scale;
  }
  set scale(A2) {
    this._scale.equals(A2) || (this._scale = A2, this.scaleChanged = true, this._updateMatrix(), this.dispatchEvent(this._changeEvent));
  }
  get forward() {
    let Q2 = new A(0, 0, 1);
    return Q2 = this.rotation.apply(Q2), Q2;
  }
  get transform() {
    return this._transform;
  }
};
var n = class _n {
  constructor(A2 = 1, Q2 = 0, F2 = 0, U2 = 0, B2 = 1, l2 = 0, t2 = 0, d2 = 0, n2 = 1) {
    this.buffer = [A2, Q2, F2, U2, B2, l2, t2, d2, n2];
  }
  equals(A2) {
    if (this.buffer.length !== A2.buffer.length)
      return false;
    if (this.buffer === A2.buffer)
      return true;
    for (let Q2 = 0; Q2 < this.buffer.length; Q2++)
      if (this.buffer[Q2] !== A2.buffer[Q2])
        return false;
    return true;
  }
  multiply(A2) {
    const Q2 = this.buffer, F2 = A2.buffer;
    return new _n(F2[0] * Q2[0] + F2[3] * Q2[1] + F2[6] * Q2[2], F2[1] * Q2[0] + F2[4] * Q2[1] + F2[7] * Q2[2], F2[2] * Q2[0] + F2[5] * Q2[1] + F2[8] * Q2[2], F2[0] * Q2[3] + F2[3] * Q2[4] + F2[6] * Q2[5], F2[1] * Q2[3] + F2[4] * Q2[4] + F2[7] * Q2[5], F2[2] * Q2[3] + F2[5] * Q2[4] + F2[8] * Q2[5], F2[0] * Q2[6] + F2[3] * Q2[7] + F2[6] * Q2[8], F2[1] * Q2[6] + F2[4] * Q2[7] + F2[7] * Q2[8], F2[2] * Q2[6] + F2[5] * Q2[7] + F2[8] * Q2[8]);
  }
  clone() {
    const A2 = this.buffer;
    return new _n(A2[0], A2[1], A2[2], A2[3], A2[4], A2[5], A2[6], A2[7], A2[8]);
  }
  static Eye(A2 = 1) {
    return new _n(A2, 0, 0, 0, A2, 0, 0, 0, A2);
  }
  static Diagonal(A2) {
    return new _n(A2.x, 0, 0, 0, A2.y, 0, 0, 0, A2.z);
  }
  static RotationFromQuaternion(A2) {
    return new _n(1 - 2 * A2.y * A2.y - 2 * A2.z * A2.z, 2 * A2.x * A2.y - 2 * A2.z * A2.w, 2 * A2.x * A2.z + 2 * A2.y * A2.w, 2 * A2.x * A2.y + 2 * A2.z * A2.w, 1 - 2 * A2.x * A2.x - 2 * A2.z * A2.z, 2 * A2.y * A2.z - 2 * A2.x * A2.w, 2 * A2.x * A2.z - 2 * A2.y * A2.w, 2 * A2.y * A2.z + 2 * A2.x * A2.w, 1 - 2 * A2.x * A2.x - 2 * A2.y * A2.y);
  }
  static RotationFromEuler(A2) {
    const Q2 = Math.cos(A2.x), F2 = Math.sin(A2.x), U2 = Math.cos(A2.y), B2 = Math.sin(A2.y), l2 = Math.cos(A2.z), t2 = Math.sin(A2.z);
    return new _n(...[U2 * l2 + B2 * F2 * t2, -U2 * t2 + B2 * F2 * l2, B2 * Q2, Q2 * t2, Q2 * l2, -F2, -B2 * l2 + U2 * F2 * t2, B2 * t2 + U2 * F2 * l2, U2 * Q2]);
  }
  toString() {
    return `[${this.buffer.join(", ")}]`;
  }
};
var V = class _V {
  constructor(A2 = 0, F2 = null, U2 = null, B2 = null, l2 = null) {
    this.changed = false, this.detached = false, this._vertexCount = A2, this._positions = F2 || new Float32Array(0), this._rotations = U2 || new Float32Array(0), this._scales = B2 || new Float32Array(0), this._colors = l2 || new Uint8Array(0), this._selection = new Uint8Array(this.vertexCount), this.translate = (A3) => {
      for (let Q2 = 0; Q2 < this.vertexCount; Q2++)
        this.positions[3 * Q2 + 0] += A3.x, this.positions[3 * Q2 + 1] += A3.y, this.positions[3 * Q2 + 2] += A3.z;
      this.changed = true;
    }, this.rotate = (A3) => {
      const F3 = n.RotationFromQuaternion(A3).buffer;
      for (let U3 = 0; U3 < this.vertexCount; U3++) {
        const B3 = this.positions[3 * U3 + 0], l3 = this.positions[3 * U3 + 1], t2 = this.positions[3 * U3 + 2];
        this.positions[3 * U3 + 0] = F3[0] * B3 + F3[1] * l3 + F3[2] * t2, this.positions[3 * U3 + 1] = F3[3] * B3 + F3[4] * l3 + F3[5] * t2, this.positions[3 * U3 + 2] = F3[6] * B3 + F3[7] * l3 + F3[8] * t2;
        const d2 = new Q(this.rotations[4 * U3 + 1], this.rotations[4 * U3 + 2], this.rotations[4 * U3 + 3], this.rotations[4 * U3 + 0]), n2 = A3.multiply(d2);
        this.rotations[4 * U3 + 1] = n2.x, this.rotations[4 * U3 + 2] = n2.y, this.rotations[4 * U3 + 3] = n2.z, this.rotations[4 * U3 + 0] = n2.w;
      }
      this.changed = true;
    }, this.scale = (A3) => {
      for (let Q2 = 0; Q2 < this.vertexCount; Q2++)
        this.positions[3 * Q2 + 0] *= A3.x, this.positions[3 * Q2 + 1] *= A3.y, this.positions[3 * Q2 + 2] *= A3.z, this.scales[3 * Q2 + 0] *= A3.x, this.scales[3 * Q2 + 1] *= A3.y, this.scales[3 * Q2 + 2] *= A3.z;
      this.changed = true;
    }, this.serialize = () => {
      const A3 = new Uint8Array(this.vertexCount * _V.RowLength), Q2 = new Float32Array(A3.buffer), F3 = new Uint8Array(A3.buffer);
      for (let A4 = 0; A4 < this.vertexCount; A4++)
        Q2[8 * A4 + 0] = this.positions[3 * A4 + 0], Q2[8 * A4 + 1] = this.positions[3 * A4 + 1], Q2[8 * A4 + 2] = this.positions[3 * A4 + 2], F3[32 * A4 + 24 + 0] = this.colors[4 * A4 + 0], F3[32 * A4 + 24 + 1] = this.colors[4 * A4 + 1], F3[32 * A4 + 24 + 2] = this.colors[4 * A4 + 2], F3[32 * A4 + 24 + 3] = this.colors[4 * A4 + 3], Q2[8 * A4 + 3 + 0] = this.scales[3 * A4 + 0], Q2[8 * A4 + 3 + 1] = this.scales[3 * A4 + 1], Q2[8 * A4 + 3 + 2] = this.scales[3 * A4 + 2], F3[32 * A4 + 28 + 0] = 128 * this.rotations[4 * A4 + 0] + 128 & 255, F3[32 * A4 + 28 + 1] = 128 * this.rotations[4 * A4 + 1] + 128 & 255, F3[32 * A4 + 28 + 2] = 128 * this.rotations[4 * A4 + 2] + 128 & 255, F3[32 * A4 + 28 + 3] = 128 * this.rotations[4 * A4 + 3] + 128 & 255;
      return A3;
    }, this.reattach = (A3, Q2, F3, U3, B3) => {
      console.assert(A3.byteLength === 3 * this.vertexCount * 4, `Expected ${3 * this.vertexCount * 4} bytes, got ${A3.byteLength} bytes`), this._positions = new Float32Array(A3), this._rotations = new Float32Array(Q2), this._scales = new Float32Array(F3), this._colors = new Uint8Array(U3), this._selection = new Uint8Array(B3), this.detached = false;
    };
  }
  static Deserialize(A2) {
    const Q2 = A2.length / _V.RowLength, F2 = new Float32Array(3 * Q2), U2 = new Float32Array(4 * Q2), B2 = new Float32Array(3 * Q2), l2 = new Uint8Array(4 * Q2), t2 = new Float32Array(A2.buffer), d2 = new Uint8Array(A2.buffer);
    for (let A3 = 0; A3 < Q2; A3++)
      F2[3 * A3 + 0] = t2[8 * A3 + 0], F2[3 * A3 + 1] = t2[8 * A3 + 1], F2[3 * A3 + 2] = t2[8 * A3 + 2], U2[4 * A3 + 0] = (d2[32 * A3 + 28 + 0] - 128) / 128, U2[4 * A3 + 1] = (d2[32 * A3 + 28 + 1] - 128) / 128, U2[4 * A3 + 2] = (d2[32 * A3 + 28 + 2] - 128) / 128, U2[4 * A3 + 3] = (d2[32 * A3 + 28 + 3] - 128) / 128, B2[3 * A3 + 0] = t2[8 * A3 + 3 + 0], B2[3 * A3 + 1] = t2[8 * A3 + 3 + 1], B2[3 * A3 + 2] = t2[8 * A3 + 3 + 2], l2[4 * A3 + 0] = d2[32 * A3 + 24 + 0], l2[4 * A3 + 1] = d2[32 * A3 + 24 + 1], l2[4 * A3 + 2] = d2[32 * A3 + 24 + 2], l2[4 * A3 + 3] = d2[32 * A3 + 24 + 3];
    return new _V(Q2, F2, U2, B2, l2);
  }
  get vertexCount() {
    return this._vertexCount;
  }
  get positions() {
    return this._positions;
  }
  get rotations() {
    return this._rotations;
  }
  get scales() {
    return this._scales;
  }
  get colors() {
    return this._colors;
  }
  get selection() {
    return this._selection;
  }
};
V.RowLength = 32;
var Z = class {
  static SplatToPLY(A2, F2) {
    let U2 = "ply\nformat binary_little_endian 1.0\n";
    U2 += `element vertex ${F2}
`;
    const B2 = ["x", "y", "z", "nx", "ny", "nz", "f_dc_0", "f_dc_1", "f_dc_2"];
    for (let A3 = 0; A3 < 45; A3++)
      B2.push(`f_rest_${A3}`);
    B2.push("opacity"), B2.push("scale_0"), B2.push("scale_1"), B2.push("scale_2"), B2.push("rot_0"), B2.push("rot_1"), B2.push("rot_2"), B2.push("rot_3");
    for (const A3 of B2)
      U2 += `property float ${A3}
`;
    U2 += "end_header\n";
    const l2 = new TextEncoder().encode(U2), t2 = 248, d2 = F2 * t2, n2 = new DataView(new ArrayBuffer(l2.length + d2));
    new Uint8Array(n2.buffer).set(l2, 0);
    const V2 = new Float32Array(A2), Z2 = new Uint8Array(A2), I2 = l2.length, e2 = 220, R2 = 232;
    for (let A3 = 0; A3 < F2; A3++) {
      const F3 = V2[8 * A3 + 0], U3 = V2[8 * A3 + 1], B3 = V2[8 * A3 + 2], l3 = (Z2[32 * A3 + 24 + 0] / 255 - 0.5) / this.SH_C0, d3 = (Z2[32 * A3 + 24 + 1] / 255 - 0.5) / this.SH_C0, a2 = (Z2[32 * A3 + 24 + 2] / 255 - 0.5) / this.SH_C0, g2 = Z2[32 * A3 + 24 + 3] / 255, i2 = Math.log(g2 / (1 - g2)), c2 = Math.log(V2[8 * A3 + 3 + 0]), C2 = Math.log(V2[8 * A3 + 3 + 1]), W2 = Math.log(V2[8 * A3 + 3 + 2]);
      let h2 = new Q((Z2[32 * A3 + 28 + 1] - 128) / 128, (Z2[32 * A3 + 28 + 2] - 128) / 128, (Z2[32 * A3 + 28 + 3] - 128) / 128, (Z2[32 * A3 + 28 + 0] - 128) / 128);
      h2 = h2.normalize();
      const s2 = h2.w, o2 = h2.x, J2 = h2.y, r2 = h2.z;
      n2.setFloat32(I2 + t2 * A3 + 0, F3, true), n2.setFloat32(I2 + t2 * A3 + 4, U3, true), n2.setFloat32(I2 + t2 * A3 + 8, B3, true), n2.setFloat32(I2 + t2 * A3 + 24 + 0, l3, true), n2.setFloat32(I2 + t2 * A3 + 24 + 4, d3, true), n2.setFloat32(I2 + t2 * A3 + 24 + 8, a2, true), n2.setFloat32(I2 + t2 * A3 + 216, i2, true), n2.setFloat32(I2 + t2 * A3 + e2 + 0, c2, true), n2.setFloat32(I2 + t2 * A3 + e2 + 4, C2, true), n2.setFloat32(I2 + t2 * A3 + e2 + 8, W2, true), n2.setFloat32(I2 + t2 * A3 + R2 + 0, s2, true), n2.setFloat32(I2 + t2 * A3 + R2 + 4, o2, true), n2.setFloat32(I2 + t2 * A3 + R2 + 8, J2, true), n2.setFloat32(I2 + t2 * A3 + R2 + 12, r2, true);
    }
    return n2.buffer;
  }
};
Z.SH_C0 = 0.28209479177387814;
var I = class extends d {
  constructor(F2 = void 0) {
    super(), this.selectedChanged = false, this._selected = false, this._data = F2 || new V(), this.applyPosition = () => {
      this.data.translate(this.position), this.position = new A();
    }, this.applyRotation = () => {
      this.data.rotate(this.rotation), this.rotation = new Q();
    }, this.applyScale = () => {
      this.data.scale(this.scale), this.scale = new A(1, 1, 1);
    };
  }
  saveToFile(A2 = null, Q2 = null) {
    if (!document)
      return;
    if (Q2) {
      if ("splat" !== Q2 && "ply" !== Q2)
        throw new Error("Invalid format. Must be 'splat' or 'ply'");
    } else
      Q2 = "splat";
    if (!A2) {
      const F3 = /* @__PURE__ */ new Date();
      A2 = `splat-${F3.getFullYear()}-${F3.getMonth() + 1}-${F3.getDate()}.${Q2}`;
    }
    this.applyRotation(), this.applyScale(), this.applyPosition();
    const F2 = this.data.serialize();
    let U2;
    if ("ply" === Q2) {
      const A3 = Z.SplatToPLY(F2.buffer, this.data.vertexCount);
      U2 = new Blob([A3], { type: "application/octet-stream" });
    } else
      U2 = new Blob([F2.buffer], { type: "application/octet-stream" });
    const B2 = document.createElement("a");
    B2.download = A2, B2.href = URL.createObjectURL(U2), B2.click();
  }
  get data() {
    return this._data;
  }
  get selected() {
    return this._selected;
  }
  set selected(A2) {
    this._selected !== A2 && (this._selected = A2, this.selectedChanged = true, this.dispatchEvent(this._changeEvent));
  }
};
var e = class {
  constructor() {
    this._fx = 1132, this._fy = 1132, this._near = 0.1, this._far = 100, this._width = 512, this._height = 512, this._projectionMatrix = new U(), this._viewMatrix = new U(), this._viewProj = new U(), this._updateProjectionMatrix = () => {
      this._projectionMatrix = new U(2 * this.fx / this.width, 0, 0, 0, 0, -2 * this.fy / this.height, 0, 0, 0, 0, this.far / (this.far - this.near), 1, 0, 0, -this.far * this.near / (this.far - this.near), 0), this._viewProj = this.projectionMatrix.multiply(this.viewMatrix);
    }, this.update = (A2, Q2) => {
      const F2 = n.RotationFromQuaternion(Q2).buffer, B2 = A2.flat();
      this._viewMatrix = new U(F2[0], F2[1], F2[2], 0, F2[3], F2[4], F2[5], 0, F2[6], F2[7], F2[8], 0, -B2[0] * F2[0] - B2[1] * F2[3] - B2[2] * F2[6], -B2[0] * F2[1] - B2[1] * F2[4] - B2[2] * F2[7], -B2[0] * F2[2] - B2[1] * F2[5] - B2[2] * F2[8], 1), this._viewProj = this.projectionMatrix.multiply(this.viewMatrix);
    }, this.setSize = (A2, Q2) => {
      this._width = A2, this._height = Q2, this._updateProjectionMatrix();
    };
  }
  get fx() {
    return this._fx;
  }
  set fx(A2) {
    this._fx !== A2 && (this._fx = A2, this._updateProjectionMatrix());
  }
  get fy() {
    return this._fy;
  }
  set fy(A2) {
    this._fy !== A2 && (this._fy = A2, this._updateProjectionMatrix());
  }
  get near() {
    return this._near;
  }
  set near(A2) {
    this._near !== A2 && (this._near = A2, this._updateProjectionMatrix());
  }
  get far() {
    return this._far;
  }
  set far(A2) {
    this._far !== A2 && (this._far = A2, this._updateProjectionMatrix());
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get projectionMatrix() {
    return this._projectionMatrix;
  }
  get viewMatrix() {
    return this._viewMatrix;
  }
  get viewProj() {
    return this._viewProj;
  }
};
var R = class _R {
  constructor(A2 = 0, Q2 = 0, F2 = 0, U2 = 0) {
    this.x = A2, this.y = Q2, this.z = F2, this.w = U2;
  }
  equals(A2) {
    return this.x === A2.x && (this.y === A2.y && (this.z === A2.z && this.w === A2.w));
  }
  add(A2) {
    return "number" == typeof A2 ? new _R(this.x + A2, this.y + A2, this.z + A2, this.w + A2) : new _R(this.x + A2.x, this.y + A2.y, this.z + A2.z, this.w + A2.w);
  }
  subtract(A2) {
    return "number" == typeof A2 ? new _R(this.x - A2, this.y - A2, this.z - A2, this.w - A2) : new _R(this.x - A2.x, this.y - A2.y, this.z - A2.z, this.w - A2.w);
  }
  multiply(A2) {
    return "number" == typeof A2 ? new _R(this.x * A2, this.y * A2, this.z * A2, this.w * A2) : A2 instanceof _R ? new _R(this.x * A2.x, this.y * A2.y, this.z * A2.z, this.w * A2.w) : new _R(this.x * A2.buffer[0] + this.y * A2.buffer[4] + this.z * A2.buffer[8] + this.w * A2.buffer[12], this.x * A2.buffer[1] + this.y * A2.buffer[5] + this.z * A2.buffer[9] + this.w * A2.buffer[13], this.x * A2.buffer[2] + this.y * A2.buffer[6] + this.z * A2.buffer[10] + this.w * A2.buffer[14], this.x * A2.buffer[3] + this.y * A2.buffer[7] + this.z * A2.buffer[11] + this.w * A2.buffer[15]);
  }
  dot(A2) {
    return this.x * A2.x + this.y * A2.y + this.z * A2.z + this.w * A2.w;
  }
  lerp(A2, Q2) {
    return new _R(this.x + (A2.x - this.x) * Q2, this.y + (A2.y - this.y) * Q2, this.z + (A2.z - this.z) * Q2, this.w + (A2.w - this.w) * Q2);
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  distanceTo(A2) {
    return Math.sqrt((this.x - A2.x) ** 2 + (this.y - A2.y) ** 2 + (this.z - A2.z) ** 2 + (this.w - A2.w) ** 2);
  }
  normalize() {
    const A2 = this.magnitude();
    return new _R(this.x / A2, this.y / A2, this.z / A2, this.w / A2);
  }
  flat() {
    return [this.x, this.y, this.z, this.w];
  }
  clone() {
    return new _R(this.x, this.y, this.z, this.w);
  }
  toString() {
    return `[${this.flat().join(", ")}]`;
  }
};
var a = class extends d {
  constructor(Q2 = void 0) {
    super(), this._data = Q2 || new e(), this._position = new A(0, 0, -5), this.update = () => {
      this.data.update(this.position, this.rotation);
    }, this.screenPointToRay = (Q3, F2) => {
      const U2 = new R(Q3, F2, -1, 1), B2 = this._data.projectionMatrix.invert(), l2 = U2.multiply(B2), t2 = this._data.viewMatrix.invert(), d2 = l2.multiply(t2);
      return new A(d2.x / d2.w, d2.y / d2.w, d2.z / d2.w).subtract(this.position).normalize();
    };
  }
  get data() {
    return this._data;
  }
};
var g = class extends F {
  constructor() {
    super(), this._objects = [], this.addObject = (A2) => {
      this.objects.push(A2), this.dispatchEvent(new B(A2));
    }, this.removeObject = (A2) => {
      const Q2 = this.objects.indexOf(A2);
      if (Q2 < 0)
        throw new Error("Object not found in scene");
      this.objects.splice(Q2, 1), this.dispatchEvent(new l(A2));
    }, this.findObject = (A2) => {
      for (const Q2 of this.objects)
        if (A2(Q2))
          return Q2;
    }, this.findObjectOfType = (A2) => {
      for (const Q2 of this.objects)
        if (Q2 instanceof A2)
          return Q2;
    }, this.reset = () => {
      const A2 = this.objects.slice();
      for (const Q2 of A2)
        this.removeObject(Q2);
    }, this.reset();
  }
  saveToFile(A2 = null, Q2 = null) {
    if (!document)
      return;
    if (Q2) {
      if ("splat" !== Q2 && "ply" !== Q2)
        throw new Error("Invalid format. Must be 'splat' or 'ply'");
    } else
      Q2 = "splat";
    if (!A2) {
      const F3 = /* @__PURE__ */ new Date();
      A2 = `scene-${F3.getFullYear()}-${F3.getMonth() + 1}-${F3.getDate()}.${Q2}`;
    }
    const F2 = [];
    let U2 = 0;
    for (const A3 of this.objects)
      if (A3.applyRotation(), A3.applyScale(), A3.applyPosition(), A3 instanceof I) {
        const Q3 = A3.data.serialize();
        F2.push(Q3), U2 += A3.data.vertexCount;
      }
    const B2 = new Uint8Array(U2 * V.RowLength);
    let l2, t2 = 0;
    for (const A3 of F2)
      B2.set(A3, t2), t2 += A3.length;
    if ("ply" === Q2) {
      const A3 = Z.SplatToPLY(B2.buffer, U2);
      l2 = new Blob([A3], { type: "application/octet-stream" });
    } else
      l2 = new Blob([B2.buffer], { type: "application/octet-stream" });
    const d2 = document.createElement("a");
    d2.download = A2, d2.href = URL.createObjectURL(l2), d2.click();
  }
  get objects() {
    return this._objects;
  }
};
async function i(A2, Q2) {
  const F2 = await fetch(A2, { mode: "cors", credentials: "omit", cache: Q2 ? "force-cache" : "default" });
  if (200 != F2.status)
    throw new Error(F2.status + " Unable to load " + F2.url);
  return F2;
}
async function c(A2, Q2) {
  return A2.headers.has("content-length") ? async function(A3, Q3) {
    const F2 = A3.body.getReader(), U2 = parseInt(A3.headers.get("content-length")), B2 = new Uint8Array(U2);
    let l2 = 0;
    for (; ; ) {
      const { done: A4, value: t2 } = await F2.read();
      if (A4)
        break;
      B2.set(t2, l2), l2 += t2.length, null == Q3 || Q3(l2 / U2);
    }
    return B2;
  }(A2, Q2) : async function(A3, Q3) {
    const F2 = A3.body.getReader(), U2 = [];
    let B2 = 0;
    for (; ; ) {
      const { done: A4, value: Q4 } = await F2.read();
      if (A4)
        break;
      U2.push(Q4), B2 += Q4.length;
    }
    const l2 = new Uint8Array(B2);
    let t2 = 0;
    for (const A4 of U2)
      l2.set(A4, t2), t2 += A4.length, null == Q3 || Q3(t2 / B2);
    return l2;
  }(A2, Q2);
}
var C = class {
  static async LoadAsync(A2, Q2, F2, U2 = false) {
    const B2 = await i(A2, U2), l2 = await c(B2, F2), t2 = V.Deserialize(l2), d2 = new I(t2);
    return Q2.addObject(d2), d2;
  }
  static async LoadFromFileAsync(A2, Q2, F2) {
    const U2 = new FileReader();
    let B2 = new I();
    return U2.onload = (A3) => {
      const F3 = new Uint8Array(A3.target.result), U3 = V.Deserialize(F3);
      B2 = new I(U3), Q2.addObject(B2);
    }, U2.onprogress = (A3) => {
      null == F2 || F2(A3.loaded / A3.total);
    }, U2.readAsArrayBuffer(A2), await new Promise((A3) => {
      U2.onloadend = () => {
        A3();
      };
    }), B2;
  }
};
var W = class {
  static async LoadAsync(A2, Q2, F2, U2 = "", B2 = false) {
    const l2 = await i(A2, B2), t2 = await c(l2, F2);
    if (112 !== t2[0] || 108 !== t2[1] || 121 !== t2[2] || 10 !== t2[3])
      throw new Error("Invalid PLY file");
    const d2 = new Uint8Array(this._ParsePLYBuffer(t2.buffer, U2)), n2 = V.Deserialize(d2), Z2 = new I(n2);
    return Q2.addObject(Z2), Z2;
  }
  static async LoadFromFileAsync(A2, Q2, F2, U2 = "") {
    const B2 = new FileReader();
    let l2 = new I();
    return B2.onload = (A3) => {
      const F3 = new Uint8Array(this._ParsePLYBuffer(A3.target.result, U2)), B3 = V.Deserialize(F3);
      l2 = new I(B3), Q2.addObject(l2);
    }, B2.onprogress = (A3) => {
      null == F2 || F2(A3.loaded / A3.total);
    }, B2.readAsArrayBuffer(A2), await new Promise((A3) => {
      B2.onloadend = () => {
        A3();
      };
    }), l2;
  }
  static _ParsePLYBuffer(F2, U2) {
    const B2 = new Uint8Array(F2), l2 = new TextDecoder().decode(B2.slice(0, 10240)), t2 = "end_header\n", d2 = l2.indexOf(t2);
    if (d2 < 0)
      throw new Error("Unable to read .ply file header");
    const n2 = parseInt(/element vertex (\d+)\n/.exec(l2)[1]);
    let I2 = 0;
    const e2 = { double: 8, int: 4, uint: 4, float: 4, short: 2, ushort: 2, uchar: 1 }, R2 = [];
    for (const A2 of l2.slice(0, d2).split("\n").filter((A3) => A3.startsWith("property "))) {
      const [Q2, F3, U3] = A2.split(" ");
      if (R2.push({ name: U3, type: F3, offset: I2 }), !e2[F3])
        throw new Error(`Unsupported property type: ${F3}`);
      I2 += e2[F3];
    }
    const a2 = new DataView(F2, d2 + 11), g2 = new ArrayBuffer(V.RowLength * n2), i2 = Q.FromEuler(new A(Math.PI / 2, 0, 0));
    for (let A2 = 0; A2 < n2; A2++) {
      const F3 = new Float32Array(g2, A2 * V.RowLength, 3), B3 = new Float32Array(g2, A2 * V.RowLength + 12, 3), l3 = new Uint8ClampedArray(g2, A2 * V.RowLength + 24, 4), t3 = new Uint8ClampedArray(g2, A2 * V.RowLength + 28, 4);
      let d3 = 255, n3 = 0, e3 = 0, c2 = 0;
      R2.forEach((Q2) => {
        let U3;
        switch (Q2.type) {
          case "float":
            U3 = a2.getFloat32(Q2.offset + A2 * I2, true);
            break;
          case "int":
            U3 = a2.getInt32(Q2.offset + A2 * I2, true);
            break;
          default:
            throw new Error(`Unsupported property type: ${Q2.type}`);
        }
        switch (Q2.name) {
          case "x":
            F3[0] = U3;
            break;
          case "y":
            F3[1] = U3;
            break;
          case "z":
            F3[2] = U3;
            break;
          case "scale_0":
            B3[0] = Math.exp(U3);
            break;
          case "scale_1":
            B3[1] = Math.exp(U3);
            break;
          case "scale_2":
            B3[2] = Math.exp(U3);
            break;
          case "red":
            l3[0] = U3;
            break;
          case "green":
            l3[1] = U3;
            break;
          case "blue":
            l3[2] = U3;
            break;
          case "f_dc_0":
            l3[0] = 255 * (0.5 + Z.SH_C0 * U3);
            break;
          case "f_dc_1":
            l3[1] = 255 * (0.5 + Z.SH_C0 * U3);
            break;
          case "f_dc_2":
            l3[2] = 255 * (0.5 + Z.SH_C0 * U3);
            break;
          case "f_dc_3":
            l3[3] = 255 * (0.5 + Z.SH_C0 * U3);
            break;
          case "opacity":
            l3[3] = 1 / (1 + Math.exp(-U3)) * 255;
            break;
          case "rot_0":
            d3 = U3;
            break;
          case "rot_1":
            n3 = U3;
            break;
          case "rot_2":
            e3 = U3;
            break;
          case "rot_3":
            c2 = U3;
        }
      });
      let C2 = new Q(n3, e3, c2, d3);
      switch (U2) {
        case "polycam": {
          const A3 = F3[1];
          F3[1] = -F3[2], F3[2] = A3, C2 = i2.multiply(C2);
          break;
        }
        case "":
          break;
        default:
          throw new Error(`Unsupported format: ${U2}`);
      }
      C2 = C2.normalize(), t3[0] = 128 * C2.w + 128, t3[1] = 128 * C2.x + 128, t3[2] = 128 * C2.y + 128, t3[3] = 128 * C2.z + 128;
    }
    return g2;
  }
};
function h(A2, Q2, F2) {
  var U2 = void 0 === Q2 ? null : Q2, B2 = function(A3, Q3) {
    var F3 = atob(A3);
    if (Q3) {
      for (var U3 = new Uint8Array(F3.length), B3 = 0, l3 = F3.length; B3 < l3; ++B3)
        U3[B3] = F3.charCodeAt(B3);
      return String.fromCharCode.apply(null, new Uint16Array(U3.buffer));
    }
    return F3;
  }(A2, void 0 !== F2 && F2), l2 = B2.indexOf("\n", 10) + 1, t2 = B2.substring(l2) + (U2 ? "//# sourceMappingURL=" + U2 : ""), d2 = new Blob([t2], { type: "application/javascript" });
  return URL.createObjectURL(d2);
}
function s(A2, Q2, F2) {
  var U2;
  return function(B2) {
    return U2 = U2 || h(A2, Q2, F2), new Worker(U2, B2);
  };
}
var o = s("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgdmFyIGxvYWRXYXNtID0gKCgpID0+IHsKICAgIAogICAgcmV0dXJuICgKICBmdW5jdGlvbihtb2R1bGVBcmcgPSB7fSkgewoKICB2YXIgTW9kdWxlPW1vZHVsZUFyZzt2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSxyZWFkeVByb21pc2VSZWplY3Q7TW9kdWxlWyJyZWFkeSJdPW5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntyZWFkeVByb21pc2VSZXNvbHZlPXJlc29sdmU7cmVhZHlQcm9taXNlUmVqZWN0PXJlamVjdDt9KTt2YXIgbW9kdWxlT3ZlcnJpZGVzPU9iamVjdC5hc3NpZ24oe30sTW9kdWxlKTt2YXIgc2NyaXB0RGlyZWN0b3J5PSIiO2Z1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCl7aWYoTW9kdWxlWyJsb2NhdGVGaWxlIl0pe3JldHVybiBNb2R1bGVbImxvY2F0ZUZpbGUiXShwYXRoLHNjcmlwdERpcmVjdG9yeSl9cmV0dXJuIHNjcmlwdERpcmVjdG9yeStwYXRofXZhciByZWFkQmluYXJ5O3t7c2NyaXB0RGlyZWN0b3J5PXNlbGYubG9jYXRpb24uaHJlZjt9aWYoc2NyaXB0RGlyZWN0b3J5LnN0YXJ0c1dpdGgoImJsb2I6Iikpe3NjcmlwdERpcmVjdG9yeT0iIjt9ZWxzZSB7c2NyaXB0RGlyZWN0b3J5PXNjcmlwdERpcmVjdG9yeS5zdWJzdHIoMCxzY3JpcHREaXJlY3RvcnkucmVwbGFjZSgvWz8jXS4qLywiIikubGFzdEluZGV4T2YoIi8iKSsxKTt9e3tyZWFkQmluYXJ5PXVybD0+e3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKCJHRVQiLHVybCxmYWxzZSk7eGhyLnJlc3BvbnNlVHlwZT0iYXJyYXlidWZmZXIiO3hoci5zZW5kKG51bGwpO3JldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpfTt9fX1Nb2R1bGVbInByaW50Il18fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7dmFyIGVycj1Nb2R1bGVbInByaW50RXJyIl18fGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKE1vZHVsZSxtb2R1bGVPdmVycmlkZXMpO21vZHVsZU92ZXJyaWRlcz1udWxsO2lmKE1vZHVsZVsiYXJndW1lbnRzIl0pTW9kdWxlWyJhcmd1bWVudHMiXTtpZihNb2R1bGVbInRoaXNQcm9ncmFtIl0pTW9kdWxlWyJ0aGlzUHJvZ3JhbSJdO2lmKE1vZHVsZVsicXVpdCJdKU1vZHVsZVsicXVpdCJdO3ZhciB3YXNtQmluYXJ5O2lmKE1vZHVsZVsid2FzbUJpbmFyeSJdKXdhc21CaW5hcnk9TW9kdWxlWyJ3YXNtQmluYXJ5Il07aWYodHlwZW9mIFdlYkFzc2VtYmx5IT0ib2JqZWN0Iil7YWJvcnQoIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQiKTt9ZnVuY3Rpb24gaW50QXJyYXlGcm9tQmFzZTY0KHMpe3ZhciBkZWNvZGVkPWF0b2Iocyk7dmFyIGJ5dGVzPW5ldyBVaW50OEFycmF5KGRlY29kZWQubGVuZ3RoKTtmb3IodmFyIGk9MDtpPGRlY29kZWQubGVuZ3RoOysraSl7Ynl0ZXNbaV09ZGVjb2RlZC5jaGFyQ29kZUF0KGkpO31yZXR1cm4gYnl0ZXN9ZnVuY3Rpb24gdHJ5UGFyc2VBc0RhdGFVUkkoZmlsZW5hbWUpe2lmKCFpc0RhdGFVUkkoZmlsZW5hbWUpKXtyZXR1cm59cmV0dXJuIGludEFycmF5RnJvbUJhc2U2NChmaWxlbmFtZS5zbGljZShkYXRhVVJJUHJlZml4Lmxlbmd0aCkpfXZhciB3YXNtTWVtb3J5O3ZhciBBQk9SVD1mYWxzZTt2YXIgSEVBUDgsSEVBUFU4LEhFQVAxNixIRUFQVTE2LEhFQVAzMixIRUFQVTMyLEhFQVBGMzIsSEVBUEY2NDtmdW5jdGlvbiB1cGRhdGVNZW1vcnlWaWV3cygpe3ZhciBiPXdhc21NZW1vcnkuYnVmZmVyO01vZHVsZVsiSEVBUDgiXT1IRUFQOD1uZXcgSW50OEFycmF5KGIpO01vZHVsZVsiSEVBUDE2Il09SEVBUDE2PW5ldyBJbnQxNkFycmF5KGIpO01vZHVsZVsiSEVBUFU4Il09SEVBUFU4PW5ldyBVaW50OEFycmF5KGIpO01vZHVsZVsiSEVBUFUxNiJdPUhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGIpO01vZHVsZVsiSEVBUDMyIl09SEVBUDMyPW5ldyBJbnQzMkFycmF5KGIpO01vZHVsZVsiSEVBUFUzMiJdPUhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KGIpO01vZHVsZVsiSEVBUEYzMiJdPUhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheShiKTtNb2R1bGVbIkhFQVBGNjQiXT1IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkoYik7fXZhciBfX0FUUFJFUlVOX189W107dmFyIF9fQVRJTklUX189W107dmFyIF9fQVRQT1NUUlVOX189W107ZnVuY3Rpb24gcHJlUnVuKCl7aWYoTW9kdWxlWyJwcmVSdW4iXSl7aWYodHlwZW9mIE1vZHVsZVsicHJlUnVuIl09PSJmdW5jdGlvbiIpTW9kdWxlWyJwcmVSdW4iXT1bTW9kdWxlWyJwcmVSdW4iXV07d2hpbGUoTW9kdWxlWyJwcmVSdW4iXS5sZW5ndGgpe2FkZE9uUHJlUnVuKE1vZHVsZVsicHJlUnVuIl0uc2hpZnQoKSk7fX1jYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pO31mdW5jdGlvbiBpbml0UnVudGltZSgpe2NhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRJTklUX18pO31mdW5jdGlvbiBwb3N0UnVuKCl7aWYoTW9kdWxlWyJwb3N0UnVuIl0pe2lmKHR5cGVvZiBNb2R1bGVbInBvc3RSdW4iXT09ImZ1bmN0aW9uIilNb2R1bGVbInBvc3RSdW4iXT1bTW9kdWxlWyJwb3N0UnVuIl1dO3doaWxlKE1vZHVsZVsicG9zdFJ1biJdLmxlbmd0aCl7YWRkT25Qb3N0UnVuKE1vZHVsZVsicG9zdFJ1biJdLnNoaWZ0KCkpO319Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyk7fWZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKXtfX0FUUFJFUlVOX18udW5zaGlmdChjYik7fWZ1bmN0aW9uIGFkZE9uSW5pdChjYil7X19BVElOSVRfXy51bnNoaWZ0KGNiKTt9ZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKXtfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpO312YXIgcnVuRGVwZW5kZW5jaWVzPTA7dmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2Z1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpe3J1bkRlcGVuZGVuY2llcysrO01vZHVsZVsibW9uaXRvclJ1bkRlcGVuZGVuY2llcyJdPy4ocnVuRGVwZW5kZW5jaWVzKTt9ZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCl7cnVuRGVwZW5kZW5jaWVzLS07TW9kdWxlWyJtb25pdG9yUnVuRGVwZW5kZW5jaWVzIl0/LihydW5EZXBlbmRlbmNpZXMpO2lmKHJ1bkRlcGVuZGVuY2llcz09MCl7aWYoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKXt2YXIgY2FsbGJhY2s9ZGVwZW5kZW5jaWVzRnVsZmlsbGVkO2RlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2NhbGxiYWNrKCk7fX19ZnVuY3Rpb24gYWJvcnQod2hhdCl7TW9kdWxlWyJvbkFib3J0Il0/Lih3aGF0KTt3aGF0PSJBYm9ydGVkKCIrd2hhdCsiKSI7ZXJyKHdoYXQpO0FCT1JUPXRydWU7d2hhdCs9Ii4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby4iO3ZhciBlPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7cmVhZHlQcm9taXNlUmVqZWN0KGUpO3Rocm93IGV9dmFyIGRhdGFVUklQcmVmaXg9ImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCwiO3ZhciBpc0RhdGFVUkk9ZmlsZW5hbWU9PmZpbGVuYW1lLnN0YXJ0c1dpdGgoZGF0YVVSSVByZWZpeCk7dmFyIHdhc21CaW5hcnlGaWxlO3dhc21CaW5hcnlGaWxlPSJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsQUdGemJRRUFBQUFCV3cxZ0JIOS9mMzhBWUFOL2YzOEFZQVYvZjM5L2Z3QmdCbjkvZjM5L2Z3QmdBWDhCZjJBQmZ3QmdBMzkvZndGL1lBSi9md0JnQUFCZ0FuOS9BWDlnQjM5L2YzOS9mMzhBWUFSL2YzNStBR0FLZjM5L2YzOS9mMzkvZndBQ1BRb0JZUUZoQUFFQllRRmlBQUlCWVFGakFBRUJZUUZrQUFjQllRRmxBQUVCWVFGbUFBb0JZUUZuQUFRQllRRm9BQVVCWVFGcEFBQUJZUUZxQUFjREdSZ0dCQVVJQlFVSkN3Z0JBQUVFQkFNREFnSUFBQWtHQmd3RUJRRndBUkFRQlFjQkFZQUNnSUFDQmdnQmZ3RkJzSjRFQ3djWkJnRnJBZ0FCYkFBTkFXMEFJUUZ1QVFBQmJ3QVhBWEFBRHdrVkFRQkJBUXNQRWhZTURnNGdEQjhZR2gwTUdSc2NDc0pPR0hFQkFYOGdBa1VFUUNBQUtBSUVJQUVvQWdSR0R3c2dBQ0FCUmdSQVFRRVBDd0pBSUFBb0FnUWlBaTBBQUNJQVJTQUFJQUVvQWdRaUFTMEFBQ0lEUjNJTkFBTkFJQUV0QUFFaEF5QUNMUUFCSWdCRkRRRWdBVUVCYWlFQklBSkJBV29oQWlBQUlBTkdEUUFMQ3lBQUlBTkdDMDhCQW45QnFCb29BZ0FpQVNBQVFRZHFRWGh4SWdKcUlRQUNRQ0FDUVFBZ0FDQUJUUnRGQkVBZ0FEOEFRUkIwVFEwQklBQVFCZzBCQzBHNEdrRXdOZ0lBUVg4UEMwR29HaUFBTmdJQUlBRUxCZ0FnQUJBUEN5a0FRYkFhUVFFMkFnQkJ0QnBCQURZQ0FCQVNRYlFhUWF3YUtBSUFOZ0lBUWF3YVFiQWFOZ0lBQ3dJQUM5a0xBUWQvQWtBZ0FFVU5BQ0FBUVFocklnTWdBRUVFYXlnQ0FDSUJRWGh4SWdCcUlRVUNRQ0FCUVFGeERRQWdBVUVDY1VVTkFTQURJQU1vQWdBaUFXc2lBMEhNR2lnQ0FFa05BU0FBSUFGcUlRQUNRQUpBUWRBYUtBSUFJQU5IQkVBZ0F5Z0NEQ0VDSUFGQi93Rk5CRUFnQVVFRGRpRUJJQU1vQWdnaUJDQUNSZ1JBUWJ3YVFid2FLQUlBUVg0Z0FYZHhOZ0lBREFVTElBUWdBallDRENBQ0lBUTJBZ2dNQkFzZ0F5Z0NHQ0VHSUFJZ0EwY0VRQ0FES0FJSUlnRWdBallDRENBQ0lBRTJBZ2dNQXdzZ0F5Z0NGQ0lCQkg4Z0EwRVVhZ1VnQXlnQ0VDSUJSUTBDSUFOQkVHb0xJUVFEUUNBRUlRY2dBU0lDUVJScUlRUWdBaWdDRkNJQkRRQWdBa0VRYWlFRUlBSW9BaEFpQVEwQUN5QUhRUUEyQWdBTUFnc2dCU2dDQkNJQlFRTnhRUU5IRFFKQnhCb2dBRFlDQUNBRklBRkJmbkUyQWdRZ0F5QUFRUUZ5TmdJRUlBVWdBRFlDQUE4TFFRQWhBZ3NnQmtVTkFBSkFJQU1vQWh3aUFVRUNkRUhzSEdvaUJDZ0NBQ0FEUmdSQUlBUWdBallDQUNBQ0RRRkJ3QnBCd0Jvb0FnQkJmaUFCZDNFMkFnQU1BZ3NnQmtFUVFSUWdCaWdDRUNBRFJodHFJQUkyQWdBZ0FrVU5BUXNnQWlBR05nSVlJQU1vQWhBaUFRUkFJQUlnQVRZQ0VDQUJJQUkyQWhnTElBTW9BaFFpQVVVTkFDQUNJQUUyQWhRZ0FTQUNOZ0lZQ3lBRElBVlBEUUFnQlNnQ0JDSUJRUUZ4UlEwQUFrQUNRQUpBQWtBZ0FVRUNjVVVFUUVIVUdpZ0NBQ0FGUmdSQVFkUWFJQU0yQWdCQnlCcEJ5Qm9vQWdBZ0FHb2lBRFlDQUNBRElBQkJBWEkyQWdRZ0EwSFFHaWdDQUVjTkJrSEVHa0VBTmdJQVFkQWFRUUEyQWdBUEMwSFFHaWdDQUNBRlJnUkFRZEFhSUFNMkFnQkJ4QnBCeEJvb0FnQWdBR29pQURZQ0FDQURJQUJCQVhJMkFnUWdBQ0FEYWlBQU5nSUFEd3NnQVVGNGNTQUFhaUVBSUFVb0Fnd2hBaUFCUWY4QlRRUkFJQUZCQTNZaEFTQUZLQUlJSWdRZ0FrWUVRRUc4R2tHOEdpZ0NBRUYrSUFGM2NUWUNBQXdGQ3lBRUlBSTJBZ3dnQWlBRU5nSUlEQVFMSUFVb0FoZ2hCaUFDSUFWSEJFQkJ6Qm9vQWdBYUlBVW9BZ2dpQVNBQ05nSU1JQUlnQVRZQ0NBd0RDeUFGS0FJVUlnRUVmeUFGUVJScUJTQUZLQUlRSWdGRkRRSWdCVUVRYWdzaEJBTkFJQVFoQnlBQklnSkJGR29oQkNBQ0tBSVVJZ0VOQUNBQ1FSQnFJUVFnQWlnQ0VDSUJEUUFMSUFkQkFEWUNBQXdDQ3lBRklBRkJmbkUyQWdRZ0F5QUFRUUZ5TmdJRUlBQWdBMm9nQURZQ0FBd0RDMEVBSVFJTElBWkZEUUFDUUNBRktBSWNJZ0ZCQW5SQjdCeHFJZ1FvQWdBZ0JVWUVRQ0FFSUFJMkFnQWdBZzBCUWNBYVFjQWFLQUlBUVg0Z0FYZHhOZ0lBREFJTElBWkJFRUVVSUFZb0FoQWdCVVliYWlBQ05nSUFJQUpGRFFFTElBSWdCallDR0NBRktBSVFJZ0VFUUNBQ0lBRTJBaEFnQVNBQ05nSVlDeUFGS0FJVUlnRkZEUUFnQWlBQk5nSVVJQUVnQWpZQ0dBc2dBeUFBUVFGeU5nSUVJQUFnQTJvZ0FEWUNBQ0FEUWRBYUtBSUFSdzBBUWNRYUlBQTJBZ0FQQ3lBQVFmOEJUUVJBSUFCQmVIRkI1QnBxSVFFQ2YwRzhHaWdDQUNJRVFRRWdBRUVEZG5RaUFIRkZCRUJCdkJvZ0FDQUVjallDQUNBQkRBRUxJQUVvQWdnTElRQWdBU0FETmdJSUlBQWdBellDRENBRElBRTJBZ3dnQXlBQU5nSUlEd3RCSHlFQ0lBQkIvLy8vQjAwRVFDQUFRU1lnQUVFSWRtY2lBV3QyUVFGeElBRkJBWFJyUVQ1cUlRSUxJQU1nQWpZQ0hDQURRZ0EzQWhBZ0FrRUNkRUhzSEdvaEJ3Si9Ba0FDZjBIQUdpZ0NBQ0lCUVFFZ0FuUWlCSEZGQkVCQndCb2dBU0FFY2pZQ0FFRVlJUUlnQnlFRVFRZ01BUXNnQUVFWklBSkJBWFpyUVFBZ0FrRWZSeHQwSVFJZ0J5Z0NBQ0VFQTBBZ0JDSUJLQUlFUVhoeElBQkdEUUlnQWtFZGRpRUVJQUpCQVhRaEFpQUJJQVJCQkhGcVFSQnFJZ2NvQWdBaUJBMEFDMEVZSVFJZ0FTRUVRUWdMSVFBZ0F5SUJEQUVMSUFFb0FnZ2lCQ0FETmdJTVFRZ2hBaUFCUVFocUlRZEJHQ0VBUVFBTElRVWdCeUFETmdJQUlBSWdBMm9nQkRZQ0FDQURJQUUyQWd3Z0FDQURhaUFGTmdJQVFkd2FRZHdhS0FJQVFRRnJJZ0JCZnlBQUd6WUNBQXNMS1FFQmZ5QUJCRUFnQUNFQ0EwQWdBa0VBT2dBQUlBSkJBV29oQWlBQlFRRnJJZ0VOQUFzTElBQUxIQUFnQUNBQlFRZ2dBcWNnQWtJZ2lLY2dBNmNnQTBJZ2lLY1FCUXZlQXdCQjNCZEJpZ2tRQ1VIb0YwRzVDRUVCUVFBUUNFSDBGMEcwQ0VFQlFZQi9RZjhBRUFGQmpCaEJyUWhCQVVHQWYwSC9BQkFCUVlBWVFhc0lRUUZCQUVIL0FSQUJRWmdZUVlrSVFRSkJnSUIrUWYvL0FSQUJRYVFZUVlBSVFRSkJBRUgvL3dNUUFVR3dHRUdZQ0VFRVFZQ0FnSUI0UWYvLy8vOEhFQUZCdkJoQmp3aEJCRUVBUVg4UUFVSElHRUhIQ0VFRVFZQ0FnSUI0UWYvLy8vOEhFQUZCMUJoQnZnaEJCRUVBUVg4UUFVSGdHRUdqQ0VLQWdJQ0FnSUNBZ0lCL1F2Ly8vLy8vLy8vLy93QVFFVUhzR0VHaUNFSUFRbjhRRVVINEdFR2NDRUVFRUFSQmhCbEJnd2xCQ0JBRVFmUU9RZGtJRUFOQnZBOUJodzBRQTBHRUVFRUVRY3dJRUFKQjBCQkJBa0hsQ0JBQ1Fad1JRUVJCOUFnUUFrRzRFUkFIUWVBUlFRQkJ3Z3dRQUVHSUVrRUFRYWdORUFCQnNCSkJBVUhnREJBQVFkZ1NRUUpCandrUUFFR0FFMEVEUWE0SkVBQkJxQk5CQkVIV0NSQUFRZEFUUVFWQjh3a1FBRUg0RTBFRVFjME5FQUJCb0JSQkJVSHJEUkFBUVlnU1FRQkIyUW9RQUVHd0VrRUJRYmdLRUFCQjJCSkJBa0diQ3hBQVFZQVRRUU5CK1FvUUFFR29FMEVFUWFFTUVBQkIwQk5CQlVIL0N4QUFRY2dVUVFoQjNnc1FBRUh3RkVFSlFid0xFQUJCbUJWQkJrR1pDaEFBUWNBVlFRZEJrZzRRQUFzZ0FBSkFJQUFvQWdRZ0FVY05BQ0FBS0FJY1FRRkdEUUFnQUNBQ05nSWNDd3VhQVFBZ0FFRUJPZ0ExQWtBZ0FDZ0NCQ0FDUncwQUlBQkJBVG9BTkFKQUlBQW9BaEFpQWtVRVFDQUFRUUUyQWlRZ0FDQUROZ0lZSUFBZ0FUWUNFQ0FEUVFGSERRSWdBQ2dDTUVFQlJnMEJEQUlMSUFFZ0FrWUVRQ0FBS0FJWUlnSkJBa1lFUUNBQUlBTTJBaGdnQXlFQ0N5QUFLQUl3UVFGSERRSWdBa0VCUmcwQkRBSUxJQUFnQUNnQ0pFRUJhallDSkFzZ0FFRUJPZ0EyQ3d0ZEFRRi9JQUFvQWhBaUEwVUVRQ0FBUVFFMkFpUWdBQ0FDTmdJWUlBQWdBVFlDRUE4TEFrQWdBU0FEUmdSQUlBQW9BaGhCQWtjTkFTQUFJQUkyQWhnUEN5QUFRUUU2QURZZ0FFRUNOZ0lZSUFBZ0FDZ0NKRUVCYWpZQ0pBc0xCQUFnQUF2WEp3RU1meU1BUVJCcklnb2tBQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQjlBRk5CRUJCdkJvb0FnQWlCRUVRSUFCQkMycEIrQU54SUFCQkMwa2JJZ1pCQTNZaUFIWWlBVUVEY1FSQUFrQWdBVUYvYzBFQmNTQUFhaUlDUVFOMElnRkI1QnBxSWdBZ0FVSHNHbW9vQWdBaUFTZ0NDQ0lGUmdSQVFid2FJQVJCZmlBQ2QzRTJBZ0FNQVFzZ0JTQUFOZ0lNSUFBZ0JUWUNDQXNnQVVFSWFpRUFJQUVnQWtFRGRDSUNRUU55TmdJRUlBRWdBbW9pQVNBQktBSUVRUUZ5TmdJRURBc0xJQVpCeEJvb0FnQWlDRTBOQVNBQkJFQUNRRUVDSUFCMElnSkJBQ0FDYTNJZ0FTQUFkSEZvSWdGQkEzUWlBRUhrR21vaUFpQUFRZXdhYWlnQ0FDSUFLQUlJSWdWR0JFQkJ2Qm9nQkVGK0lBRjNjU0lFTmdJQURBRUxJQVVnQWpZQ0RDQUNJQVUyQWdnTElBQWdCa0VEY2pZQ0JDQUFJQVpxSWdjZ0FVRURkQ0lCSUFacklnVkJBWEkyQWdRZ0FDQUJhaUFGTmdJQUlBZ0VRQ0FJUVhoeFFlUWFhaUVCUWRBYUtBSUFJUUlDZnlBRVFRRWdDRUVEZG5RaUEzRkZCRUJCdkJvZ0F5QUVjallDQUNBQkRBRUxJQUVvQWdnTElRTWdBU0FDTmdJSUlBTWdBallDRENBQ0lBRTJBZ3dnQWlBRE5nSUlDeUFBUVFocUlRQkIwQm9nQnpZQ0FFSEVHaUFGTmdJQURBc0xRY0FhS0FJQUlndEZEUUVnQzJoQkFuUkI3QnhxS0FJQUlnSW9BZ1JCZUhFZ0Jtc2hBeUFDSVFFRFFBSkFJQUVvQWhBaUFFVUVRQ0FCS0FJVUlnQkZEUUVMSUFBb0FnUkJlSEVnQm1zaUFTQURJQUVnQTBraUFSc2hBeUFBSUFJZ0FSc2hBaUFBSVFFTUFRc0xJQUlvQWhnaENTQUNJQUlvQWd3aUFFY0VRRUhNR2lnQ0FCb2dBaWdDQ0NJQklBQTJBZ3dnQUNBQk5nSUlEQW9MSUFJb0FoUWlBUVIvSUFKQkZHb0ZJQUlvQWhBaUFVVU5BeUFDUVJCcUN5RUZBMEFnQlNFSElBRWlBRUVVYWlFRklBQW9BaFFpQVEwQUlBQkJFR29oQlNBQUtBSVFJZ0VOQUFzZ0IwRUFOZ0lBREFrTFFYOGhCaUFBUWI5L1N3MEFJQUJCQzJvaUFFRjRjU0VHUWNBYUtBSUFJZ2RGRFFCQkFDQUdheUVEQWtBQ1FBSkFBbjlCQUNBR1FZQUNTUTBBR2tFZklBWkIvLy8vQjBzTkFCb2dCa0VtSUFCQkNIWm5JZ0JyZGtFQmNTQUFRUUYwYTBFK2Fnc2lDRUVDZEVIc0hHb29BZ0FpQVVVRVFFRUFJUUFNQVF0QkFDRUFJQVpCR1NBSVFRRjJhMEVBSUFoQkgwY2JkQ0VDQTBBQ1FDQUJLQUlFUVhoeElBWnJJZ1FnQTA4TkFDQUJJUVVnQkNJRERRQkJBQ0VESUFFaEFBd0RDeUFBSUFFb0FoUWlCQ0FFSUFFZ0FrRWRka0VFY1dvb0FoQWlBVVliSUFBZ0JCc2hBQ0FDUVFGMElRSWdBUTBBQ3dzZ0FDQUZja1VFUUVFQUlRVkJBaUFJZENJQVFRQWdBR3R5SUFkeElnQkZEUU1nQUdoQkFuUkI3QnhxS0FJQUlRQUxJQUJGRFFFTEEwQWdBQ2dDQkVGNGNTQUdheUlDSUFOSklRRWdBaUFESUFFYklRTWdBQ0FGSUFFYklRVWdBQ2dDRUNJQkJIOGdBUVVnQUNnQ0ZBc2lBQTBBQ3dzZ0JVVU5BQ0FEUWNRYUtBSUFJQVpyVHcwQUlBVW9BaGdoQ0NBRklBVW9BZ3dpQUVjRVFFSE1HaWdDQUJvZ0JTZ0NDQ0lCSUFBMkFnd2dBQ0FCTmdJSURBZ0xJQVVvQWhRaUFRUi9JQVZCRkdvRklBVW9BaEFpQVVVTkF5QUZRUkJxQ3lFQ0EwQWdBaUVFSUFFaUFFRVVhaUVDSUFBb0FoUWlBUTBBSUFCQkVHb2hBaUFBS0FJUUlnRU5BQXNnQkVFQU5nSUFEQWNMSUFaQnhCb29BZ0FpQlUwRVFFSFFHaWdDQUNFQUFrQWdCU0FHYXlJQlFSQlBCRUFnQUNBR2FpSUNJQUZCQVhJMkFnUWdBQ0FGYWlBQk5nSUFJQUFnQmtFRGNqWUNCQXdCQ3lBQUlBVkJBM0kyQWdRZ0FDQUZhaUlCSUFFb0FnUkJBWEkyQWdSQkFDRUNRUUFoQVF0QnhCb2dBVFlDQUVIUUdpQUNOZ0lBSUFCQkNHb2hBQXdKQ3lBR1FjZ2FLQUlBSWdKSkJFQkJ5Qm9nQWlBR2F5SUJOZ0lBUWRRYVFkUWFLQUlBSWdBZ0Jtb2lBallDQUNBQ0lBRkJBWEkyQWdRZ0FDQUdRUU55TmdJRUlBQkJDR29oQUF3SkMwRUFJUUFnQmtFdmFpSURBbjlCbEI0b0FnQUVRRUdjSGlnQ0FBd0JDMEdnSGtKL053SUFRWmdlUW9DZ2dJQ0FnQVEzQWdCQmxCNGdDa0VNYWtGd2NVSFlxdFdxQlhNMkFnQkJxQjVCQURZQ0FFSDRIVUVBTmdJQVFZQWdDeUlCYWlJRVFRQWdBV3NpQjNFaUFTQUdUUTBJUWZRZEtBSUFJZ1VFUUVIc0hTZ0NBQ0lJSUFGcUlna2dDRTBnQlNBSlNYSU5DUXNDUUVINEhTMEFBRUVFY1VVRVFBSkFBa0FDUUFKQVFkUWFLQUlBSWdVRVFFSDhIU0VBQTBBZ0JTQUFLQUlBSWdoUEJFQWdDQ0FBS0FJRWFpQUZTdzBEQ3lBQUtBSUlJZ0FOQUFzTFFRQVFDeUlDUVg5R0RRTWdBU0VFUVpnZUtBSUFJZ0JCQVdzaUJTQUNjUVJBSUFFZ0Ftc2dBaUFGYWtFQUlBQnJjV29oQkFzZ0JDQUdUUTBEUWZRZEtBSUFJZ0FFUUVIc0hTZ0NBQ0lGSUFScUlnY2dCVTBnQUNBSFNYSU5CQXNnQkJBTElnQWdBa2NOQVF3RkN5QUVJQUpySUFkeElnUVFDeUlDSUFBb0FnQWdBQ2dDQkdwR0RRRWdBaUVBQ3lBQVFYOUdEUUVnQmtFd2FpQUVUUVJBSUFBaEFnd0VDMEdjSGlnQ0FDSUNJQU1nQkd0cVFRQWdBbXR4SWdJUUMwRi9SZzBCSUFJZ0JHb2hCQ0FBSVFJTUF3c2dBa0YvUncwQ0MwSDRIVUg0SFNnQ0FFRUVjallDQUFzZ0FSQUxJZ0pCZjBaQkFCQUxJZ0JCZjBaeUlBQWdBazF5RFFVZ0FDQUNheUlFSUFaQktHcE5EUVVMUWV3ZFFld2RLQUlBSUFScUlnQTJBZ0JCOEIwb0FnQWdBRWtFUUVId0hTQUFOZ0lBQ3dKQVFkUWFLQUlBSWdNRVFFSDhIU0VBQTBBZ0FpQUFLQUlBSWdFZ0FDZ0NCQ0lGYWtZTkFpQUFLQUlJSWdBTkFBc01CQXRCekJvb0FnQWlBRUVBSUFBZ0FrMGJSUVJBUWN3YUlBSTJBZ0FMUVFBaEFFR0FIaUFFTmdJQVFmd2RJQUkyQWdCQjNCcEJmellDQUVIZ0drR1VIaWdDQURZQ0FFR0lIa0VBTmdJQUEwQWdBRUVEZENJQlFld2FhaUFCUWVRYWFpSUZOZ0lBSUFGQjhCcHFJQVUyQWdBZ0FFRUJhaUlBUVNCSERRQUxRY2dhSUFSQktHc2lBRUY0SUFKclFRZHhJZ0ZySWdVMkFnQkIxQm9nQVNBQ2FpSUJOZ0lBSUFFZ0JVRUJjallDQkNBQUlBSnFRU2cyQWdSQjJCcEJwQjRvQWdBMkFnQU1CQXNnQWlBRFRTQUJJQU5MY2cwQ0lBQW9BZ3hCQ0hFTkFpQUFJQVFnQldvMkFnUkIxQm9nQTBGNElBTnJRUWR4SWdCcUlnRTJBZ0JCeUJwQnlCb29BZ0FnQkdvaUFpQUFheUlBTmdJQUlBRWdBRUVCY2pZQ0JDQUNJQU5xUVNnMkFnUkIyQnBCcEI0b0FnQTJBZ0FNQXd0QkFDRUFEQVlMUVFBaEFBd0VDMEhNR2lnQ0FDQUNTd1JBUWN3YUlBSTJBZ0FMSUFJZ0JHb2hBVUg4SFNFQUFrQURRQ0FCSUFBb0FnQkhCRUFnQUNnQ0NDSUFEUUVNQWdzTElBQXRBQXhCQ0hGRkRRTUxRZndkSVFBRFFBSkFJQU1nQUNnQ0FDSUJUd1JBSUFFZ0FDZ0NCR29pQlNBRFN3MEJDeUFBS0FJSUlRQU1BUXNMUWNnYUlBUkJLR3NpQUVGNElBSnJRUWR4SWdGcklnYzJBZ0JCMUJvZ0FTQUNhaUlCTmdJQUlBRWdCMEVCY2pZQ0JDQUFJQUpxUVNnMkFnUkIyQnBCcEI0b0FnQTJBZ0FnQXlBRlFTY2dCV3RCQjNGcVFTOXJJZ0FnQUNBRFFSQnFTUnNpQVVFYk5nSUVJQUZCaEI0cEFnQTNBaEFnQVVIOEhTa0NBRGNDQ0VHRUhpQUJRUWhxTmdJQVFZQWVJQVEyQWdCQi9CMGdBallDQUVHSUhrRUFOZ0lBSUFGQkdHb2hBQU5BSUFCQkJ6WUNCQ0FBUVFocUlRd2dBRUVFYWlFQUlBd2dCVWtOQUFzZ0FTQURSZzBBSUFFZ0FTZ0NCRUYrY1RZQ0JDQURJQUVnQTJzaUFrRUJjallDQkNBQklBSTJBZ0FDZnlBQ1FmOEJUUVJBSUFKQmVIRkI1QnBxSVFBQ2YwRzhHaWdDQUNJQlFRRWdBa0VEZG5RaUFuRkZCRUJCdkJvZ0FTQUNjallDQUNBQURBRUxJQUFvQWdnTElRRWdBQ0FETmdJSUlBRWdBellDREVFTUlRSkJDQXdCQzBFZklRQWdBa0gvLy84SFRRUkFJQUpCSmlBQ1FRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hBQXNnQXlBQU5nSWNJQU5DQURjQ0VDQUFRUUowUWV3Y2FpRUJBa0FDUUVIQUdpZ0NBQ0lGUVFFZ0FIUWlCSEZGQkVCQndCb2dCQ0FGY2pZQ0FDQUJJQU0yQWdBTUFRc2dBa0VaSUFCQkFYWnJRUUFnQUVFZlJ4dDBJUUFnQVNnQ0FDRUZBMEFnQlNJQktBSUVRWGh4SUFKR0RRSWdBRUVkZGlFRklBQkJBWFFoQUNBQklBVkJCSEZxSWdRb0FoQWlCUTBBQ3lBRUlBTTJBaEFMSUFNZ0FUWUNHRUVJSVFJZ0F5SUJJUUJCREF3QkN5QUJLQUlJSWdBZ0F6WUNEQ0FCSUFNMkFnZ2dBeUFBTmdJSVFRQWhBRUVZSVFKQkRBc2dBMm9nQVRZQ0FDQUNJQU5xSUFBMkFnQUxRY2dhS0FJQUlnQWdCazBOQUVISUdpQUFJQVpySWdFMkFnQkIxQnBCMUJvb0FnQWlBQ0FHYWlJQ05nSUFJQUlnQVVFQmNqWUNCQ0FBSUFaQkEzSTJBZ1FnQUVFSWFpRUFEQVFMUWJnYVFUQTJBZ0JCQUNFQURBTUxJQUFnQWpZQ0FDQUFJQUFvQWdRZ0JHbzJBZ1FnQWtGNElBSnJRUWR4YWlJSUlBWkJBM0kyQWdRZ0FVRjRJQUZyUVFkeGFpSUVJQVlnQ0dvaUEyc2hCd0pBUWRRYUtBSUFJQVJHQkVCQjFCb2dBellDQUVISUdrSElHaWdDQUNBSGFpSUFOZ0lBSUFNZ0FFRUJjallDQkF3QkMwSFFHaWdDQUNBRVJnUkFRZEFhSUFNMkFnQkJ4QnBCeEJvb0FnQWdCMm9pQURZQ0FDQURJQUJCQVhJMkFnUWdBQ0FEYWlBQU5nSUFEQUVMSUFRb0FnUWlBRUVEY1VFQlJnUkFJQUJCZUhFaENTQUVLQUlNSVFJQ1FDQUFRZjhCVFFSQUlBUW9BZ2dpQVNBQ1JnUkFRYndhUWJ3YUtBSUFRWDRnQUVFRGRuZHhOZ0lBREFJTElBRWdBallDRENBQ0lBRTJBZ2dNQVFzZ0JDZ0NHQ0VHQWtBZ0FpQUVSd1JBUWN3YUtBSUFHaUFFS0FJSUlnQWdBallDRENBQ0lBQTJBZ2dNQVFzQ1FDQUVLQUlVSWdBRWZ5QUVRUlJxQlNBRUtBSVFJZ0JGRFFFZ0JFRVFhZ3NoQVFOQUlBRWhCU0FBSWdKQkZHb2hBU0FBS0FJVUlnQU5BQ0FDUVJCcUlRRWdBaWdDRUNJQURRQUxJQVZCQURZQ0FBd0JDMEVBSVFJTElBWkZEUUFDUUNBRUtBSWNJZ0JCQW5SQjdCeHFJZ0VvQWdBZ0JFWUVRQ0FCSUFJMkFnQWdBZzBCUWNBYVFjQWFLQUlBUVg0Z0FIZHhOZ0lBREFJTElBWkJFRUVVSUFZb0FoQWdCRVliYWlBQ05nSUFJQUpGRFFFTElBSWdCallDR0NBRUtBSVFJZ0FFUUNBQ0lBQTJBaEFnQUNBQ05nSVlDeUFFS0FJVUlnQkZEUUFnQWlBQU5nSVVJQUFnQWpZQ0dBc2dCeUFKYWlFSElBUWdDV29pQkNnQ0JDRUFDeUFFSUFCQmZuRTJBZ1FnQXlBSFFRRnlOZ0lFSUFNZ0Iyb2dCellDQUNBSFFmOEJUUVJBSUFkQmVIRkI1QnBxSVFBQ2YwRzhHaWdDQUNJQlFRRWdCMEVEZG5RaUFuRkZCRUJCdkJvZ0FTQUNjallDQUNBQURBRUxJQUFvQWdnTElRRWdBQ0FETmdJSUlBRWdBellDRENBRElBQTJBZ3dnQXlBQk5nSUlEQUVMUVI4aEFpQUhRZi8vL3dkTkJFQWdCMEVtSUFkQkNIWm5JZ0JyZGtFQmNTQUFRUUYwYTBFK2FpRUNDeUFESUFJMkFod2dBMElBTndJUUlBSkJBblJCN0J4cUlRQUNRQUpBUWNBYUtBSUFJZ0ZCQVNBQ2RDSUZjVVVFUUVIQUdpQUJJQVZ5TmdJQUlBQWdBellDQUF3QkN5QUhRUmtnQWtFQmRtdEJBQ0FDUVI5SEczUWhBaUFBS0FJQUlRRURRQ0FCSWdBb0FnUkJlSEVnQjBZTkFpQUNRUjEySVFFZ0FrRUJkQ0VDSUFBZ0FVRUVjV29pQlNnQ0VDSUJEUUFMSUFVZ0F6WUNFQXNnQXlBQU5nSVlJQU1nQXpZQ0RDQURJQU0yQWdnTUFRc2dBQ2dDQ0NJQklBTTJBZ3dnQUNBRE5nSUlJQU5CQURZQ0dDQURJQUEyQWd3Z0F5QUJOZ0lJQ3lBSVFRaHFJUUFNQWdzQ1FDQUlSUTBBQWtBZ0JTZ0NIQ0lCUVFKMFFld2NhaUlDS0FJQUlBVkdCRUFnQWlBQU5nSUFJQUFOQVVIQUdpQUhRWDRnQVhkeElnYzJBZ0FNQWdzZ0NFRVFRUlFnQ0NnQ0VDQUZSaHRxSUFBMkFnQWdBRVVOQVFzZ0FDQUlOZ0lZSUFVb0FoQWlBUVJBSUFBZ0FUWUNFQ0FCSUFBMkFoZ0xJQVVvQWhRaUFVVU5BQ0FBSUFFMkFoUWdBU0FBTmdJWUN3SkFJQU5CRDAwRVFDQUZJQU1nQm1vaUFFRURjallDQkNBQUlBVnFJZ0FnQUNnQ0JFRUJjallDQkF3QkN5QUZJQVpCQTNJMkFnUWdCU0FHYWlJRUlBTkJBWEkyQWdRZ0F5QUVhaUFETmdJQUlBTkIvd0ZOQkVBZ0EwRjRjVUhrR21vaEFBSi9RYndhS0FJQUlnRkJBU0FEUVFOMmRDSUNjVVVFUUVHOEdpQUJJQUp5TmdJQUlBQU1BUXNnQUNnQ0NBc2hBU0FBSUFRMkFnZ2dBU0FFTmdJTUlBUWdBRFlDRENBRUlBRTJBZ2dNQVF0Qkh5RUFJQU5CLy8vL0IwMEVRQ0FEUVNZZ0EwRUlkbWNpQUd0MlFRRnhJQUJCQVhSclFUNXFJUUFMSUFRZ0FEWUNIQ0FFUWdBM0FoQWdBRUVDZEVIc0hHb2hBUUpBQWtBZ0IwRUJJQUIwSWdKeFJRUkFRY0FhSUFJZ0IzSTJBZ0FnQVNBRU5nSUFJQVFnQVRZQ0dBd0JDeUFEUVJrZ0FFRUJkbXRCQUNBQVFSOUhHM1FoQUNBQktBSUFJUUVEUUNBQklnSW9BZ1JCZUhFZ0EwWU5BaUFBUVIxMklRRWdBRUVCZENFQUlBSWdBVUVFY1dvaUJ5Z0NFQ0lCRFFBTElBY2dCRFlDRUNBRUlBSTJBaGdMSUFRZ0JEWUNEQ0FFSUFRMkFnZ01BUXNnQWlnQ0NDSUFJQVEyQWd3Z0FpQUVOZ0lJSUFSQkFEWUNHQ0FFSUFJMkFnd2dCQ0FBTmdJSUN5QUZRUWhxSVFBTUFRc0NRQ0FKUlEwQUFrQWdBaWdDSENJQlFRSjBRZXdjYWlJRktBSUFJQUpHQkVBZ0JTQUFOZ0lBSUFBTkFVSEFHaUFMUVg0Z0FYZHhOZ0lBREFJTElBbEJFRUVVSUFrb0FoQWdBa1liYWlBQU5nSUFJQUJGRFFFTElBQWdDVFlDR0NBQ0tBSVFJZ0VFUUNBQUlBRTJBaEFnQVNBQU5nSVlDeUFDS0FJVUlnRkZEUUFnQUNBQk5nSVVJQUVnQURZQ0dBc0NRQ0FEUVE5TkJFQWdBaUFESUFacUlnQkJBM0kyQWdRZ0FDQUNhaUlBSUFBb0FnUkJBWEkyQWdRTUFRc2dBaUFHUVFOeU5nSUVJQUlnQm1vaUJTQURRUUZ5TmdJRUlBTWdCV29nQXpZQ0FDQUlCRUFnQ0VGNGNVSGtHbW9oQUVIUUdpZ0NBQ0VCQW45QkFTQUlRUU4yZENJSElBUnhSUVJBUWJ3YUlBUWdCM0kyQWdBZ0FBd0JDeUFBS0FJSUN5RUVJQUFnQVRZQ0NDQUVJQUUyQWd3Z0FTQUFOZ0lNSUFFZ0JEWUNDQXRCMEJvZ0JUWUNBRUhFR2lBRE5nSUFDeUFDUVFocUlRQUxJQXBCRUdva0FDQUFDeG9BSUFBZ0FTZ0NDQ0FGRUFvRVFDQUJJQUlnQXlBRUVCUUxDemNBSUFBZ0FTZ0NDQ0FGRUFvRVFDQUJJQUlnQXlBRUVCUVBDeUFBS0FJSUlnQWdBU0FDSUFNZ0JDQUZJQUFvQWdBb0FoUVJBd0FMa1FFQUlBQWdBU2dDQ0NBRUVBb0VRQ0FCSUFJZ0F4QVREd3NDUUNBQUlBRW9BZ0FnQkJBS1JRMEFBa0FnQWlBQktBSVFSd1JBSUFFb0FoUWdBa2NOQVFzZ0EwRUJSdzBCSUFGQkFUWUNJQThMSUFFZ0FqWUNGQ0FCSUFNMkFpQWdBU0FCS0FJb1FRRnFOZ0lvQWtBZ0FTZ0NKRUVCUncwQUlBRW9BaGhCQWtjTkFDQUJRUUU2QURZTElBRkJCRFlDTEFzTDhnRUFJQUFnQVNnQ0NDQUVFQW9FUUNBQklBSWdBeEFURHdzQ1FDQUFJQUVvQWdBZ0JCQUtCRUFDUUNBQ0lBRW9BaEJIQkVBZ0FTZ0NGQ0FDUncwQkN5QURRUUZIRFFJZ0FVRUJOZ0lnRHdzZ0FTQUROZ0lnQWtBZ0FTZ0NMRUVFUmcwQUlBRkJBRHNCTkNBQUtBSUlJZ0FnQVNBQ0lBSkJBU0FFSUFBb0FnQW9BaFFSQXdBZ0FTMEFOUVJBSUFGQkF6WUNMQ0FCTFFBMFJRMEJEQU1MSUFGQkJEWUNMQXNnQVNBQ05nSVVJQUVnQVNnQ0tFRUJhallDS0NBQktBSWtRUUZIRFFFZ0FTZ0NHRUVDUncwQklBRkJBVG9BTmc4TElBQW9BZ2dpQUNBQklBSWdBeUFFSUFBb0FnQW9BaGdSQWdBTEN6RUFJQUFnQVNnQ0NFRUFFQW9FUUNBQklBSWdBeEFWRHdzZ0FDZ0NDQ0lBSUFFZ0FpQURJQUFvQWdBb0Fod1JBQUFMR0FBZ0FDQUJLQUlJUVFBUUNnUkFJQUVnQWlBREVCVUxDNEFEQVFSL0l3QkI4QUJySWdJa0FDQUFLQUlBSWdOQkJHc29BZ0FoQkNBRFFRaHJLQUlBSVFVZ0FrSUFOd0pRSUFKQ0FEY0NXQ0FDUWdBM0FtQWdBa0lBTndCbklBSkNBRGNDU0NBQ1FRQTJBa1FnQWtIc0ZUWUNRQ0FDSUFBMkFqd2dBaUFCTmdJNElBQWdCV29oQXdKQUlBUWdBVUVBRUFvRVFFRUFJQU1nQlJzaEFBd0JDeUFBSUFOT0JFQWdBa0lBTndBdklBSkNBRGNDR0NBQ1FnQTNBaUFnQWtJQU53SW9JQUpDQURjQ0VDQUNRUUEyQWd3Z0FpQUJOZ0lJSUFJZ0FEWUNCQ0FDSUFRMkFnQWdBa0VCTmdJd0lBUWdBaUFESUFOQkFVRUFJQVFvQWdBb0FoUVJBd0FnQWlnQ0dBMEJDMEVBSVFBZ0JDQUNRVGhxSUFOQkFVRUFJQVFvQWdBb0FoZ1JBZ0FDUUFKQUlBSW9BbHdPQWdBQkFnc2dBaWdDVEVFQUlBSW9BbGhCQVVZYlFRQWdBaWdDVkVFQlJodEJBQ0FDS0FKZ1FRRkdHeUVBREFFTElBSW9BbEJCQVVjRVFDQUNLQUpnRFFFZ0FpZ0NWRUVCUncwQklBSW9BbGhCQVVjTkFRc2dBaWdDU0NFQUN5QUNRZkFBYWlRQUlBQUxtZ0VCQW44akFFRkFhaUlESkFBQ2YwRUJJQUFnQVVFQUVBb05BQnBCQUNBQlJRMEFHa0VBSUFGQm5CWVFIaUlCUlEwQUdpQURRUXhxUVRRUUVCb2dBMEVCTmdJNElBTkJmellDRkNBRElBQTJBaEFnQXlBQk5nSUlJQUVnQTBFSWFpQUNLQUlBUVFFZ0FTZ0NBQ2dDSEJFQUFDQURLQUlnSWdCQkFVWUVRQ0FDSUFNb0FoZzJBZ0FMSUFCQkFVWUxJUVFnQTBGQWF5UUFJQVFMQ2dBZ0FDQUJRUUFRQ2d1QUNnSUlmeUo5UWYvLy8vOEhJUTVCZ0lDQWdIZ2hEMEYvSVFvRFFDQURJQXhHQkVCQkFDRUFJQWxCZ0lBUUVCQWhBVU1BLzM5SElBOGdEbXV5bFNFZEEwQWdBQ0FEUmdSQVFRQWhBQ0FJUVFBMkFnQWdBVUVFYXlFQlFRQWhERUVCSVFzRFFDQUxRWUNBQkVaRkJFQWdDQ0FMUVFKMElnSnFJQUVnQW1vb0FnQWdER29pRERZQ0FDQUxRUUZxSVFzTUFRc0xBMEFnQUNBRFJrVUVRQ0FJSUFZZ0FFRUNkR29vQWdCQkFuUnFJZ0VnQVNnQ0FDSUJRUUZxTmdJQUlBY2dBVUVDZEdvZ0FEWUNBQ0FBUVFGcUlRQU1BUXNMQlFKL0lCMGdCaUFBUVFKMGFpSUNLQUlBSUE1cnM1UWlFa01BQUlCUFhTQVNRd0FBQUFCZ2NRUkFJQktwREFFTFFRQUxJUXNnQWlBTE5nSUFJQUVnQzBFQ2RHb2lBaUFDS0FJQVFRRnFOZ0lBSUFCQkFXb2hBQXdCQ3dzRklBUWdERUVNYkdvaUN5b0NBQ0VTSUFzcUFnZ2hIU0FMS2dJRUlTRWdDaUFDSUF4QkFuUWlEV29vQWdBaUMwY0VRQ0FCSUF0QjBBQnNhaUlLS2dJOEloUWdBQ29DUENJVmxDQUtLZ0k0SWhZZ0FDb0NMQ0lZbENBS0tnSXdJaGtnQUNvQ0RDSWFsQ0FBS2dJY0loNGdDaW9DTkNJVGxKS1NraUVwSUJRZ0FDb0NPQ0lmbENBV0lBQXFBaWdpSUpRZ0dTQUFLZ0lJSWlLVUlBQXFBaGdpSXlBVGxKS1NraUVxSUJRZ0FDb0NOQ0lrbENBV0lBQXFBaVFpSlpRZ0dTQUFLZ0lFSWlhVUlBQXFBaFFpSnlBVGxKS1NraUVySUJRZ0FDb0NNQ0lVbENBV0lBQXFBaUFpRnBRZ0dTQUFLZ0lBSWhtVUlBQXFBaEFpS0NBVGxKS1NraUVzSUFvcUFpd2lFeUFWbENBS0tnSW9JaGNnR0pRZ0Npb0NJQ0liSUJxVUlCNGdDaW9DSkNJY2xKS1NraUV0SUJNZ0g1UWdGeUFnbENBYklDS1VJQ01nSEpTU2twSWhMaUFUSUNTVUlCY2dKWlFnR3lBbWxDQW5JQnlVa3BLU0lTOGdFeUFVbENBWElCYVVJQnNnR1pRZ0tDQWNsSktTa2lFd0lBb3FBaHdpRXlBVmxDQUtLZ0lZSWhjZ0dKUWdDaW9DRUNJYklCcVVJQjRnQ2lvQ0ZDSWNsSktTa2lFeElCTWdINVFnRnlBZ2xDQWJJQ0tVSUNNZ0hKU1NrcEloTWlBVElDU1VJQmNnSlpRZ0d5QW1sQ0FuSUJ5VWtwS1NJVE1nRXlBVWxDQVhJQmFVSUJzZ0daUWdLQ0FjbEpLU2tpRVhJQW9xQWd3aUV5QVZsQ0FLS2dJSUloVWdHSlFnQ2lvQ0FDSVlJQnFVSUFvcUFnUWlHaUFlbEpLU2tpRWVJQk1nSDVRZ0ZTQWdsQ0FZSUNLVUlCb2dJNVNTa3BJaEh5QVRJQ1NVSUJVZ0paUWdHQ0FtbENBYUlDZVVrcEtTSVNBZ0V5QVVsQ0FWSUJhVUlCZ2dHWlFnR2lBb2xKS1NraUVXSUFzaENnc2dCaUFOYWdKL0lDNGdIWlFnSHlBU2xDQWhJREtVa3BJZ0twSkRBQUNBUlpRaUZJdERBQUFBVDEwRVFDQVVxQXdCQzBHQWdJQ0FlQXNpQ3pZQ0FDQUxJQTVLSVJBZ0N5QVBTQ0VSUWY4QklRMENRQ0F0SUIyVUlCNGdFcFFnSVNBeGxKS1NJQ21TSWhSREFBQUFBRnNOQUNBd0lCMlVJQllnRXBRZ0lTQVhsSktTSUN5U0lCU1ZRd0FBZ0QrU1F3QUFBRCtVSWhWREFBQUFBR0JGSUJWREFBQ0FQMTFGY2cwQUlDOGdIWlFnSUNBU2xDQWhJRE9Va3BJZ0s1SWdGSlZEQUFDQVA1SkRBQUFBUDVRaUVrTUFBQUFBWUVVZ0VrTUFBSUEvWFVWeURRQUNmeUFTUXdBQWNFR1VJaEpEQUFDQVQxMGdFa01BQUFBQVlIRUVRQ0FTcVF3QkMwRUFDMEVQYkNFTkFuOGdGVU1BQUhCQmxDSVNRd0FBZ0U5ZElCSkRBQUFBQUdCeEJFQWdFcWtNQVF0QkFBc2dEV29oRFFzZ0RpQUxJQkFiSVE0Z0R5QUxJQkViSVE4Z0JTQU1haUFOT2dBQUlBeEJBV29oREF3QkN3c0xDN2NTQWdCQmdBZ0xwaEoxYm5OcFoyNWxaQ0J6YUc5eWRBQjFibk5wWjI1bFpDQnBiblFBWm14dllYUUFkV2x1ZERZMFgzUUFkVzV6YVdkdVpXUWdZMmhoY2dCaWIyOXNBSFZ1YzJsbmJtVmtJR3h2Ym1jQWMzUmtPanAzYzNSeWFXNW5BSE4wWkRvNmMzUnlhVzVuQUhOMFpEbzZkVEUyYzNSeWFXNW5BSE4wWkRvNmRUTXljM1J5YVc1bkFHUnZkV0pzWlFCMmIybGtBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BITm9iM0owUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkengxYm5OcFoyNWxaQ0J6YUc5eWRENEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGFXNTBQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eDFibk5wWjI1bFpDQnBiblErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQR1pzYjJGMFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4MWFXNTBPRjkwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkenhwYm5RNFgzUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BIVnBiblF4Tmw5MFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4cGJuUXhObDkwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkengxYVc1ME5qUmZkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhhVzUwTmpSZmRENEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGRXbHVkRE15WDNRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEdsdWRETXlYM1ErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQR05vWVhJK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEhWdWMybG5ibVZrSUdOb1lYSStBSE4wWkRvNlltRnphV05mYzNSeWFXNW5QSFZ1YzJsbmJtVmtJR05vWVhJK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEhOcFoyNWxaQ0JqYUdGeVBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4c2IyNW5QZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eDFibk5wWjI1bFpDQnNiMjVuUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkenhrYjNWaWJHVStBRTVUZEROZlh6SXhNbUpoYzJsalgzTjBjbWx1WjBsalRsTmZNVEZqYUdGeVgzUnlZV2wwYzBsalJVVk9VMTg1WVd4c2IyTmhkRzl5U1dORlJVVkZBQUFBQUpRTUFBQXlCd0FBVGxOME0xOWZNakV5WW1GemFXTmZjM1J5YVc1blNXaE9VMTh4TVdOb1lYSmZkSEpoYVhSelNXaEZSVTVUWHpsaGJHeHZZMkYwYjNKSmFFVkZSVVVBQUpRTUFBQjhCd0FBVGxOME0xOWZNakV5WW1GemFXTmZjM1J5YVc1blNYZE9VMTh4TVdOb1lYSmZkSEpoYVhSelNYZEZSVTVUWHpsaGJHeHZZMkYwYjNKSmQwVkZSVVVBQUpRTUFBREVCd0FBVGxOME0xOWZNakV5WW1GemFXTmZjM1J5YVc1blNVUnpUbE5mTVRGamFHRnlYM1J5WVdsMGMwbEVjMFZGVGxOZk9XRnNiRzlqWVhSdmNrbEVjMFZGUlVVQUFBQ1VEQUFBREFnQUFFNVRkRE5mWHpJeE1tSmhjMmxqWDNOMGNtbHVaMGxFYVU1VFh6RXhZMmhoY2w5MGNtRnBkSE5KUkdsRlJVNVRYemxoYkd4dlkyRjBiM0pKUkdsRlJVVkZBQUFBbEF3QUFGZ0lBQUJPTVRCbGJYTmpjbWx3ZEdWdU0zWmhiRVVBQUpRTUFBQ2tDQUFBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKWTBWRkFBQ1VEQUFBd0FnQUFFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NXRkZSUUFBbEF3QUFPZ0lBQUJPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGxvUlVVQUFKUU1BQUFRQ1FBQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSmMwVkZBQUNVREFBQU9Ba0FBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTWFJGUlFBQWxBd0FBR0FKQUFCT01UQmxiWE5qY21sd2RHVnVNVEZ0WlcxdmNubGZkbWxsZDBscFJVVUFBSlFNQUFDSUNRQUFUakV3WlcxelkzSnBjSFJsYmpFeGJXVnRiM0o1WDNacFpYZEpha1ZGQUFDVURBQUFzQWtBQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1d4RlJRQUFsQXdBQU5nSkFBQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbHRSVVVBQUpRTUFBQUFDZ0FBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKZUVWRkFBQ1VEQUFBS0FvQUFFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NYbEZSUUFBbEF3QUFGQUtBQUJPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGxtUlVVQUFKUU1BQUI0Q2dBQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSlpFVkZBQUNVREFBQW9Bb0FBRTR4TUY5ZlkzaDRZV0pwZGpFeE5sOWZjMmhwYlY5MGVYQmxYMmx1Wm05RkFBQUFBTHdNQUFESUNnQUFJQTBBQUU0eE1GOWZZM2g0WVdKcGRqRXhOMTlmWTJ4aGMzTmZkSGx3WlY5cGJtWnZSUUFBQUx3TUFBRDRDZ0FBN0FvQUFFNHhNRjlmWTNoNFlXSnBkakV4TjE5ZmNHSmhjMlZmZEhsd1pWOXBibVp2UlFBQUFMd01BQUFvQ3dBQTdBb0FBRTR4TUY5ZlkzaDRZV0pwZGpFeE9WOWZjRzlwYm5SbGNsOTBlWEJsWDJsdVptOUZBTHdNQUFCWUN3QUFUQXNBQUFBQUFBRE1Dd0FBQWdBQUFBTUFBQUFFQUFBQUJRQUFBQVlBQUFCT01UQmZYMk40ZUdGaWFYWXhNak5mWDJaMWJtUmhiV1Z1ZEdGc1gzUjVjR1ZmYVc1bWIwVUF2QXdBQUtRTEFBRHNDZ0FBZGdBQUFKQUxBQURZQ3dBQVlnQUFBSkFMQUFEa0N3QUFZd0FBQUpBTEFBRHdDd0FBYUFBQUFKQUxBQUQ4Q3dBQVlRQUFBSkFMQUFBSURBQUFjd0FBQUpBTEFBQVVEQUFBZEFBQUFKQUxBQUFnREFBQWFRQUFBSkFMQUFBc0RBQUFhZ0FBQUpBTEFBQTREQUFBYkFBQUFKQUxBQUJFREFBQWJRQUFBSkFMQUFCUURBQUFlQUFBQUpBTEFBQmNEQUFBZVFBQUFKQUxBQUJvREFBQVpnQUFBSkFMQUFCMERBQUFaQUFBQUpBTEFBQ0FEQUFBQUFBQUFCd0xBQUFDQUFBQUJ3QUFBQVFBQUFBRkFBQUFDQUFBQUFrQUFBQUtBQUFBQ3dBQUFBQUFBQUFFRFFBQUFnQUFBQXdBQUFBRUFBQUFCUUFBQUFnQUFBQU5BQUFBRGdBQUFBOEFBQUJPTVRCZlgyTjRlR0ZpYVhZeE1qQmZYM05wWDJOc1lYTnpYM1I1Y0dWZmFXNW1iMFVBQUFBQXZBd0FBTndNQUFBY0N3QUFVM1E1ZEhsd1pWOXBibVp2QUFBQUFKUU1BQUFRRFFCQnFCb0xBekFQQVE9PSI7aWYoIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkpe3dhc21CaW5hcnlGaWxlPWxvY2F0ZUZpbGUod2FzbUJpbmFyeUZpbGUpO31mdW5jdGlvbiBnZXRCaW5hcnlTeW5jKGZpbGUpe2lmKGZpbGU9PXdhc21CaW5hcnlGaWxlJiZ3YXNtQmluYXJ5KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2FzbUJpbmFyeSl9dmFyIGJpbmFyeT10cnlQYXJzZUFzRGF0YVVSSShmaWxlKTtpZihiaW5hcnkpe3JldHVybiBiaW5hcnl9aWYocmVhZEJpbmFyeSl7cmV0dXJuIHJlYWRCaW5hcnkoZmlsZSl9dGhyb3cgImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkIn1mdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpe3JldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT5nZXRCaW5hcnlTeW5jKGJpbmFyeUZpbGUpKX1mdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsaW1wb3J0cyxyZWNlaXZlcil7cmV0dXJuIGdldEJpbmFyeVByb21pc2UoYmluYXJ5RmlsZSkudGhlbihiaW5hcnk9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSxpbXBvcnRzKSkudGhlbihyZWNlaXZlcixyZWFzb249PntlcnIoYGZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICR7cmVhc29ufWApO2Fib3J0KHJlYXNvbik7fSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBc3luYyhiaW5hcnksYmluYXJ5RmlsZSxpbXBvcnRzLGNhbGxiYWNrKXtyZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLGltcG9ydHMsY2FsbGJhY2spfWZ1bmN0aW9uIGNyZWF0ZVdhc20oKXt2YXIgaW5mbz17ImEiOndhc21JbXBvcnRzfTtmdW5jdGlvbiByZWNlaXZlSW5zdGFuY2UoaW5zdGFuY2UsbW9kdWxlKXt3YXNtRXhwb3J0cz1pbnN0YW5jZS5leHBvcnRzO3dhc21NZW1vcnk9d2FzbUV4cG9ydHNbImsiXTt1cGRhdGVNZW1vcnlWaWV3cygpO2FkZE9uSW5pdCh3YXNtRXhwb3J0c1sibCJdKTtyZW1vdmVSdW5EZXBlbmRlbmN5KCk7cmV0dXJuIHdhc21FeHBvcnRzfWFkZFJ1bkRlcGVuZGVuY3koKTtmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpe3JlY2VpdmVJbnN0YW5jZShyZXN1bHRbImluc3RhbmNlIl0pO31pZihNb2R1bGVbImluc3RhbnRpYXRlV2FzbSJdKXt0cnl7cmV0dXJuIE1vZHVsZVsiaW5zdGFudGlhdGVXYXNtIl0oaW5mbyxyZWNlaXZlSW5zdGFuY2UpfWNhdGNoKGUpe2VycihgTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJHtlfWApO3JlYWR5UHJvbWlzZVJlamVjdChlKTt9fWluc3RhbnRpYXRlQXN5bmMod2FzbUJpbmFyeSx3YXNtQmluYXJ5RmlsZSxpbmZvLHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO3JldHVybiB7fX12YXIgY2FsbFJ1bnRpbWVDYWxsYmFja3M9Y2FsbGJhY2tzPT57d2hpbGUoY2FsbGJhY2tzLmxlbmd0aD4wKXtjYWxsYmFja3Muc2hpZnQoKShNb2R1bGUpO319O01vZHVsZVsibm9FeGl0UnVudGltZSJdfHx0cnVlO3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQ9KHByaW1pdGl2ZVR5cGUsbmFtZSxzaXplLG1pblJhbmdlLG1heFJhbmdlKT0+e307dmFyIGVtYmluZF9pbml0X2NoYXJDb2Rlcz0oKT0+e3ZhciBjb2Rlcz1uZXcgQXJyYXkoMjU2KTtmb3IodmFyIGk9MDtpPDI1NjsrK2kpe2NvZGVzW2ldPVN0cmluZy5mcm9tQ2hhckNvZGUoaSk7fWVtYmluZF9jaGFyQ29kZXM9Y29kZXM7fTt2YXIgZW1iaW5kX2NoYXJDb2Rlczt2YXIgcmVhZExhdGluMVN0cmluZz1wdHI9Pnt2YXIgcmV0PSIiO3ZhciBjPXB0cjt3aGlsZShIRUFQVThbY10pe3JldCs9ZW1iaW5kX2NoYXJDb2Rlc1tIRUFQVThbYysrXV07fXJldHVybiByZXR9O3ZhciBhd2FpdGluZ0RlcGVuZGVuY2llcz17fTt2YXIgcmVnaXN0ZXJlZFR5cGVzPXt9O3ZhciBCaW5kaW5nRXJyb3I7dmFyIHRocm93QmluZGluZ0Vycm9yPW1lc3NhZ2U9Pnt0aHJvdyBuZXcgQmluZGluZ0Vycm9yKG1lc3NhZ2UpfTtmdW5jdGlvbiBzaGFyZWRSZWdpc3RlclR5cGUocmF3VHlwZSxyZWdpc3RlcmVkSW5zdGFuY2Usb3B0aW9ucz17fSl7dmFyIG5hbWU9cmVnaXN0ZXJlZEluc3RhbmNlLm5hbWU7aWYoIXJhd1R5cGUpe3Rocm93QmluZGluZ0Vycm9yKGB0eXBlICIke25hbWV9IiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyYCk7fWlmKHJlZ2lzdGVyZWRUeXBlcy5oYXNPd25Qcm9wZXJ0eShyYXdUeXBlKSl7aWYob3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zKXtyZXR1cm59ZWxzZSB7dGhyb3dCaW5kaW5nRXJyb3IoYENhbm5vdCByZWdpc3RlciB0eXBlICcke25hbWV9JyB0d2ljZWApO319cmVnaXN0ZXJlZFR5cGVzW3Jhd1R5cGVdPXJlZ2lzdGVyZWRJbnN0YW5jZTtpZihhd2FpdGluZ0RlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShyYXdUeXBlKSl7dmFyIGNhbGxiYWNrcz1hd2FpdGluZ0RlcGVuZGVuY2llc1tyYXdUeXBlXTtkZWxldGUgYXdhaXRpbmdEZXBlbmRlbmNpZXNbcmF3VHlwZV07Y2FsbGJhY2tzLmZvckVhY2goY2I9PmNiKCkpO319ZnVuY3Rpb24gcmVnaXN0ZXJUeXBlKHJhd1R5cGUscmVnaXN0ZXJlZEluc3RhbmNlLG9wdGlvbnM9e30pe2lmKCEoImFyZ1BhY2tBZHZhbmNlImluIHJlZ2lzdGVyZWRJbnN0YW5jZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoInJlZ2lzdGVyVHlwZSByZWdpc3RlcmVkSW5zdGFuY2UgcmVxdWlyZXMgYXJnUGFja0FkdmFuY2UiKX1yZXR1cm4gc2hhcmVkUmVnaXN0ZXJUeXBlKHJhd1R5cGUscmVnaXN0ZXJlZEluc3RhbmNlLG9wdGlvbnMpfXZhciBHZW5lcmljV2lyZVR5cGVTaXplPTg7dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2w9KHJhd1R5cGUsbmFtZSx0cnVlVmFsdWUsZmFsc2VWYWx1ZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjpmdW5jdGlvbih3dCl7cmV0dXJuICEhd3R9LCJ0b1dpcmVUeXBlIjpmdW5jdGlvbihkZXN0cnVjdG9ycyxvKXtyZXR1cm4gbz90cnVlVmFsdWU6ZmFsc2VWYWx1ZX0sImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6ZnVuY3Rpb24ocG9pbnRlcil7cmV0dXJuIHRoaXNbImZyb21XaXJlVHlwZSJdKEhFQVBVOFtwb2ludGVyXSl9LGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSk7fTt2YXIgZW12YWxfZnJlZWxpc3Q9W107dmFyIGVtdmFsX2hhbmRsZXM9W107dmFyIF9fZW12YWxfZGVjcmVmPWhhbmRsZT0+e2lmKGhhbmRsZT45JiYwPT09LS1lbXZhbF9oYW5kbGVzW2hhbmRsZSsxXSl7ZW12YWxfaGFuZGxlc1toYW5kbGVdPXVuZGVmaW5lZDtlbXZhbF9mcmVlbGlzdC5wdXNoKGhhbmRsZSk7fX07dmFyIGNvdW50X2VtdmFsX2hhbmRsZXM9KCk9PmVtdmFsX2hhbmRsZXMubGVuZ3RoLzItNS1lbXZhbF9mcmVlbGlzdC5sZW5ndGg7dmFyIGluaXRfZW12YWw9KCk9PntlbXZhbF9oYW5kbGVzLnB1c2goMCwxLHVuZGVmaW5lZCwxLG51bGwsMSx0cnVlLDEsZmFsc2UsMSk7TW9kdWxlWyJjb3VudF9lbXZhbF9oYW5kbGVzIl09Y291bnRfZW12YWxfaGFuZGxlczt9O3ZhciBFbXZhbD17dG9WYWx1ZTpoYW5kbGU9PntpZighaGFuZGxlKXt0aHJvd0JpbmRpbmdFcnJvcigiQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gIitoYW5kbGUpO31yZXR1cm4gZW12YWxfaGFuZGxlc1toYW5kbGVdfSx0b0hhbmRsZTp2YWx1ZT0+e3N3aXRjaCh2YWx1ZSl7Y2FzZSB1bmRlZmluZWQ6cmV0dXJuIDI7Y2FzZSBudWxsOnJldHVybiA0O2Nhc2UgdHJ1ZTpyZXR1cm4gNjtjYXNlIGZhbHNlOnJldHVybiA4O2RlZmF1bHQ6e2NvbnN0IGhhbmRsZT1lbXZhbF9mcmVlbGlzdC5wb3AoKXx8ZW12YWxfaGFuZGxlcy5sZW5ndGg7ZW12YWxfaGFuZGxlc1toYW5kbGVdPXZhbHVlO2VtdmFsX2hhbmRsZXNbaGFuZGxlKzFdPTE7cmV0dXJuIGhhbmRsZX19fX07ZnVuY3Rpb24gcmVhZFBvaW50ZXIocG9pbnRlcil7cmV0dXJuIHRoaXNbImZyb21XaXJlVHlwZSJdKEhFQVBVMzJbcG9pbnRlcj4+Ml0pfXZhciBFbVZhbFR5cGU9e25hbWU6ImVtc2NyaXB0ZW46OnZhbCIsImZyb21XaXJlVHlwZSI6aGFuZGxlPT57dmFyIHJ2PUVtdmFsLnRvVmFsdWUoaGFuZGxlKTtfX2VtdmFsX2RlY3JlZihoYW5kbGUpO3JldHVybiBydn0sInRvV2lyZVR5cGUiOihkZXN0cnVjdG9ycyx2YWx1ZSk9PkVtdmFsLnRvSGFuZGxlKHZhbHVlKSwiYXJnUGFja0FkdmFuY2UiOkdlbmVyaWNXaXJlVHlwZVNpemUsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjpyZWFkUG9pbnRlcixkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2VtdmFsPXJhd1R5cGU9PnJlZ2lzdGVyVHlwZShyYXdUeXBlLEVtVmFsVHlwZSk7dmFyIGZsb2F0UmVhZFZhbHVlRnJvbVBvaW50ZXI9KG5hbWUsd2lkdGgpPT57c3dpdGNoKHdpZHRoKXtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKHBvaW50ZXIpe3JldHVybiB0aGlzWyJmcm9tV2lyZVR5cGUiXShIRUFQRjMyW3BvaW50ZXI+PjJdKX07Y2FzZSA4OnJldHVybiBmdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oSEVBUEY2NFtwb2ludGVyPj4zXSl9O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBmbG9hdCB3aWR0aCAoJHt3aWR0aH0pOiAke25hbWV9YCl9fTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQ9KHJhd1R5cGUsbmFtZSxzaXplKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiOnZhbHVlPT52YWx1ZSwidG9XaXJlVHlwZSI6KGRlc3RydWN0b3JzLHZhbHVlKT0+dmFsdWUsImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6ZmxvYXRSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLHNpemUpLGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSk7fTt2YXIgaW50ZWdlclJlYWRWYWx1ZUZyb21Qb2ludGVyPShuYW1lLHdpZHRoLHNpZ25lZCk9Pntzd2l0Y2god2lkdGgpe2Nhc2UgMTpyZXR1cm4gc2lnbmVkP3BvaW50ZXI9PkhFQVA4W3BvaW50ZXJdOnBvaW50ZXI9PkhFQVBVOFtwb2ludGVyXTtjYXNlIDI6cmV0dXJuIHNpZ25lZD9wb2ludGVyPT5IRUFQMTZbcG9pbnRlcj4+MV06cG9pbnRlcj0+SEVBUFUxNltwb2ludGVyPj4xXTtjYXNlIDQ6cmV0dXJuIHNpZ25lZD9wb2ludGVyPT5IRUFQMzJbcG9pbnRlcj4+Ml06cG9pbnRlcj0+SEVBUFUzMltwb2ludGVyPj4yXTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgaW50ZWdlciB3aWR0aCAoJHt3aWR0aH0pOiAke25hbWV9YCl9fTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcj0ocHJpbWl0aXZlVHlwZSxuYW1lLHNpemUsbWluUmFuZ2UsbWF4UmFuZ2UpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3ZhciBmcm9tV2lyZVR5cGU9dmFsdWU9PnZhbHVlO2lmKG1pblJhbmdlPT09MCl7dmFyIGJpdHNoaWZ0PTMyLTgqc2l6ZTtmcm9tV2lyZVR5cGU9dmFsdWU9PnZhbHVlPDxiaXRzaGlmdD4+PmJpdHNoaWZ0O312YXIgaXNVbnNpZ25lZFR5cGU9bmFtZS5pbmNsdWRlcygidW5zaWduZWQiKTt2YXIgY2hlY2tBc3NlcnRpb25zPSh2YWx1ZSx0b1R5cGVOYW1lKT0+e307dmFyIHRvV2lyZVR5cGU7aWYoaXNVbnNpZ25lZFR5cGUpe3RvV2lyZVR5cGU9ZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsdmFsdWUpe2NoZWNrQXNzZXJ0aW9ucyh2YWx1ZSx0aGlzLm5hbWUpO3JldHVybiB2YWx1ZT4+PjB9O31lbHNlIHt0b1dpcmVUeXBlPWZ1bmN0aW9uKGRlc3RydWN0b3JzLHZhbHVlKXtjaGVja0Fzc2VydGlvbnModmFsdWUsdGhpcy5uYW1lKTtyZXR1cm4gdmFsdWV9O31yZWdpc3RlclR5cGUocHJpbWl0aXZlVHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiOmZyb21XaXJlVHlwZSwidG9XaXJlVHlwZSI6dG9XaXJlVHlwZSwiYXJnUGFja0FkdmFuY2UiOkdlbmVyaWNXaXJlVHlwZVNpemUsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjppbnRlZ2VyUmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSxzaXplLG1pblJhbmdlIT09MCksZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KTt9O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldz0ocmF3VHlwZSxkYXRhVHlwZUluZGV4LG5hbWUpPT57dmFyIHR5cGVNYXBwaW5nPVtJbnQ4QXJyYXksVWludDhBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheV07dmFyIFRBPXR5cGVNYXBwaW5nW2RhdGFUeXBlSW5kZXhdO2Z1bmN0aW9uIGRlY29kZU1lbW9yeVZpZXcoaGFuZGxlKXt2YXIgc2l6ZT1IRUFQVTMyW2hhbmRsZT4+Ml07dmFyIGRhdGE9SEVBUFUzMltoYW5kbGUrND4+Ml07cmV0dXJuIG5ldyBUQShIRUFQOC5idWZmZXIsZGF0YSxzaXplKX1uYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjpkZWNvZGVNZW1vcnlWaWV3LCJhcmdQYWNrQWR2YW5jZSI6R2VuZXJpY1dpcmVUeXBlU2l6ZSwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOmRlY29kZU1lbW9yeVZpZXd9LHtpZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zOnRydWV9KTt9O3ZhciBzdHJpbmdUb1VURjhBcnJheT0oc3RyLGhlYXAsb3V0SWR4LG1heEJ5dGVzVG9Xcml0ZSk9PntpZighKG1heEJ5dGVzVG9Xcml0ZT4wKSlyZXR1cm4gMDt2YXIgc3RhcnRJZHg9b3V0SWR4O3ZhciBlbmRJZHg9b3V0SWR4K21heEJ5dGVzVG9Xcml0ZS0xO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciB1PXN0ci5jaGFyQ29kZUF0KGkpO2lmKHU+PTU1Mjk2JiZ1PD01NzM0Myl7dmFyIHUxPXN0ci5jaGFyQ29kZUF0KCsraSk7dT02NTUzNisoKHUmMTAyMyk8PDEwKXx1MSYxMDIzO31pZih1PD0xMjcpe2lmKG91dElkeD49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPXU7fWVsc2UgaWYodTw9MjA0Nyl7aWYob3V0SWR4KzE+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0xOTJ8dT4+NjtoZWFwW291dElkeCsrXT0xMjh8dSY2Mzt9ZWxzZSBpZih1PD02NTUzNSl7aWYob3V0SWR4KzI+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0yMjR8dT4+MTI7aGVhcFtvdXRJZHgrK109MTI4fHU+PjYmNjM7aGVhcFtvdXRJZHgrK109MTI4fHUmNjM7fWVsc2Uge2lmKG91dElkeCszPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MjQwfHU+PjE4O2hlYXBbb3V0SWR4KytdPTEyOHx1Pj4xMiY2MztoZWFwW291dElkeCsrXT0xMjh8dT4+NiY2MztoZWFwW291dElkeCsrXT0xMjh8dSY2Mzt9fWhlYXBbb3V0SWR4XT0wO3JldHVybiBvdXRJZHgtc3RhcnRJZHh9O3ZhciBzdHJpbmdUb1VURjg9KHN0cixvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKT0+c3RyaW5nVG9VVEY4QXJyYXkoc3RyLEhFQVBVOCxvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKTt2YXIgbGVuZ3RoQnl0ZXNVVEY4PXN0cj0+e3ZhciBsZW49MDtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgYz1zdHIuY2hhckNvZGVBdChpKTtpZihjPD0xMjcpe2xlbisrO31lbHNlIGlmKGM8PTIwNDcpe2xlbis9Mjt9ZWxzZSBpZihjPj01NTI5NiYmYzw9NTczNDMpe2xlbis9NDsrK2k7fWVsc2Uge2xlbis9Mzt9fXJldHVybiBsZW59O3ZhciBVVEY4RGVjb2Rlcj10eXBlb2YgVGV4dERlY29kZXIhPSJ1bmRlZmluZWQiP25ldyBUZXh0RGVjb2RlcigidXRmOCIpOnVuZGVmaW5lZDt2YXIgVVRGOEFycmF5VG9TdHJpbmc9KGhlYXBPckFycmF5LGlkeCxtYXhCeXRlc1RvUmVhZCk9Pnt2YXIgZW5kSWR4PWlkeCttYXhCeXRlc1RvUmVhZDt2YXIgZW5kUHRyPWlkeDt3aGlsZShoZWFwT3JBcnJheVtlbmRQdHJdJiYhKGVuZFB0cj49ZW5kSWR4KSkrK2VuZFB0cjtpZihlbmRQdHItaWR4PjE2JiZoZWFwT3JBcnJheS5idWZmZXImJlVURjhEZWNvZGVyKXtyZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKGhlYXBPckFycmF5LnN1YmFycmF5KGlkeCxlbmRQdHIpKX12YXIgc3RyPSIiO3doaWxlKGlkeDxlbmRQdHIpe3ZhciB1MD1oZWFwT3JBcnJheVtpZHgrK107aWYoISh1MCYxMjgpKXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUodTApO2NvbnRpbnVlfXZhciB1MT1oZWFwT3JBcnJheVtpZHgrK10mNjM7aWYoKHUwJjIyNCk9PTE5Mil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCh1MCYzMSk8PDZ8dTEpO2NvbnRpbnVlfXZhciB1Mj1oZWFwT3JBcnJheVtpZHgrK10mNjM7aWYoKHUwJjI0MCk9PTIyNCl7dTA9KHUwJjE1KTw8MTJ8dTE8PDZ8dTI7fWVsc2Uge3UwPSh1MCY3KTw8MTh8dTE8PDEyfHUyPDw2fGhlYXBPckFycmF5W2lkeCsrXSY2Mzt9aWYodTA8NjU1MzYpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7fWVsc2Uge3ZhciBjaD11MC02NTUzNjtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Y2g+PjEwLDU2MzIwfGNoJjEwMjMpO319cmV0dXJuIHN0cn07dmFyIFVURjhUb1N0cmluZz0ocHRyLG1heEJ5dGVzVG9SZWFkKT0+cHRyP1VURjhBcnJheVRvU3RyaW5nKEhFQVBVOCxwdHIsbWF4Qnl0ZXNUb1JlYWQpOiIiO3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nPShyYXdUeXBlLG5hbWUpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3ZhciBzdGRTdHJpbmdJc1VURjg9bmFtZT09PSJzdGQ6OnN0cmluZyI7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIih2YWx1ZSl7dmFyIGxlbmd0aD1IRUFQVTMyW3ZhbHVlPj4yXTt2YXIgcGF5bG9hZD12YWx1ZSs0O3ZhciBzdHI7aWYoc3RkU3RyaW5nSXNVVEY4KXt2YXIgZGVjb2RlU3RhcnRQdHI9cGF5bG9hZDtmb3IodmFyIGk9MDtpPD1sZW5ndGg7KytpKXt2YXIgY3VycmVudEJ5dGVQdHI9cGF5bG9hZCtpO2lmKGk9PWxlbmd0aHx8SEVBUFU4W2N1cnJlbnRCeXRlUHRyXT09MCl7dmFyIG1heFJlYWQ9Y3VycmVudEJ5dGVQdHItZGVjb2RlU3RhcnRQdHI7dmFyIHN0cmluZ1NlZ21lbnQ9VVRGOFRvU3RyaW5nKGRlY29kZVN0YXJ0UHRyLG1heFJlYWQpO2lmKHN0cj09PXVuZGVmaW5lZCl7c3RyPXN0cmluZ1NlZ21lbnQ7fWVsc2Uge3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgwKTtzdHIrPXN0cmluZ1NlZ21lbnQ7fWRlY29kZVN0YXJ0UHRyPWN1cnJlbnRCeXRlUHRyKzE7fX19ZWxzZSB7dmFyIGE9bmV3IEFycmF5KGxlbmd0aCk7Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXthW2ldPVN0cmluZy5mcm9tQ2hhckNvZGUoSEVBUFU4W3BheWxvYWQraV0pO31zdHI9YS5qb2luKCIiKTt9X2ZyZWUodmFsdWUpO3JldHVybiBzdHJ9LCJ0b1dpcmVUeXBlIihkZXN0cnVjdG9ycyx2YWx1ZSl7aWYodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7dmFsdWU9bmV3IFVpbnQ4QXJyYXkodmFsdWUpO312YXIgbGVuZ3RoO3ZhciB2YWx1ZUlzT2ZUeXBlU3RyaW5nPXR5cGVvZiB2YWx1ZT09InN0cmluZyI7aWYoISh2YWx1ZUlzT2ZUeXBlU3RyaW5nfHx2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fHZhbHVlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fHZhbHVlIGluc3RhbmNlb2YgSW50OEFycmF5KSl7dGhyb3dCaW5kaW5nRXJyb3IoIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmciKTt9aWYoc3RkU3RyaW5nSXNVVEY4JiZ2YWx1ZUlzT2ZUeXBlU3RyaW5nKXtsZW5ndGg9bGVuZ3RoQnl0ZXNVVEY4KHZhbHVlKTt9ZWxzZSB7bGVuZ3RoPXZhbHVlLmxlbmd0aDt9dmFyIGJhc2U9X21hbGxvYyg0K2xlbmd0aCsxKTt2YXIgcHRyPWJhc2UrNDtIRUFQVTMyW2Jhc2U+PjJdPWxlbmd0aDtpZihzdGRTdHJpbmdJc1VURjgmJnZhbHVlSXNPZlR5cGVTdHJpbmcpe3N0cmluZ1RvVVRGOCh2YWx1ZSxwdHIsbGVuZ3RoKzEpO31lbHNlIHtpZih2YWx1ZUlzT2ZUeXBlU3RyaW5nKXtmb3IodmFyIGk9MDtpPGxlbmd0aDsrK2kpe3ZhciBjaGFyQ29kZT12YWx1ZS5jaGFyQ29kZUF0KGkpO2lmKGNoYXJDb2RlPjI1NSl7X2ZyZWUocHRyKTt0aHJvd0JpbmRpbmdFcnJvcigiU3RyaW5nIGhhcyBVVEYtMTYgY29kZSB1bml0cyB0aGF0IGRvIG5vdCBmaXQgaW4gOCBiaXRzIik7fUhFQVBVOFtwdHIraV09Y2hhckNvZGU7fX1lbHNlIHtmb3IodmFyIGk9MDtpPGxlbmd0aDsrK2kpe0hFQVBVOFtwdHIraV09dmFsdWVbaV07fX19aWYoZGVzdHJ1Y3RvcnMhPT1udWxsKXtkZXN0cnVjdG9ycy5wdXNoKF9mcmVlLGJhc2UpO31yZXR1cm4gYmFzZX0sImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6cmVhZFBvaW50ZXIsZGVzdHJ1Y3RvckZ1bmN0aW9uKHB0cil7X2ZyZWUocHRyKTt9fSk7fTt2YXIgVVRGMTZEZWNvZGVyPXR5cGVvZiBUZXh0RGVjb2RlciE9InVuZGVmaW5lZCI/bmV3IFRleHREZWNvZGVyKCJ1dGYtMTZsZSIpOnVuZGVmaW5lZDt2YXIgVVRGMTZUb1N0cmluZz0ocHRyLG1heEJ5dGVzVG9SZWFkKT0+e3ZhciBlbmRQdHI9cHRyO3ZhciBpZHg9ZW5kUHRyPj4xO3ZhciBtYXhJZHg9aWR4K21heEJ5dGVzVG9SZWFkLzI7d2hpbGUoIShpZHg+PW1heElkeCkmJkhFQVBVMTZbaWR4XSkrK2lkeDtlbmRQdHI9aWR4PDwxO2lmKGVuZFB0ci1wdHI+MzImJlVURjE2RGVjb2RlcilyZXR1cm4gVVRGMTZEZWNvZGVyLmRlY29kZShIRUFQVTguc3ViYXJyYXkocHRyLGVuZFB0cikpO3ZhciBzdHI9IiI7Zm9yKHZhciBpPTA7IShpPj1tYXhCeXRlc1RvUmVhZC8yKTsrK2kpe3ZhciBjb2RlVW5pdD1IRUFQMTZbcHRyK2kqMj4+MV07aWYoY29kZVVuaXQ9PTApYnJlYWs7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVVbml0KTt9cmV0dXJuIHN0cn07dmFyIHN0cmluZ1RvVVRGMTY9KHN0cixvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKT0+e21heEJ5dGVzVG9Xcml0ZT8/PTIxNDc0ODM2NDc7aWYobWF4Qnl0ZXNUb1dyaXRlPDIpcmV0dXJuIDA7bWF4Qnl0ZXNUb1dyaXRlLT0yO3ZhciBzdGFydFB0cj1vdXRQdHI7dmFyIG51bUNoYXJzVG9Xcml0ZT1tYXhCeXRlc1RvV3JpdGU8c3RyLmxlbmd0aCoyP21heEJ5dGVzVG9Xcml0ZS8yOnN0ci5sZW5ndGg7Zm9yKHZhciBpPTA7aTxudW1DaGFyc1RvV3JpdGU7KytpKXt2YXIgY29kZVVuaXQ9c3RyLmNoYXJDb2RlQXQoaSk7SEVBUDE2W291dFB0cj4+MV09Y29kZVVuaXQ7b3V0UHRyKz0yO31IRUFQMTZbb3V0UHRyPj4xXT0wO3JldHVybiBvdXRQdHItc3RhcnRQdHJ9O3ZhciBsZW5ndGhCeXRlc1VURjE2PXN0cj0+c3RyLmxlbmd0aCoyO3ZhciBVVEYzMlRvU3RyaW5nPShwdHIsbWF4Qnl0ZXNUb1JlYWQpPT57dmFyIGk9MDt2YXIgc3RyPSIiO3doaWxlKCEoaT49bWF4Qnl0ZXNUb1JlYWQvNCkpe3ZhciB1dGYzMj1IRUFQMzJbcHRyK2kqND4+Ml07aWYodXRmMzI9PTApYnJlYWs7KytpO2lmKHV0ZjMyPj02NTUzNil7dmFyIGNoPXV0ZjMyLTY1NTM2O3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjaD4+MTAsNTYzMjB8Y2gmMTAyMyk7fWVsc2Uge3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1dGYzMik7fX1yZXR1cm4gc3RyfTt2YXIgc3RyaW5nVG9VVEYzMj0oc3RyLG91dFB0cixtYXhCeXRlc1RvV3JpdGUpPT57bWF4Qnl0ZXNUb1dyaXRlPz89MjE0NzQ4MzY0NztpZihtYXhCeXRlc1RvV3JpdGU8NClyZXR1cm4gMDt2YXIgc3RhcnRQdHI9b3V0UHRyO3ZhciBlbmRQdHI9c3RhcnRQdHIrbWF4Qnl0ZXNUb1dyaXRlLTQ7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIGNvZGVVbml0PXN0ci5jaGFyQ29kZUF0KGkpO2lmKGNvZGVVbml0Pj01NTI5NiYmY29kZVVuaXQ8PTU3MzQzKXt2YXIgdHJhaWxTdXJyb2dhdGU9c3RyLmNoYXJDb2RlQXQoKytpKTtjb2RlVW5pdD02NTUzNisoKGNvZGVVbml0JjEwMjMpPDwxMCl8dHJhaWxTdXJyb2dhdGUmMTAyMzt9SEVBUDMyW291dFB0cj4+Ml09Y29kZVVuaXQ7b3V0UHRyKz00O2lmKG91dFB0cis0PmVuZFB0cilicmVha31IRUFQMzJbb3V0UHRyPj4yXT0wO3JldHVybiBvdXRQdHItc3RhcnRQdHJ9O3ZhciBsZW5ndGhCeXRlc1VURjMyPXN0cj0+e3ZhciBsZW49MDtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgY29kZVVuaXQ9c3RyLmNoYXJDb2RlQXQoaSk7aWYoY29kZVVuaXQ+PTU1Mjk2JiZjb2RlVW5pdDw9NTczNDMpKytpO2xlbis9NDt9cmV0dXJuIGxlbn07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nPShyYXdUeXBlLGNoYXJTaXplLG5hbWUpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3ZhciBkZWNvZGVTdHJpbmcsZW5jb2RlU3RyaW5nLHJlYWRDaGFyQXQsbGVuZ3RoQnl0ZXNVVEY7aWYoY2hhclNpemU9PT0yKXtkZWNvZGVTdHJpbmc9VVRGMTZUb1N0cmluZztlbmNvZGVTdHJpbmc9c3RyaW5nVG9VVEYxNjtsZW5ndGhCeXRlc1VURj1sZW5ndGhCeXRlc1VURjE2O3JlYWRDaGFyQXQ9cG9pbnRlcj0+SEVBUFUxNltwb2ludGVyPj4xXTt9ZWxzZSBpZihjaGFyU2l6ZT09PTQpe2RlY29kZVN0cmluZz1VVEYzMlRvU3RyaW5nO2VuY29kZVN0cmluZz1zdHJpbmdUb1VURjMyO2xlbmd0aEJ5dGVzVVRGPWxlbmd0aEJ5dGVzVVRGMzI7cmVhZENoYXJBdD1wb2ludGVyPT5IRUFQVTMyW3BvaW50ZXI+PjJdO31yZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiOnZhbHVlPT57dmFyIGxlbmd0aD1IRUFQVTMyW3ZhbHVlPj4yXTt2YXIgc3RyO3ZhciBkZWNvZGVTdGFydFB0cj12YWx1ZSs0O2Zvcih2YXIgaT0wO2k8PWxlbmd0aDsrK2kpe3ZhciBjdXJyZW50Qnl0ZVB0cj12YWx1ZSs0K2kqY2hhclNpemU7aWYoaT09bGVuZ3RofHxyZWFkQ2hhckF0KGN1cnJlbnRCeXRlUHRyKT09MCl7dmFyIG1heFJlYWRCeXRlcz1jdXJyZW50Qnl0ZVB0ci1kZWNvZGVTdGFydFB0cjt2YXIgc3RyaW5nU2VnbWVudD1kZWNvZGVTdHJpbmcoZGVjb2RlU3RhcnRQdHIsbWF4UmVhZEJ5dGVzKTtpZihzdHI9PT11bmRlZmluZWQpe3N0cj1zdHJpbmdTZWdtZW50O31lbHNlIHtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoMCk7c3RyKz1zdHJpbmdTZWdtZW50O31kZWNvZGVTdGFydFB0cj1jdXJyZW50Qnl0ZVB0citjaGFyU2l6ZTt9fV9mcmVlKHZhbHVlKTtyZXR1cm4gc3RyfSwidG9XaXJlVHlwZSI6KGRlc3RydWN0b3JzLHZhbHVlKT0+e2lmKCEodHlwZW9mIHZhbHVlPT0ic3RyaW5nIikpe3Rocm93QmluZGluZ0Vycm9yKGBDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIEMrKyBzdHJpbmcgdHlwZSAke25hbWV9YCk7fXZhciBsZW5ndGg9bGVuZ3RoQnl0ZXNVVEYodmFsdWUpO3ZhciBwdHI9X21hbGxvYyg0K2xlbmd0aCtjaGFyU2l6ZSk7SEVBUFUzMltwdHI+PjJdPWxlbmd0aC9jaGFyU2l6ZTtlbmNvZGVTdHJpbmcodmFsdWUscHRyKzQsbGVuZ3RoK2NoYXJTaXplKTtpZihkZXN0cnVjdG9ycyE9PW51bGwpe2Rlc3RydWN0b3JzLnB1c2goX2ZyZWUscHRyKTt9cmV0dXJuIHB0cn0sImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6cmVhZFBvaW50ZXIsZGVzdHJ1Y3RvckZ1bmN0aW9uKHB0cil7X2ZyZWUocHRyKTt9fSk7fTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfdm9pZD0ocmF3VHlwZSxuYW1lKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7aXNWb2lkOnRydWUsbmFtZTpuYW1lLCJhcmdQYWNrQWR2YW5jZSI6MCwiZnJvbVdpcmVUeXBlIjooKT0+dW5kZWZpbmVkLCJ0b1dpcmVUeXBlIjooZGVzdHJ1Y3RvcnMsbyk9PnVuZGVmaW5lZH0pO307dmFyIGdldEhlYXBNYXg9KCk9PjIxNDc0ODM2NDg7dmFyIGdyb3dNZW1vcnk9c2l6ZT0+e3ZhciBiPXdhc21NZW1vcnkuYnVmZmVyO3ZhciBwYWdlcz0oc2l6ZS1iLmJ5dGVMZW5ndGgrNjU1MzUpLzY1NTM2O3RyeXt3YXNtTWVtb3J5Lmdyb3cocGFnZXMpO3VwZGF0ZU1lbW9yeVZpZXdzKCk7cmV0dXJuIDF9Y2F0Y2goZSl7fX07dmFyIF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwPXJlcXVlc3RlZFNpemU9Pnt2YXIgb2xkU2l6ZT1IRUFQVTgubGVuZ3RoO3JlcXVlc3RlZFNpemU+Pj49MDt2YXIgbWF4SGVhcFNpemU9Z2V0SGVhcE1heCgpO2lmKHJlcXVlc3RlZFNpemU+bWF4SGVhcFNpemUpe3JldHVybiBmYWxzZX12YXIgYWxpZ25VcD0oeCxtdWx0aXBsZSk9PngrKG11bHRpcGxlLXglbXVsdGlwbGUpJW11bHRpcGxlO2Zvcih2YXIgY3V0RG93bj0xO2N1dERvd248PTQ7Y3V0RG93bio9Mil7dmFyIG92ZXJHcm93bkhlYXBTaXplPW9sZFNpemUqKDErLjIvY3V0RG93bik7b3Zlckdyb3duSGVhcFNpemU9TWF0aC5taW4ob3Zlckdyb3duSGVhcFNpemUscmVxdWVzdGVkU2l6ZSsxMDA2NjMyOTYpO3ZhciBuZXdTaXplPU1hdGgubWluKG1heEhlYXBTaXplLGFsaWduVXAoTWF0aC5tYXgocmVxdWVzdGVkU2l6ZSxvdmVyR3Jvd25IZWFwU2l6ZSksNjU1MzYpKTt2YXIgcmVwbGFjZW1lbnQ9Z3Jvd01lbW9yeShuZXdTaXplKTtpZihyZXBsYWNlbWVudCl7cmV0dXJuIHRydWV9fXJldHVybiBmYWxzZX07ZW1iaW5kX2luaXRfY2hhckNvZGVzKCk7QmluZGluZ0Vycm9yPU1vZHVsZVsiQmluZGluZ0Vycm9yIl09Y2xhc3MgQmluZGluZ0Vycm9yIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IobWVzc2FnZSl7c3VwZXIobWVzc2FnZSk7dGhpcy5uYW1lPSJCaW5kaW5nRXJyb3IiO319O01vZHVsZVsiSW50ZXJuYWxFcnJvciJdPWNsYXNzIEludGVybmFsRXJyb3IgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihtZXNzYWdlKXtzdXBlcihtZXNzYWdlKTt0aGlzLm5hbWU9IkludGVybmFsRXJyb3IiO319O2luaXRfZW12YWwoKTt2YXIgd2FzbUltcG9ydHM9e2Y6X19lbWJpbmRfcmVnaXN0ZXJfYmlnaW50LGk6X19lbWJpbmRfcmVnaXN0ZXJfYm9vbCxoOl9fZW1iaW5kX3JlZ2lzdGVyX2VtdmFsLGU6X19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQsYjpfX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyLGE6X19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcsZDpfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nLGM6X19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmcsajpfX2VtYmluZF9yZWdpc3Rlcl92b2lkLGc6X2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXB9O3ZhciB3YXNtRXhwb3J0cz1jcmVhdGVXYXNtKCk7TW9kdWxlWyJfc29ydCJdPShhMCxhMSxhMixhMyxhNCxhNSxhNixhNyxhOCxhOSk9PihNb2R1bGVbIl9zb3J0Il09d2FzbUV4cG9ydHNbIm0iXSkoYTAsYTEsYTIsYTMsYTQsYTUsYTYsYTcsYTgsYTkpO3ZhciBfbWFsbG9jPU1vZHVsZVsiX21hbGxvYyJdPWEwPT4oX21hbGxvYz1Nb2R1bGVbIl9tYWxsb2MiXT13YXNtRXhwb3J0c1sibyJdKShhMCk7dmFyIF9mcmVlPU1vZHVsZVsiX2ZyZWUiXT1hMD0+KF9mcmVlPU1vZHVsZVsiX2ZyZWUiXT13YXNtRXhwb3J0c1sicCJdKShhMCk7dmFyIGNhbGxlZFJ1bjtkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9ZnVuY3Rpb24gcnVuQ2FsbGVyKCl7aWYoIWNhbGxlZFJ1bilydW4oKTtpZighY2FsbGVkUnVuKWRlcGVuZGVuY2llc0Z1bGZpbGxlZD1ydW5DYWxsZXI7fTtmdW5jdGlvbiBydW4oKXtpZihydW5EZXBlbmRlbmNpZXM+MCl7cmV0dXJufXByZVJ1bigpO2lmKHJ1bkRlcGVuZGVuY2llcz4wKXtyZXR1cm59ZnVuY3Rpb24gZG9SdW4oKXtpZihjYWxsZWRSdW4pcmV0dXJuO2NhbGxlZFJ1bj10cnVlO01vZHVsZVsiY2FsbGVkUnVuIl09dHJ1ZTtpZihBQk9SVClyZXR1cm47aW5pdFJ1bnRpbWUoKTtyZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7aWYoTW9kdWxlWyJvblJ1bnRpbWVJbml0aWFsaXplZCJdKU1vZHVsZVsib25SdW50aW1lSW5pdGlhbGl6ZWQiXSgpO3Bvc3RSdW4oKTt9aWYoTW9kdWxlWyJzZXRTdGF0dXMiXSl7TW9kdWxlWyJzZXRTdGF0dXMiXSgiUnVubmluZy4uLiIpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7TW9kdWxlWyJzZXRTdGF0dXMiXSgiIik7fSwxKTtkb1J1bigpO30sMSk7fWVsc2Uge2RvUnVuKCk7fX1pZihNb2R1bGVbInByZUluaXQiXSl7aWYodHlwZW9mIE1vZHVsZVsicHJlSW5pdCJdPT0iZnVuY3Rpb24iKU1vZHVsZVsicHJlSW5pdCJdPVtNb2R1bGVbInByZUluaXQiXV07d2hpbGUoTW9kdWxlWyJwcmVJbml0Il0ubGVuZ3RoPjApe01vZHVsZVsicHJlSW5pdCJdLnBvcCgpKCk7fX1ydW4oKTsKCgogICAgcmV0dXJuIG1vZHVsZUFyZy5yZWFkeQogIH0KICApOwogIH0pKCk7CgogIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55CiAgbGV0IHdhc21Nb2R1bGU7CiAgYXN5bmMgZnVuY3Rpb24gaW5pdFdhc20oKSB7CiAgICAgIHdhc21Nb2R1bGUgPSBhd2FpdCBsb2FkV2FzbSgpOwogIH0KICBsZXQgc29ydERhdGE7CiAgbGV0IHZpZXdQcm9qUHRyOwogIGxldCB0cmFuc2Zvcm1zUHRyOwogIGxldCB0cmFuc2Zvcm1JbmRpY2VzUHRyOwogIGxldCBwb3NpdGlvbnNQdHI7CiAgbGV0IGNodW5rc1B0cjsKICBsZXQgZGVwdGhCdWZmZXJQdHI7CiAgbGV0IGRlcHRoSW5kZXhQdHI7CiAgbGV0IHN0YXJ0c1B0cjsKICBsZXQgY291bnRzUHRyOwogIGxldCBhbGxvY2F0ZWRWZXJ0ZXhDb3VudCA9IDA7CiAgbGV0IGFsbG9jYXRlZFRyYW5zZm9ybUNvdW50ID0gMDsKICBsZXQgdmlld1Byb2ogPSBuZXcgRmxvYXQzMkFycmF5KDE2KTsKICBsZXQgbG9jayA9IGZhbHNlOwogIGxldCBhbGxvY2F0aW9uUGVuZGluZyA9IGZhbHNlOwogIGxldCBzb3J0aW5nID0gZmFsc2U7CiAgY29uc3QgYWxsb2NhdGVCdWZmZXJzID0gYXN5bmMgKCkgPT4gewogICAgICBpZiAobG9jaykgewogICAgICAgICAgYWxsb2NhdGlvblBlbmRpbmcgPSB0cnVlOwogICAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGxvY2sgPSB0cnVlOwogICAgICBhbGxvY2F0aW9uUGVuZGluZyA9IGZhbHNlOwogICAgICBpZiAoIXdhc21Nb2R1bGUpCiAgICAgICAgICBhd2FpdCBpbml0V2FzbSgpOwogICAgICBjb25zdCB0YXJnZXRBbGxvY2F0ZWRWZXJ0ZXhDb3VudCA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIoc29ydERhdGEudmVydGV4Q291bnQpKSk7CiAgICAgIGlmIChhbGxvY2F0ZWRWZXJ0ZXhDb3VudCA8IHRhcmdldEFsbG9jYXRlZFZlcnRleENvdW50KSB7CiAgICAgICAgICBpZiAoYWxsb2NhdGVkVmVydGV4Q291bnQgPiAwKSB7CiAgICAgICAgICAgICAgd2FzbU1vZHVsZS5fZnJlZSh2aWV3UHJvalB0cik7CiAgICAgICAgICAgICAgd2FzbU1vZHVsZS5fZnJlZSh0cmFuc2Zvcm1JbmRpY2VzUHRyKTsKICAgICAgICAgICAgICB3YXNtTW9kdWxlLl9mcmVlKHBvc2l0aW9uc1B0cik7CiAgICAgICAgICAgICAgd2FzbU1vZHVsZS5fZnJlZShjaHVua3NQdHIpOwogICAgICAgICAgICAgIHdhc21Nb2R1bGUuX2ZyZWUoZGVwdGhCdWZmZXJQdHIpOwogICAgICAgICAgICAgIHdhc21Nb2R1bGUuX2ZyZWUoZGVwdGhJbmRleFB0cik7CiAgICAgICAgICAgICAgd2FzbU1vZHVsZS5fZnJlZShzdGFydHNQdHIpOwogICAgICAgICAgICAgIHdhc21Nb2R1bGUuX2ZyZWUoY291bnRzUHRyKTsKICAgICAgICAgIH0KICAgICAgICAgIGFsbG9jYXRlZFZlcnRleENvdW50ID0gdGFyZ2V0QWxsb2NhdGVkVmVydGV4Q291bnQ7CiAgICAgICAgICB2aWV3UHJvalB0ciA9IHdhc21Nb2R1bGUuX21hbGxvYygxNiAqIDQpOwogICAgICAgICAgdHJhbnNmb3JtSW5kaWNlc1B0ciA9IHdhc21Nb2R1bGUuX21hbGxvYyhhbGxvY2F0ZWRWZXJ0ZXhDb3VudCAqIDQpOwogICAgICAgICAgcG9zaXRpb25zUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKDMgKiBhbGxvY2F0ZWRWZXJ0ZXhDb3VudCAqIDQpOwogICAgICAgICAgY2h1bmtzUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKGFsbG9jYXRlZFZlcnRleENvdW50KTsKICAgICAgICAgIGRlcHRoQnVmZmVyUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKGFsbG9jYXRlZFZlcnRleENvdW50ICogNCk7CiAgICAgICAgICBkZXB0aEluZGV4UHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKGFsbG9jYXRlZFZlcnRleENvdW50ICogNCk7CiAgICAgICAgICBzdGFydHNQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoYWxsb2NhdGVkVmVydGV4Q291bnQgKiA0KTsKICAgICAgICAgIGNvdW50c1B0ciA9IHdhc21Nb2R1bGUuX21hbGxvYyhhbGxvY2F0ZWRWZXJ0ZXhDb3VudCAqIDQpOwogICAgICB9CiAgICAgIGlmIChhbGxvY2F0ZWRUcmFuc2Zvcm1Db3VudCA8IHNvcnREYXRhLnRyYW5zZm9ybXMubGVuZ3RoKSB7CiAgICAgICAgICBpZiAoYWxsb2NhdGVkVHJhbnNmb3JtQ291bnQgPiAwKSB7CiAgICAgICAgICAgICAgd2FzbU1vZHVsZS5fZnJlZSh0cmFuc2Zvcm1zUHRyKTsKICAgICAgICAgIH0KICAgICAgICAgIGFsbG9jYXRlZFRyYW5zZm9ybUNvdW50ID0gc29ydERhdGEudHJhbnNmb3Jtcy5sZW5ndGg7CiAgICAgICAgICB0cmFuc2Zvcm1zUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKGFsbG9jYXRlZFRyYW5zZm9ybUNvdW50ICogNCk7CiAgICAgIH0KICAgICAgbG9jayA9IGZhbHNlOwogICAgICBpZiAoYWxsb2NhdGlvblBlbmRpbmcpIHsKICAgICAgICAgIGFsbG9jYXRpb25QZW5kaW5nID0gZmFsc2U7CiAgICAgICAgICBhd2FpdCBhbGxvY2F0ZUJ1ZmZlcnMoKTsKICAgICAgfQogIH07CiAgY29uc3QgcnVuU29ydCA9ICgpID0+IHsKICAgICAgaWYgKGxvY2sgfHwgYWxsb2NhdGlvblBlbmRpbmcgfHwgIXdhc21Nb2R1bGUpCiAgICAgICAgICByZXR1cm47CiAgICAgIGxvY2sgPSB0cnVlOwogICAgICB3YXNtTW9kdWxlLkhFQVBGMzIuc2V0KHNvcnREYXRhLnBvc2l0aW9ucywgcG9zaXRpb25zUHRyIC8gNCk7CiAgICAgIHdhc21Nb2R1bGUuSEVBUEYzMi5zZXQoc29ydERhdGEudHJhbnNmb3JtcywgdHJhbnNmb3Jtc1B0ciAvIDQpOwogICAgICB3YXNtTW9kdWxlLkhFQVBVMzIuc2V0KHNvcnREYXRhLnRyYW5zZm9ybUluZGljZXMsIHRyYW5zZm9ybUluZGljZXNQdHIgLyA0KTsKICAgICAgd2FzbU1vZHVsZS5IRUFQRjMyLnNldCh2aWV3UHJvaiwgdmlld1Byb2pQdHIgLyA0KTsKICAgICAgd2FzbU1vZHVsZS5fc29ydCh2aWV3UHJvalB0ciwgdHJhbnNmb3Jtc1B0ciwgdHJhbnNmb3JtSW5kaWNlc1B0ciwgc29ydERhdGEudmVydGV4Q291bnQsIHBvc2l0aW9uc1B0ciwgY2h1bmtzUHRyLCBkZXB0aEJ1ZmZlclB0ciwgZGVwdGhJbmRleFB0ciwgc3RhcnRzUHRyLCBjb3VudHNQdHIpOwogICAgICBjb25zdCBkZXB0aEluZGV4ID0gbmV3IFVpbnQzMkFycmF5KHdhc21Nb2R1bGUuSEVBUFUzMi5idWZmZXIsIGRlcHRoSW5kZXhQdHIsIHNvcnREYXRhLnZlcnRleENvdW50KTsKICAgICAgY29uc3QgZGV0YWNoZWREZXB0aEluZGV4ID0gbmV3IFVpbnQzMkFycmF5KGRlcHRoSW5kZXguc2xpY2UoKS5idWZmZXIpOwogICAgICBjb25zdCBjaHVua3MgPSBuZXcgVWludDhBcnJheSh3YXNtTW9kdWxlLkhFQVBVOC5idWZmZXIsIGNodW5rc1B0ciwgc29ydERhdGEudmVydGV4Q291bnQpOwogICAgICBjb25zdCBkZXRhY2hlZENodW5rcyA9IG5ldyBVaW50OEFycmF5KGNodW5rcy5zbGljZSgpLmJ1ZmZlcik7CiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBkZXB0aEluZGV4OiBkZXRhY2hlZERlcHRoSW5kZXgsIGNodW5rczogZGV0YWNoZWRDaHVua3MgfSwgWwogICAgICAgICAgZGV0YWNoZWREZXB0aEluZGV4LmJ1ZmZlciwKICAgICAgICAgIGRldGFjaGVkQ2h1bmtzLmJ1ZmZlciwKICAgICAgXSk7CiAgICAgIGxvY2sgPSBmYWxzZTsKICB9OwogIGNvbnN0IHRocm90dGxlZFNvcnQgPSAoKSA9PiB7CiAgICAgIGlmICghc29ydGluZykgewogICAgICAgICAgc29ydGluZyA9IHRydWU7CiAgICAgICAgICBydW5Tb3J0KCk7CiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICBzb3J0aW5nID0gZmFsc2U7CiAgICAgICAgICAgICAgdGhyb3R0bGVkU29ydCgpOwogICAgICAgICAgfSk7CiAgICAgIH0KICB9OwogIHNlbGYub25tZXNzYWdlID0gKGUpID0+IHsKICAgICAgaWYgKGUuZGF0YS5zb3J0RGF0YSkgewogICAgICAgICAgc29ydERhdGEgPSB7CiAgICAgICAgICAgICAgcG9zaXRpb25zOiBGbG9hdDMyQXJyYXkuZnJvbShlLmRhdGEuc29ydERhdGEucG9zaXRpb25zKSwKICAgICAgICAgICAgICB0cmFuc2Zvcm1zOiBGbG9hdDMyQXJyYXkuZnJvbShlLmRhdGEuc29ydERhdGEudHJhbnNmb3JtcyksCiAgICAgICAgICAgICAgdHJhbnNmb3JtSW5kaWNlczogVWludDMyQXJyYXkuZnJvbShlLmRhdGEuc29ydERhdGEudHJhbnNmb3JtSW5kaWNlcyksCiAgICAgICAgICAgICAgdmVydGV4Q291bnQ6IGUuZGF0YS5zb3J0RGF0YS52ZXJ0ZXhDb3VudCwKICAgICAgICAgIH07CiAgICAgICAgICBhbGxvY2F0ZUJ1ZmZlcnMoKTsKICAgICAgfQogICAgICBpZiAoZS5kYXRhLnZpZXdQcm9qKSB7CiAgICAgICAgICB2aWV3UHJvaiA9IEZsb2F0MzJBcnJheS5mcm9tKGUuZGF0YS52aWV3UHJvaik7CiAgICAgICAgICB0aHJvdHRsZWRTb3J0KCk7CiAgICAgIH0KICB9OwoKfSkoKTsKLy8jIHNvdXJjZU1hcHBpbmdVUkw9U29ydFdvcmtlci5qcy5tYXAKCg==", null, false);
var J = class {
  constructor(A2, Q2) {
    this._scene = null, this._camera = null, this._started = false, this._initialized = false, this._renderer = A2;
    const F2 = A2.gl;
    this._program = F2.createProgram(), this._passes = Q2 || [];
    const U2 = F2.createShader(F2.VERTEX_SHADER);
    F2.shaderSource(U2, this._getVertexSource()), F2.compileShader(U2), F2.getShaderParameter(U2, F2.COMPILE_STATUS) || console.error(F2.getShaderInfoLog(U2));
    const B2 = F2.createShader(F2.FRAGMENT_SHADER);
    F2.shaderSource(B2, this._getFragmentSource()), F2.compileShader(B2), F2.getShaderParameter(B2, F2.COMPILE_STATUS) || console.error(F2.getShaderInfoLog(B2)), F2.attachShader(this.program, U2), F2.attachShader(this.program, B2), F2.linkProgram(this.program), F2.getProgramParameter(this.program, F2.LINK_STATUS) || console.error(F2.getProgramInfoLog(this.program)), this.resize = () => {
      F2.useProgram(this._program), this._resize();
    }, this.initialize = () => {
      console.assert(!this._initialized, "ShaderProgram already initialized"), F2.useProgram(this._program), this._initialize();
      for (const A3 of this.passes)
        A3.initialize(this);
      this._initialized = true, this._started = true;
    }, this.render = (A3, Q3) => {
      F2.useProgram(this._program), this._scene === A3 && this._camera === Q3 || (this.dispose(), this._scene = A3, this._camera = Q3, this.initialize());
      for (const A4 of this.passes)
        A4.render();
      this._render();
    }, this.dispose = () => {
      if (this._initialized) {
        F2.useProgram(this._program);
        for (const A3 of this.passes)
          A3.dispose();
        this._dispose(), this._scene = null, this._camera = null, this._initialized = false;
      }
    };
  }
  get renderer() {
    return this._renderer;
  }
  get scene() {
    return this._scene;
  }
  get camera() {
    return this._camera;
  }
  get program() {
    return this._program;
  }
  get passes() {
    return this._passes;
  }
  get started() {
    return this._started;
  }
};
var r = s("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgdmFyIGxvYWRXYXNtID0gKCgpID0+IHsKICAgIAogICAgcmV0dXJuICgKICBmdW5jdGlvbihtb2R1bGVBcmcgPSB7fSkgewoKICB2YXIgTW9kdWxlPW1vZHVsZUFyZzt2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSxyZWFkeVByb21pc2VSZWplY3Q7TW9kdWxlWyJyZWFkeSJdPW5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntyZWFkeVByb21pc2VSZXNvbHZlPXJlc29sdmU7cmVhZHlQcm9taXNlUmVqZWN0PXJlamVjdDt9KTt2YXIgbW9kdWxlT3ZlcnJpZGVzPU9iamVjdC5hc3NpZ24oe30sTW9kdWxlKTt2YXIgc2NyaXB0RGlyZWN0b3J5PSIiO2Z1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCl7aWYoTW9kdWxlWyJsb2NhdGVGaWxlIl0pe3JldHVybiBNb2R1bGVbImxvY2F0ZUZpbGUiXShwYXRoLHNjcmlwdERpcmVjdG9yeSl9cmV0dXJuIHNjcmlwdERpcmVjdG9yeStwYXRofXZhciByZWFkQmluYXJ5O3t7c2NyaXB0RGlyZWN0b3J5PXNlbGYubG9jYXRpb24uaHJlZjt9aWYoc2NyaXB0RGlyZWN0b3J5LnN0YXJ0c1dpdGgoImJsb2I6Iikpe3NjcmlwdERpcmVjdG9yeT0iIjt9ZWxzZSB7c2NyaXB0RGlyZWN0b3J5PXNjcmlwdERpcmVjdG9yeS5zdWJzdHIoMCxzY3JpcHREaXJlY3RvcnkucmVwbGFjZSgvWz8jXS4qLywiIikubGFzdEluZGV4T2YoIi8iKSsxKTt9e3tyZWFkQmluYXJ5PXVybD0+e3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKCJHRVQiLHVybCxmYWxzZSk7eGhyLnJlc3BvbnNlVHlwZT0iYXJyYXlidWZmZXIiO3hoci5zZW5kKG51bGwpO3JldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpfTt9fX1Nb2R1bGVbInByaW50Il18fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7dmFyIGVycj1Nb2R1bGVbInByaW50RXJyIl18fGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKE1vZHVsZSxtb2R1bGVPdmVycmlkZXMpO21vZHVsZU92ZXJyaWRlcz1udWxsO2lmKE1vZHVsZVsiYXJndW1lbnRzIl0pTW9kdWxlWyJhcmd1bWVudHMiXTtpZihNb2R1bGVbInRoaXNQcm9ncmFtIl0pTW9kdWxlWyJ0aGlzUHJvZ3JhbSJdO2lmKE1vZHVsZVsicXVpdCJdKU1vZHVsZVsicXVpdCJdO3ZhciB3YXNtQmluYXJ5O2lmKE1vZHVsZVsid2FzbUJpbmFyeSJdKXdhc21CaW5hcnk9TW9kdWxlWyJ3YXNtQmluYXJ5Il07aWYodHlwZW9mIFdlYkFzc2VtYmx5IT0ib2JqZWN0Iil7YWJvcnQoIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQiKTt9ZnVuY3Rpb24gaW50QXJyYXlGcm9tQmFzZTY0KHMpe3ZhciBkZWNvZGVkPWF0b2Iocyk7dmFyIGJ5dGVzPW5ldyBVaW50OEFycmF5KGRlY29kZWQubGVuZ3RoKTtmb3IodmFyIGk9MDtpPGRlY29kZWQubGVuZ3RoOysraSl7Ynl0ZXNbaV09ZGVjb2RlZC5jaGFyQ29kZUF0KGkpO31yZXR1cm4gYnl0ZXN9ZnVuY3Rpb24gdHJ5UGFyc2VBc0RhdGFVUkkoZmlsZW5hbWUpe2lmKCFpc0RhdGFVUkkoZmlsZW5hbWUpKXtyZXR1cm59cmV0dXJuIGludEFycmF5RnJvbUJhc2U2NChmaWxlbmFtZS5zbGljZShkYXRhVVJJUHJlZml4Lmxlbmd0aCkpfXZhciB3YXNtTWVtb3J5O3ZhciBBQk9SVD1mYWxzZTt2YXIgSEVBUDgsSEVBUFU4LEhFQVAxNixIRUFQVTE2LEhFQVAzMixIRUFQVTMyLEhFQVBGMzIsSEVBUEY2NDtmdW5jdGlvbiB1cGRhdGVNZW1vcnlWaWV3cygpe3ZhciBiPXdhc21NZW1vcnkuYnVmZmVyO01vZHVsZVsiSEVBUDgiXT1IRUFQOD1uZXcgSW50OEFycmF5KGIpO01vZHVsZVsiSEVBUDE2Il09SEVBUDE2PW5ldyBJbnQxNkFycmF5KGIpO01vZHVsZVsiSEVBUFU4Il09SEVBUFU4PW5ldyBVaW50OEFycmF5KGIpO01vZHVsZVsiSEVBUFUxNiJdPUhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGIpO01vZHVsZVsiSEVBUDMyIl09SEVBUDMyPW5ldyBJbnQzMkFycmF5KGIpO01vZHVsZVsiSEVBUFUzMiJdPUhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KGIpO01vZHVsZVsiSEVBUEYzMiJdPUhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheShiKTtNb2R1bGVbIkhFQVBGNjQiXT1IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkoYik7fXZhciBfX0FUUFJFUlVOX189W107dmFyIF9fQVRJTklUX189W107dmFyIF9fQVRQT1NUUlVOX189W107ZnVuY3Rpb24gcHJlUnVuKCl7aWYoTW9kdWxlWyJwcmVSdW4iXSl7aWYodHlwZW9mIE1vZHVsZVsicHJlUnVuIl09PSJmdW5jdGlvbiIpTW9kdWxlWyJwcmVSdW4iXT1bTW9kdWxlWyJwcmVSdW4iXV07d2hpbGUoTW9kdWxlWyJwcmVSdW4iXS5sZW5ndGgpe2FkZE9uUHJlUnVuKE1vZHVsZVsicHJlUnVuIl0uc2hpZnQoKSk7fX1jYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pO31mdW5jdGlvbiBpbml0UnVudGltZSgpe2NhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRJTklUX18pO31mdW5jdGlvbiBwb3N0UnVuKCl7aWYoTW9kdWxlWyJwb3N0UnVuIl0pe2lmKHR5cGVvZiBNb2R1bGVbInBvc3RSdW4iXT09ImZ1bmN0aW9uIilNb2R1bGVbInBvc3RSdW4iXT1bTW9kdWxlWyJwb3N0UnVuIl1dO3doaWxlKE1vZHVsZVsicG9zdFJ1biJdLmxlbmd0aCl7YWRkT25Qb3N0UnVuKE1vZHVsZVsicG9zdFJ1biJdLnNoaWZ0KCkpO319Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyk7fWZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKXtfX0FUUFJFUlVOX18udW5zaGlmdChjYik7fWZ1bmN0aW9uIGFkZE9uSW5pdChjYil7X19BVElOSVRfXy51bnNoaWZ0KGNiKTt9ZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKXtfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpO312YXIgcnVuRGVwZW5kZW5jaWVzPTA7dmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2Z1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpe3J1bkRlcGVuZGVuY2llcysrO01vZHVsZVsibW9uaXRvclJ1bkRlcGVuZGVuY2llcyJdPy4ocnVuRGVwZW5kZW5jaWVzKTt9ZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCl7cnVuRGVwZW5kZW5jaWVzLS07TW9kdWxlWyJtb25pdG9yUnVuRGVwZW5kZW5jaWVzIl0/LihydW5EZXBlbmRlbmNpZXMpO2lmKHJ1bkRlcGVuZGVuY2llcz09MCl7aWYoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKXt2YXIgY2FsbGJhY2s9ZGVwZW5kZW5jaWVzRnVsZmlsbGVkO2RlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2NhbGxiYWNrKCk7fX19ZnVuY3Rpb24gYWJvcnQod2hhdCl7TW9kdWxlWyJvbkFib3J0Il0/Lih3aGF0KTt3aGF0PSJBYm9ydGVkKCIrd2hhdCsiKSI7ZXJyKHdoYXQpO0FCT1JUPXRydWU7d2hhdCs9Ii4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby4iO3ZhciBlPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7cmVhZHlQcm9taXNlUmVqZWN0KGUpO3Rocm93IGV9dmFyIGRhdGFVUklQcmVmaXg9ImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCwiO3ZhciBpc0RhdGFVUkk9ZmlsZW5hbWU9PmZpbGVuYW1lLnN0YXJ0c1dpdGgoZGF0YVVSSVByZWZpeCk7dmFyIHdhc21CaW5hcnlGaWxlO3dhc21CaW5hcnlGaWxlPSJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsQUdGemJRRUFBQUFCWnc5Z0JIOS9mMzhBWUFOL2YzOEFZQVYvZjM5L2Z3QmdCbjkvZjM5L2Z3QmdBWDhCZjJBQmZ3QmdBbjkvQUdBRGYzOS9BWDlnQUFCZ0IzOS9mMzkvZjM4QVlBSjlmUUYvWUFSL2YzNStBR0FCZlFGL1lBdC9mMzkvZjM5L2YzOS9md0JnQW45L0FYOENQUW9CWVFGaEFBRUJZUUZpQUFJQllRRmpBQUVCWVFGa0FBWUJZUUZsQUFFQllRRm1BQWtCWVFGbkFBUUJZUUZvQUFVQllRRnBBQUFCWVFGcUFBWURHeG9IQkFvRkNBVUdDQXNCQUFFRkRBUUVEUU1EQWdJQUFBNEhCd1FGQVhBQkVCQUZCd0VCZ0FLQWdBSUdDQUYvQVVHd25nUUxCeGtHQVdzQ0FBRnNBQTRCYlFBYUFXNEJBQUZ2QUJrQmNBQVBDUlVCQUVFQkN3OFJHQTBXRmlNTkloc2RJQTBjSGg4SzZWQWFjUUVCZnlBQ1JRUkFJQUFvQWdRZ0FTZ0NCRVlQQ3lBQUlBRkdCRUJCQVE4TEFrQWdBQ2dDQkNJQ0xRQUFJZ0JGSUFBZ0FTZ0NCQ0lCTFFBQUlnTkhjZzBBQTBBZ0FTMEFBU0VESUFJdEFBRWlBRVVOQVNBQlFRRnFJUUVnQWtFQmFpRUNJQUFnQTBZTkFBc0xJQUFnQTBZTFR3RUNmMEdvR2lnQ0FDSUJJQUJCQjJwQmVIRWlBbW9oQUFKQUlBSkJBQ0FBSUFGTkcwVUVRQ0FBUHdCQkVIUk5EUUVnQUJBR0RRRUxRYmdhUVRBMkFnQkJmdzhMUWFnYUlBQTJBZ0FnQVFzT0FDQUFFQmNnQVJBWFFSQjBjZ3NHQUNBQUVBOExLUUJCc0JwQkFUWUNBRUcwR2tFQU5nSUFFQkZCdEJwQnJCb29BZ0EyQWdCQnJCcEJzQm8yQWdBTDJRc0JCMzhDUUNBQVJRMEFJQUJCQ0dzaUF5QUFRUVJyS0FJQUlnRkJlSEVpQUdvaEJRSkFJQUZCQVhFTkFDQUJRUUp4UlEwQklBTWdBeWdDQUNJQmF5SURRY3dhS0FJQVNRMEJJQUFnQVdvaEFBSkFBa0JCMEJvb0FnQWdBMGNFUUNBREtBSU1JUUlnQVVIL0FVMEVRQ0FCUVFOMklRRWdBeWdDQ0NJRUlBSkdCRUJCdkJwQnZCb29BZ0JCZmlBQmQzRTJBZ0FNQlFzZ0JDQUNOZ0lNSUFJZ0JEWUNDQXdFQ3lBREtBSVlJUVlnQWlBRFJ3UkFJQU1vQWdnaUFTQUNOZ0lNSUFJZ0FUWUNDQXdEQ3lBREtBSVVJZ0VFZnlBRFFSUnFCU0FES0FJUUlnRkZEUUlnQTBFUWFnc2hCQU5BSUFRaEJ5QUJJZ0pCRkdvaEJDQUNLQUlVSWdFTkFDQUNRUkJxSVFRZ0FpZ0NFQ0lCRFFBTElBZEJBRFlDQUF3Q0N5QUZLQUlFSWdGQkEzRkJBMGNOQWtIRUdpQUFOZ0lBSUFVZ0FVRitjVFlDQkNBRElBQkJBWEkyQWdRZ0JTQUFOZ0lBRHd0QkFDRUNDeUFHUlEwQUFrQWdBeWdDSENJQlFRSjBRZXdjYWlJRUtBSUFJQU5HQkVBZ0JDQUNOZ0lBSUFJTkFVSEFHa0hBR2lnQ0FFRitJQUYzY1RZQ0FBd0NDeUFHUVJCQkZDQUdLQUlRSUFOR0cyb2dBallDQUNBQ1JRMEJDeUFDSUFZMkFoZ2dBeWdDRUNJQkJFQWdBaUFCTmdJUUlBRWdBallDR0FzZ0F5Z0NGQ0lCUlEwQUlBSWdBVFlDRkNBQklBSTJBaGdMSUFNZ0JVOE5BQ0FGS0FJRUlnRkJBWEZGRFFBQ1FBSkFBa0FDUUNBQlFRSnhSUVJBUWRRYUtBSUFJQVZHQkVCQjFCb2dBellDQUVISUdrSElHaWdDQUNBQWFpSUFOZ0lBSUFNZ0FFRUJjallDQkNBRFFkQWFLQUlBUncwR1FjUWFRUUEyQWdCQjBCcEJBRFlDQUE4TFFkQWFLQUlBSUFWR0JFQkIwQm9nQXpZQ0FFSEVHa0hFR2lnQ0FDQUFhaUlBTmdJQUlBTWdBRUVCY2pZQ0JDQUFJQU5xSUFBMkFnQVBDeUFCUVhoeElBQnFJUUFnQlNnQ0RDRUNJQUZCL3dGTkJFQWdBVUVEZGlFQklBVW9BZ2dpQkNBQ1JnUkFRYndhUWJ3YUtBSUFRWDRnQVhkeE5nSUFEQVVMSUFRZ0FqWUNEQ0FDSUFRMkFnZ01CQXNnQlNnQ0dDRUdJQUlnQlVjRVFFSE1HaWdDQUJvZ0JTZ0NDQ0lCSUFJMkFnd2dBaUFCTmdJSURBTUxJQVVvQWhRaUFRUi9JQVZCRkdvRklBVW9BaEFpQVVVTkFpQUZRUkJxQ3lFRUEwQWdCQ0VISUFFaUFrRVVhaUVFSUFJb0FoUWlBUTBBSUFKQkVHb2hCQ0FDS0FJUUlnRU5BQXNnQjBFQU5nSUFEQUlMSUFVZ0FVRitjVFlDQkNBRElBQkJBWEkyQWdRZ0FDQURhaUFBTmdJQURBTUxRUUFoQWdzZ0JrVU5BQUpBSUFVb0Fod2lBVUVDZEVIc0hHb2lCQ2dDQUNBRlJnUkFJQVFnQWpZQ0FDQUNEUUZCd0JwQndCb29BZ0JCZmlBQmQzRTJBZ0FNQWdzZ0JrRVFRUlFnQmlnQ0VDQUZSaHRxSUFJMkFnQWdBa1VOQVFzZ0FpQUdOZ0lZSUFVb0FoQWlBUVJBSUFJZ0FUWUNFQ0FCSUFJMkFoZ0xJQVVvQWhRaUFVVU5BQ0FDSUFFMkFoUWdBU0FDTmdJWUN5QURJQUJCQVhJMkFnUWdBQ0FEYWlBQU5nSUFJQU5CMEJvb0FnQkhEUUJCeEJvZ0FEWUNBQThMSUFCQi93Rk5CRUFnQUVGNGNVSGtHbW9oQVFKL1Fid2FLQUlBSWdSQkFTQUFRUU4yZENJQWNVVUVRRUc4R2lBQUlBUnlOZ0lBSUFFTUFRc2dBU2dDQ0FzaEFDQUJJQU0yQWdnZ0FDQUROZ0lNSUFNZ0FUWUNEQ0FESUFBMkFnZ1BDMEVmSVFJZ0FFSC8vLzhIVFFSQUlBQkJKaUFBUVFoMlp5SUJhM1pCQVhFZ0FVRUJkR3RCUG1vaEFnc2dBeUFDTmdJY0lBTkNBRGNDRUNBQ1FRSjBRZXdjYWlFSEFuOENRQUovUWNBYUtBSUFJZ0ZCQVNBQ2RDSUVjVVVFUUVIQUdpQUJJQVJ5TmdJQVFSZ2hBaUFISVFSQkNBd0JDeUFBUVJrZ0FrRUJkbXRCQUNBQ1FSOUhHM1FoQWlBSEtBSUFJUVFEUUNBRUlnRW9BZ1JCZUhFZ0FFWU5BaUFDUVIxMklRUWdBa0VCZENFQ0lBRWdCRUVFY1dwQkVHb2lCeWdDQUNJRURRQUxRUmdoQWlBQklRUkJDQXNoQUNBRElnRU1BUXNnQVNnQ0NDSUVJQU0yQWd4QkNDRUNJQUZCQ0dvaEIwRVlJUUJCQUFzaEJTQUhJQU0yQWdBZ0FpQURhaUFFTmdJQUlBTWdBVFlDRENBQUlBTnFJQVUyQWdCQjNCcEIzQm9vQWdCQkFXc2lBRUYvSUFBYk5nSUFDd3NoQUNBQkJFQURRQ0FBUVFBNkFBQWdBRUVCYWlFQUlBRkJBV3NpQVEwQUN3c0wzZ01BUWR3WFFZb0pFQWxCNkJkQnVRaEJBVUVBRUFoQjlCZEJ0QWhCQVVHQWYwSC9BQkFCUVl3WVFhMElRUUZCZ0g5Qi93QVFBVUdBR0VHckNFRUJRUUJCL3dFUUFVR1lHRUdKQ0VFQ1FZQ0Fma0gvL3dFUUFVR2tHRUdBQ0VFQ1FRQkIvLzhERUFGQnNCaEJtQWhCQkVHQWdJQ0FlRUgvLy8vL0J4QUJRYndZUVk4SVFRUkJBRUYvRUFGQnlCaEJ4d2hCQkVHQWdJQ0FlRUgvLy8vL0J4QUJRZFFZUWI0SVFRUkJBRUYvRUFGQjRCaEJvd2hDZ0lDQWdJQ0FnSUNBZjBMLy8vLy8vLy8vLy84QUVCSkI3QmhCb2doQ0FFSi9FQkpCK0JoQm5BaEJCQkFFUVlRWlFZTUpRUWdRQkVIMERrSFpDQkFEUWJ3UFFZY05FQU5CaEJCQkJFSE1DQkFDUWRBUVFRSkI1UWdRQWtHY0VVRUVRZlFJRUFKQnVCRVFCMEhnRVVFQVFjSU1FQUJCaUJKQkFFR29EUkFBUWJBU1FRRkI0QXdRQUVIWUVrRUNRWThKRUFCQmdCTkJBMEd1Q1JBQVFhZ1RRUVJCMWdrUUFFSFFFMEVGUWZNSkVBQkIrQk5CQkVITkRSQUFRYUFVUVFWQjZ3MFFBRUdJRWtFQVFka0tFQUJCc0JKQkFVRzRDaEFBUWRnU1FRSkJtd3NRQUVHQUUwRURRZmtLRUFCQnFCTkJCRUdoREJBQVFkQVRRUVZCL3dzUUFFSElGRUVJUWQ0TEVBQkI4QlJCQ1VHOEN4QUFRWmdWUVFaQm1Rb1FBRUhBRlVFSFFaSU9FQUFMSEFBZ0FDQUJRUWdnQXFjZ0FrSWdpS2NnQTZjZ0EwSWdpS2NRQlFzZ0FBSkFJQUFvQWdRZ0FVY05BQ0FBS0FJY1FRRkdEUUFnQUNBQ05nSWNDd3VhQVFBZ0FFRUJPZ0ExQWtBZ0FDZ0NCQ0FDUncwQUlBQkJBVG9BTkFKQUlBQW9BaEFpQWtVRVFDQUFRUUUyQWlRZ0FDQUROZ0lZSUFBZ0FUWUNFQ0FEUVFGSERRSWdBQ2dDTUVFQlJnMEJEQUlMSUFFZ0FrWUVRQ0FBS0FJWUlnSkJBa1lFUUNBQUlBTTJBaGdnQXlFQ0N5QUFLQUl3UVFGSERRSWdBa0VCUmcwQkRBSUxJQUFnQUNnQ0pFRUJhallDSkFzZ0FFRUJPZ0EyQ3d0ZEFRRi9JQUFvQWhBaUEwVUVRQ0FBUVFFMkFpUWdBQ0FDTmdJWUlBQWdBVFlDRUE4TEFrQWdBU0FEUmdSQUlBQW9BaGhCQWtjTkFTQUFJQUkyQWhnUEN5QUFRUUU2QURZZ0FFRUNOZ0lZSUFBZ0FDZ0NKRUVCYWpZQ0pBc0xBZ0FMZHdFRWZ5QUF2Q0lFUWYvLy93TnhJUUVDUUNBRVFSZDJRZjhCY1NJQ1JRMEFJQUpCOEFCTkJFQWdBVUdBZ0lBRWNrSHhBQ0FDYTNZaEFRd0JDeUFDUVkwQlN3UkFRWUQ0QVNFRFFRQWhBUXdCQ3lBQ1FRcDBRWUNBQjJzaEF3c2dBeUFFUVJCMlFZQ0FBbkZ5SUFGQkRYWnlRZi8vQTNFTEJBQWdBQXZYSndFTWZ5TUFRUkJySWdva0FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUJCOUFGTkJFQkJ2Qm9vQWdBaUJFRVFJQUJCQzJwQitBTnhJQUJCQzBrYklnWkJBM1lpQUhZaUFVRURjUVJBQWtBZ0FVRi9jMEVCY1NBQWFpSUNRUU4wSWdGQjVCcHFJZ0FnQVVIc0dtb29BZ0FpQVNnQ0NDSUZSZ1JBUWJ3YUlBUkJmaUFDZDNFMkFnQU1BUXNnQlNBQU5nSU1JQUFnQlRZQ0NBc2dBVUVJYWlFQUlBRWdBa0VEZENJQ1FRTnlOZ0lFSUFFZ0Ftb2lBU0FCS0FJRVFRRnlOZ0lFREFzTElBWkJ4Qm9vQWdBaUNFME5BU0FCQkVBQ1FFRUNJQUIwSWdKQkFDQUNhM0lnQVNBQWRIRm9JZ0ZCQTNRaUFFSGtHbW9pQWlBQVFld2FhaWdDQUNJQUtBSUlJZ1ZHQkVCQnZCb2dCRUYrSUFGM2NTSUVOZ0lBREFFTElBVWdBallDRENBQ0lBVTJBZ2dMSUFBZ0JrRURjallDQkNBQUlBWnFJZ2NnQVVFRGRDSUJJQVpySWdWQkFYSTJBZ1FnQUNBQmFpQUZOZ0lBSUFnRVFDQUlRWGh4UWVRYWFpRUJRZEFhS0FJQUlRSUNmeUFFUVFFZ0NFRURkblFpQTNGRkJFQkJ2Qm9nQXlBRWNqWUNBQ0FCREFFTElBRW9BZ2dMSVFNZ0FTQUNOZ0lJSUFNZ0FqWUNEQ0FDSUFFMkFnd2dBaUFETmdJSUN5QUFRUWhxSVFCQjBCb2dCellDQUVIRUdpQUZOZ0lBREFzTFFjQWFLQUlBSWd0RkRRRWdDMmhCQW5SQjdCeHFLQUlBSWdJb0FnUkJlSEVnQm1zaEF5QUNJUUVEUUFKQUlBRW9BaEFpQUVVRVFDQUJLQUlVSWdCRkRRRUxJQUFvQWdSQmVIRWdCbXNpQVNBRElBRWdBMGtpQVJzaEF5QUFJQUlnQVJzaEFpQUFJUUVNQVFzTElBSW9BaGdoQ1NBQ0lBSW9BZ3dpQUVjRVFFSE1HaWdDQUJvZ0FpZ0NDQ0lCSUFBMkFnd2dBQ0FCTmdJSURBb0xJQUlvQWhRaUFRUi9JQUpCRkdvRklBSW9BaEFpQVVVTkF5QUNRUkJxQ3lFRkEwQWdCU0VISUFFaUFFRVVhaUVGSUFBb0FoUWlBUTBBSUFCQkVHb2hCU0FBS0FJUUlnRU5BQXNnQjBFQU5nSUFEQWtMUVg4aEJpQUFRYjkvU3cwQUlBQkJDMm9pQUVGNGNTRUdRY0FhS0FJQUlnZEZEUUJCQUNBR2F5RURBa0FDUUFKQUFuOUJBQ0FHUVlBQ1NRMEFHa0VmSUFaQi8vLy9CMHNOQUJvZ0JrRW1JQUJCQ0habklnQnJka0VCY1NBQVFRRjBhMEUrYWdzaUNFRUNkRUhzSEdvb0FnQWlBVVVFUUVFQUlRQU1BUXRCQUNFQUlBWkJHU0FJUVFGMmEwRUFJQWhCSDBjYmRDRUNBMEFDUUNBQktBSUVRWGh4SUFacklnUWdBMDhOQUNBQklRVWdCQ0lERFFCQkFDRURJQUVoQUF3REN5QUFJQUVvQWhRaUJDQUVJQUVnQWtFZGRrRUVjV29vQWhBaUFVWWJJQUFnQkJzaEFDQUNRUUYwSVFJZ0FRMEFDd3NnQUNBRmNrVUVRRUVBSVFWQkFpQUlkQ0lBUVFBZ0FHdHlJQWR4SWdCRkRRTWdBR2hCQW5SQjdCeHFLQUlBSVFBTElBQkZEUUVMQTBBZ0FDZ0NCRUY0Y1NBR2F5SUNJQU5KSVFFZ0FpQURJQUViSVFNZ0FDQUZJQUViSVFVZ0FDZ0NFQ0lCQkg4Z0FRVWdBQ2dDRkFzaUFBMEFDd3NnQlVVTkFDQURRY1FhS0FJQUlBWnJUdzBBSUFVb0FoZ2hDQ0FGSUFVb0Fnd2lBRWNFUUVITUdpZ0NBQm9nQlNnQ0NDSUJJQUEyQWd3Z0FDQUJOZ0lJREFnTElBVW9BaFFpQVFSL0lBVkJGR29GSUFVb0FoQWlBVVVOQXlBRlFSQnFDeUVDQTBBZ0FpRUVJQUVpQUVFVWFpRUNJQUFvQWhRaUFRMEFJQUJCRUdvaEFpQUFLQUlRSWdFTkFBc2dCRUVBTmdJQURBY0xJQVpCeEJvb0FnQWlCVTBFUUVIUUdpZ0NBQ0VBQWtBZ0JTQUdheUlCUVJCUEJFQWdBQ0FHYWlJQ0lBRkJBWEkyQWdRZ0FDQUZhaUFCTmdJQUlBQWdCa0VEY2pZQ0JBd0JDeUFBSUFWQkEzSTJBZ1FnQUNBRmFpSUJJQUVvQWdSQkFYSTJBZ1JCQUNFQ1FRQWhBUXRCeEJvZ0FUWUNBRUhRR2lBQ05nSUFJQUJCQ0dvaEFBd0pDeUFHUWNnYUtBSUFJZ0pKQkVCQnlCb2dBaUFHYXlJQk5nSUFRZFFhUWRRYUtBSUFJZ0FnQm1vaUFqWUNBQ0FDSUFGQkFYSTJBZ1FnQUNBR1FRTnlOZ0lFSUFCQkNHb2hBQXdKQzBFQUlRQWdCa0V2YWlJREFuOUJsQjRvQWdBRVFFR2NIaWdDQUF3QkMwR2dIa0ovTndJQVFaZ2VRb0NnZ0lDQWdBUTNBZ0JCbEI0Z0NrRU1ha0Z3Y1VIWXF0V3FCWE0yQWdCQnFCNUJBRFlDQUVINEhVRUFOZ0lBUVlBZ0N5SUJhaUlFUVFBZ0FXc2lCM0VpQVNBR1RRMElRZlFkS0FJQUlnVUVRRUhzSFNnQ0FDSUlJQUZxSWdrZ0NFMGdCU0FKU1hJTkNRc0NRRUg0SFMwQUFFRUVjVVVFUUFKQUFrQUNRQUpBUWRRYUtBSUFJZ1VFUUVIOEhTRUFBMEFnQlNBQUtBSUFJZ2hQQkVBZ0NDQUFLQUlFYWlBRlN3MERDeUFBS0FJSUlnQU5BQXNMUVFBUUN5SUNRWDlHRFFNZ0FTRUVRWmdlS0FJQUlnQkJBV3NpQlNBQ2NRUkFJQUVnQW1zZ0FpQUZha0VBSUFCcmNXb2hCQXNnQkNBR1RRMERRZlFkS0FJQUlnQUVRRUhzSFNnQ0FDSUZJQVJxSWdjZ0JVMGdBQ0FIU1hJTkJBc2dCQkFMSWdBZ0FrY05BUXdGQ3lBRUlBSnJJQWR4SWdRUUN5SUNJQUFvQWdBZ0FDZ0NCR3BHRFFFZ0FpRUFDeUFBUVg5R0RRRWdCa0V3YWlBRVRRUkFJQUFoQWd3RUMwR2NIaWdDQUNJQ0lBTWdCR3RxUVFBZ0FtdHhJZ0lRQzBGL1JnMEJJQUlnQkdvaEJDQUFJUUlNQXdzZ0FrRi9SdzBDQzBINEhVSDRIU2dDQUVFRWNqWUNBQXNnQVJBTElnSkJmMFpCQUJBTElnQkJmMFp5SUFBZ0FrMXlEUVVnQUNBQ2F5SUVJQVpCS0dwTkRRVUxRZXdkUWV3ZEtBSUFJQVJxSWdBMkFnQkI4QjBvQWdBZ0FFa0VRRUh3SFNBQU5nSUFDd0pBUWRRYUtBSUFJZ01FUUVIOEhTRUFBMEFnQWlBQUtBSUFJZ0VnQUNnQ0JDSUZha1lOQWlBQUtBSUlJZ0FOQUFzTUJBdEJ6Qm9vQWdBaUFFRUFJQUFnQWswYlJRUkFRY3dhSUFJMkFnQUxRUUFoQUVHQUhpQUVOZ0lBUWZ3ZElBSTJBZ0JCM0JwQmZ6WUNBRUhnR2tHVUhpZ0NBRFlDQUVHSUhrRUFOZ0lBQTBBZ0FFRURkQ0lCUWV3YWFpQUJRZVFhYWlJRk5nSUFJQUZCOEJwcUlBVTJBZ0FnQUVFQmFpSUFRU0JIRFFBTFFjZ2FJQVJCS0dzaUFFRjRJQUpyUVFkeElnRnJJZ1UyQWdCQjFCb2dBU0FDYWlJQk5nSUFJQUVnQlVFQmNqWUNCQ0FBSUFKcVFTZzJBZ1JCMkJwQnBCNG9BZ0EyQWdBTUJBc2dBaUFEVFNBQklBTkxjZzBDSUFBb0FneEJDSEVOQWlBQUlBUWdCV28yQWdSQjFCb2dBMEY0SUFOclFRZHhJZ0JxSWdFMkFnQkJ5QnBCeUJvb0FnQWdCR29pQWlBQWF5SUFOZ0lBSUFFZ0FFRUJjallDQkNBQ0lBTnFRU2cyQWdSQjJCcEJwQjRvQWdBMkFnQU1Bd3RCQUNFQURBWUxRUUFoQUF3RUMwSE1HaWdDQUNBQ1N3UkFRY3dhSUFJMkFnQUxJQUlnQkdvaEFVSDhIU0VBQWtBRFFDQUJJQUFvQWdCSEJFQWdBQ2dDQ0NJQURRRU1BZ3NMSUFBdEFBeEJDSEZGRFFNTFFmd2RJUUFEUUFKQUlBTWdBQ2dDQUNJQlR3UkFJQUVnQUNnQ0JHb2lCU0FEU3cwQkN5QUFLQUlJSVFBTUFRc0xRY2dhSUFSQktHc2lBRUY0SUFKclFRZHhJZ0ZySWdjMkFnQkIxQm9nQVNBQ2FpSUJOZ0lBSUFFZ0IwRUJjallDQkNBQUlBSnFRU2cyQWdSQjJCcEJwQjRvQWdBMkFnQWdBeUFGUVNjZ0JXdEJCM0ZxUVM5cklnQWdBQ0FEUVJCcVNSc2lBVUViTmdJRUlBRkJoQjRwQWdBM0FoQWdBVUg4SFNrQ0FEY0NDRUdFSGlBQlFRaHFOZ0lBUVlBZUlBUTJBZ0JCL0IwZ0FqWUNBRUdJSGtFQU5nSUFJQUZCR0dvaEFBTkFJQUJCQnpZQ0JDQUFRUWhxSVF3Z0FFRUVhaUVBSUF3Z0JVa05BQXNnQVNBRFJnMEFJQUVnQVNnQ0JFRitjVFlDQkNBRElBRWdBMnNpQWtFQmNqWUNCQ0FCSUFJMkFnQUNmeUFDUWY4QlRRUkFJQUpCZUhGQjVCcHFJUUFDZjBHOEdpZ0NBQ0lCUVFFZ0FrRURkblFpQW5GRkJFQkJ2Qm9nQVNBQ2NqWUNBQ0FBREFFTElBQW9BZ2dMSVFFZ0FDQUROZ0lJSUFFZ0F6WUNERUVNSVFKQkNBd0JDMEVmSVFBZ0FrSC8vLzhIVFFSQUlBSkJKaUFDUVFoMlp5SUFhM1pCQVhFZ0FFRUJkR3RCUG1vaEFBc2dBeUFBTmdJY0lBTkNBRGNDRUNBQVFRSjBRZXdjYWlFQkFrQUNRRUhBR2lnQ0FDSUZRUUVnQUhRaUJIRkZCRUJCd0JvZ0JDQUZjallDQUNBQklBTTJBZ0FNQVFzZ0FrRVpJQUJCQVhaclFRQWdBRUVmUnh0MElRQWdBU2dDQUNFRkEwQWdCU0lCS0FJRVFYaHhJQUpHRFFJZ0FFRWRkaUVGSUFCQkFYUWhBQ0FCSUFWQkJIRnFJZ1FvQWhBaUJRMEFDeUFFSUFNMkFoQUxJQU1nQVRZQ0dFRUlJUUlnQXlJQklRQkJEQXdCQ3lBQktBSUlJZ0FnQXpZQ0RDQUJJQU0yQWdnZ0F5QUFOZ0lJUVFBaEFFRVlJUUpCREFzZ0Eyb2dBVFlDQUNBQ0lBTnFJQUEyQWdBTFFjZ2FLQUlBSWdBZ0JrME5BRUhJR2lBQUlBWnJJZ0UyQWdCQjFCcEIxQm9vQWdBaUFDQUdhaUlDTmdJQUlBSWdBVUVCY2pZQ0JDQUFJQVpCQTNJMkFnUWdBRUVJYWlFQURBUUxRYmdhUVRBMkFnQkJBQ0VBREFNTElBQWdBallDQUNBQUlBQW9BZ1FnQkdvMkFnUWdBa0Y0SUFKclFRZHhhaUlJSUFaQkEzSTJBZ1FnQVVGNElBRnJRUWR4YWlJRUlBWWdDR29pQTJzaEJ3SkFRZFFhS0FJQUlBUkdCRUJCMUJvZ0F6WUNBRUhJR2tISUdpZ0NBQ0FIYWlJQU5nSUFJQU1nQUVFQmNqWUNCQXdCQzBIUUdpZ0NBQ0FFUmdSQVFkQWFJQU0yQWdCQnhCcEJ4Qm9vQWdBZ0Iyb2lBRFlDQUNBRElBQkJBWEkyQWdRZ0FDQURhaUFBTmdJQURBRUxJQVFvQWdRaUFFRURjVUVCUmdSQUlBQkJlSEVoQ1NBRUtBSU1JUUlDUUNBQVFmOEJUUVJBSUFRb0FnZ2lBU0FDUmdSQVFid2FRYndhS0FJQVFYNGdBRUVEZG5keE5nSUFEQUlMSUFFZ0FqWUNEQ0FDSUFFMkFnZ01BUXNnQkNnQ0dDRUdBa0FnQWlBRVJ3UkFRY3dhS0FJQUdpQUVLQUlJSWdBZ0FqWUNEQ0FDSUFBMkFnZ01BUXNDUUNBRUtBSVVJZ0FFZnlBRVFSUnFCU0FFS0FJUUlnQkZEUUVnQkVFUWFnc2hBUU5BSUFFaEJTQUFJZ0pCRkdvaEFTQUFLQUlVSWdBTkFDQUNRUkJxSVFFZ0FpZ0NFQ0lBRFFBTElBVkJBRFlDQUF3QkMwRUFJUUlMSUFaRkRRQUNRQ0FFS0FJY0lnQkJBblJCN0J4cUlnRW9BZ0FnQkVZRVFDQUJJQUkyQWdBZ0FnMEJRY0FhUWNBYUtBSUFRWDRnQUhkeE5nSUFEQUlMSUFaQkVFRVVJQVlvQWhBZ0JFWWJhaUFDTmdJQUlBSkZEUUVMSUFJZ0JqWUNHQ0FFS0FJUUlnQUVRQ0FDSUFBMkFoQWdBQ0FDTmdJWUN5QUVLQUlVSWdCRkRRQWdBaUFBTmdJVUlBQWdBallDR0FzZ0J5QUphaUVISUFRZ0NXb2lCQ2dDQkNFQUN5QUVJQUJCZm5FMkFnUWdBeUFIUVFGeU5nSUVJQU1nQjJvZ0J6WUNBQ0FIUWY4QlRRUkFJQWRCZUhGQjVCcHFJUUFDZjBHOEdpZ0NBQ0lCUVFFZ0IwRURkblFpQW5GRkJFQkJ2Qm9nQVNBQ2NqWUNBQ0FBREFFTElBQW9BZ2dMSVFFZ0FDQUROZ0lJSUFFZ0F6WUNEQ0FESUFBMkFnd2dBeUFCTmdJSURBRUxRUjhoQWlBSFFmLy8vd2ROQkVBZ0IwRW1JQWRCQ0habklnQnJka0VCY1NBQVFRRjBhMEUrYWlFQ0N5QURJQUkyQWh3Z0EwSUFOd0lRSUFKQkFuUkI3QnhxSVFBQ1FBSkFRY0FhS0FJQUlnRkJBU0FDZENJRmNVVUVRRUhBR2lBQklBVnlOZ0lBSUFBZ0F6WUNBQXdCQ3lBSFFSa2dBa0VCZG10QkFDQUNRUjlIRzNRaEFpQUFLQUlBSVFFRFFDQUJJZ0FvQWdSQmVIRWdCMFlOQWlBQ1FSMTJJUUVnQWtFQmRDRUNJQUFnQVVFRWNXb2lCU2dDRUNJQkRRQUxJQVVnQXpZQ0VBc2dBeUFBTmdJWUlBTWdBellDRENBRElBTTJBZ2dNQVFzZ0FDZ0NDQ0lCSUFNMkFnd2dBQ0FETmdJSUlBTkJBRFlDR0NBRElBQTJBZ3dnQXlBQk5nSUlDeUFJUVFocUlRQU1BZ3NDUUNBSVJRMEFBa0FnQlNnQ0hDSUJRUUowUWV3Y2FpSUNLQUlBSUFWR0JFQWdBaUFBTmdJQUlBQU5BVUhBR2lBSFFYNGdBWGR4SWdjMkFnQU1BZ3NnQ0VFUVFSUWdDQ2dDRUNBRlJodHFJQUEyQWdBZ0FFVU5BUXNnQUNBSU5nSVlJQVVvQWhBaUFRUkFJQUFnQVRZQ0VDQUJJQUEyQWhnTElBVW9BaFFpQVVVTkFDQUFJQUUyQWhRZ0FTQUFOZ0lZQ3dKQUlBTkJEMDBFUUNBRklBTWdCbW9pQUVFRGNqWUNCQ0FBSUFWcUlnQWdBQ2dDQkVFQmNqWUNCQXdCQ3lBRklBWkJBM0kyQWdRZ0JTQUdhaUlFSUFOQkFYSTJBZ1FnQXlBRWFpQUROZ0lBSUFOQi93Rk5CRUFnQTBGNGNVSGtHbW9oQUFKL1Fid2FLQUlBSWdGQkFTQURRUU4yZENJQ2NVVUVRRUc4R2lBQklBSnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaEFTQUFJQVEyQWdnZ0FTQUVOZ0lNSUFRZ0FEWUNEQ0FFSUFFMkFnZ01BUXRCSHlFQUlBTkIvLy8vQjAwRVFDQURRU1lnQTBFSWRtY2lBR3QyUVFGeElBQkJBWFJyUVQ1cUlRQUxJQVFnQURZQ0hDQUVRZ0EzQWhBZ0FFRUNkRUhzSEdvaEFRSkFBa0FnQjBFQklBQjBJZ0p4UlFSQVFjQWFJQUlnQjNJMkFnQWdBU0FFTmdJQUlBUWdBVFlDR0F3QkN5QURRUmtnQUVFQmRtdEJBQ0FBUVI5SEczUWhBQ0FCS0FJQUlRRURRQ0FCSWdJb0FnUkJlSEVnQTBZTkFpQUFRUjEySVFFZ0FFRUJkQ0VBSUFJZ0FVRUVjV29pQnlnQ0VDSUJEUUFMSUFjZ0JEWUNFQ0FFSUFJMkFoZ0xJQVFnQkRZQ0RDQUVJQVEyQWdnTUFRc2dBaWdDQ0NJQUlBUTJBZ3dnQWlBRU5nSUlJQVJCQURZQ0dDQUVJQUkyQWd3Z0JDQUFOZ0lJQ3lBRlFRaHFJUUFNQVFzQ1FDQUpSUTBBQWtBZ0FpZ0NIQ0lCUVFKMFFld2NhaUlGS0FJQUlBSkdCRUFnQlNBQU5nSUFJQUFOQVVIQUdpQUxRWDRnQVhkeE5nSUFEQUlMSUFsQkVFRVVJQWtvQWhBZ0FrWWJhaUFBTmdJQUlBQkZEUUVMSUFBZ0NUWUNHQ0FDS0FJUUlnRUVRQ0FBSUFFMkFoQWdBU0FBTmdJWUN5QUNLQUlVSWdGRkRRQWdBQ0FCTmdJVUlBRWdBRFlDR0FzQ1FDQURRUTlOQkVBZ0FpQURJQVpxSWdCQkEzSTJBZ1FnQUNBQ2FpSUFJQUFvQWdSQkFYSTJBZ1FNQVFzZ0FpQUdRUU55TmdJRUlBSWdCbW9pQlNBRFFRRnlOZ0lFSUFNZ0JXb2dBellDQUNBSUJFQWdDRUY0Y1VIa0dtb2hBRUhRR2lnQ0FDRUJBbjlCQVNBSVFRTjJkQ0lISUFSeFJRUkFRYndhSUFRZ0IzSTJBZ0FnQUF3QkN5QUFLQUlJQ3lFRUlBQWdBVFlDQ0NBRUlBRTJBZ3dnQVNBQU5nSU1JQUVnQkRZQ0NBdEIwQm9nQlRZQ0FFSEVHaUFETmdJQUN5QUNRUWhxSVFBTElBcEJFR29rQUNBQUM2a0xBZ3QvQ1gwakFFR2dBV3NpQ3lRQUlBdEJNR3BCSkJBUUEwQWdBU0FOUndSQUlBSWdEVUVEYkNJTVFRSnFRUUowSWc1cUtnSUFJUmNnQWlBTVFRRnFRUUowSWc5cUtnSUFJUmdnQ0NBTVFRSjBJaEJxSUFJZ0VHb3FBZ0FpR1RnQ0FDQUlJQTlxSUJnNEFnQWdDQ0FPYWlBWE9BSUFJQWNnRFVFRmRHb2lEQ0FZT0FJRUlBd2dHVGdDQUNBTUlCYzRBZ2dnREVFQU5nSU1Ba0FnQUVVRVFDQUdJQTFxTFFBQVJRMEJDeUFNUVlDQWdBZzJBZ3dMSUFjZ0RVRUZkR29pRVNBRklBMUJBblFpREVFQmNpSVNhaTBBQUVFSWRDQUZJQXhxTFFBQWNpQUZJQXhCQW5JaUUyb3RBQUJCRUhSeUlBVWdERUVEY2lJTWFpMEFBRUVZZEhJMkFod2dDeUFESUJKQkFuUWlFbW9xQWdBaUZ6Z0NrQUVnQ3lBRElCTkJBblFpRTJvcUFnQWlHRGdDbEFFZ0N5QURJQXhCQW5RaUZHb3FBZ0FpR1RnQ21BRWdDeUFESUExQkJIUWlGV29xQWdDTUlobzRBcHdCSUF0QjRBQnFJZ3dnQ3lvQ21BRWlGa01BQUFEQWxDQVdsQ0FMS2dLVUFTSVdRd0FBQU1DVUlCYVVRd0FBZ0QrU2tqZ0NBQ0FNSUFzcUFwQUJJaFlnRnBJZ0N5b0NsQUdVSUFzcUFwZ0JRd0FBQU1DVUlBc3FBcHdCbEpJNEFnUWdEQ0FMS2dLUUFTSVdJQmFTSUFzcUFwZ0JsQ0FMS2dLVUFTSVdJQmFTSUFzcUFwd0JsSkk0QWdnZ0RDQUxLZ0tRQVNJV0lCYVNJQXNxQXBRQmxDQUxLZ0tZQVNJV0lCYVNJQXNxQXB3QmxKSTRBZ3dnRENBTEtnS1lBU0lXUXdBQUFNQ1VJQmFVSUFzcUFwQUJJaFpEQUFBQXdKUWdGcFJEQUFDQVA1S1NPQUlRSUF3Z0N5b0NsQUVpRmlBV2tpQUxLZ0tZQVpRZ0N5b0NrQUZEQUFBQXdKUWdDeW9DbkFHVWtqZ0NGQ0FNSUFzcUFwQUJJaFlnRnBJZ0N5b0NtQUdVSUFzcUFwUUJRd0FBQU1DVUlBc3FBcHdCbEpJNEFoZ2dEQ0FMS2dLVUFTSVdJQmFTSUFzcUFwZ0JsQ0FMS2dLUUFTSVdJQmFTSUFzcUFwd0JsSkk0QWh3Z0RDQUxLZ0tVQVNJV1F3QUFBTUNVSUJhVUlBc3FBcEFCSWhaREFBQUF3SlFnRnBSREFBQ0FQNUtTT0FJZ0lBa2dGV29nRnpnQ0FDQUpJQkpxSUJnNEFnQWdDU0FUYWlBWk9BSUFJQWtnRkdvZ0dqZ0NBQ0FMSUFRZ0VHb3FBZ0FpRnpnQ01DQUxJQVFnRDJvcUFnQWlHRGdDUUNBTElBUWdEbW9xQWdBaUdUZ0NVQ0FLSUJCcUlCYzRBZ0FnQ2lBUGFpQVlPQUlBSUFvZ0Rtb2dHVGdDQUNBTElBd3FBaGdnQ3lvQ09KUWdEQ29DQUNBTEtnSXdsQ0FNS2dJTUlBc3FBalNVa3BJNEFnQWdDeUFNS2dJY0lBc3FBamlVSUF3cUFnUWdDeW9DTUpRZ0RDb0NFQ0FMS2dJMGxKS1NPQUlFSUFzZ0RDb0NJQ0FMS2dJNGxDQU1LZ0lJSUFzcUFqQ1VJQXdxQWhRZ0N5b0NOSlNTa2pnQ0NDQUxJQXdxQWhnZ0N5b0NSSlFnRENvQ0FDQUxLZ0k4bENBTUtnSU1JQXNxQWtDVWtwSTRBZ3dnQ3lBTUtnSWNJQXNxQWtTVUlBd3FBZ1FnQ3lvQ1BKUWdEQ29DRUNBTEtnSkFsSktTT0FJUUlBc2dEQ29DSUNBTEtnSkVsQ0FNS2dJSUlBc3FBanlVSUF3cUFoUWdDeW9DUUpTU2tqZ0NGQ0FMSUF3cUFoZ2dDeW9DVUpRZ0RDb0NBQ0FMS2dKSWxDQU1LZ0lNSUFzcUFreVVrcEk0QWhnZ0N5QU1LZ0ljSUFzcUFsQ1VJQXdxQWdRZ0N5b0NTSlFnRENvQ0VDQUxLZ0pNbEpLU09BSWNJQXNnRENvQ0lDQUxLZ0pRbENBTUtnSUlJQXNxQWtpVUlBd3FBaFFnQ3lvQ1RKU1NramdDSUNBTEtnSWdJUmNnQ3lvQ0NDRVlJQXNxQWhRaEdTQVJJQXNxQWhnaUdpQWFsQ0FMS2dJQUloWWdGcFFnQ3lvQ0RDSWJJQnVVa3BKREFBQ0FRSlFnR2lBTEtnSWNJaHlVSUJZZ0N5b0NCQ0lkbENBYklBc3FBaEFpSHBTU2trTUFBSUJBbEJBTU5nSVFJQkVnR2lBWGxDQVdJQmlVSUJzZ0daU1Nra01BQUlCQWxDQWNJQnlVSUIwZ0haUWdIaUFlbEpLU1F3QUFnRUNVRUF3MkFoUWdFU0FjSUJlVUlCMGdHSlFnSGlBWmxKS1NRd0FBZ0VDVUlCY2dGNVFnR0NBWWxDQVpJQm1Va3BKREFBQ0FRSlFRRERZQ0dDQU5RUUZxSVEwTUFRc0xJQXRCb0FGcUpBQUxHZ0FnQUNBQktBSUlJQVVRQ2dSQUlBRWdBaUFESUFRUUZBc0xOd0FnQUNBQktBSUlJQVVRQ2dSQUlBRWdBaUFESUFRUUZBOExJQUFvQWdnaUFDQUJJQUlnQXlBRUlBVWdBQ2dDQUNnQ0ZCRURBQXVSQVFBZ0FDQUJLQUlJSUFRUUNnUkFJQUVnQWlBREVCTVBDd0pBSUFBZ0FTZ0NBQ0FFRUFwRkRRQUNRQ0FDSUFFb0FoQkhCRUFnQVNnQ0ZDQUNSdzBCQ3lBRFFRRkhEUUVnQVVFQk5nSWdEd3NnQVNBQ05nSVVJQUVnQXpZQ0lDQUJJQUVvQWloQkFXbzJBaWdDUUNBQktBSWtRUUZIRFFBZ0FTZ0NHRUVDUncwQUlBRkJBVG9BTmdzZ0FVRUVOZ0lzQ3d2eUFRQWdBQ0FCS0FJSUlBUVFDZ1JBSUFFZ0FpQURFQk1QQ3dKQUlBQWdBU2dDQUNBRUVBb0VRQUpBSUFJZ0FTZ0NFRWNFUUNBQktBSVVJQUpIRFFFTElBTkJBVWNOQWlBQlFRRTJBaUFQQ3lBQklBTTJBaUFDUUNBQktBSXNRUVJHRFFBZ0FVRUFPd0UwSUFBb0FnZ2lBQ0FCSUFJZ0FrRUJJQVFnQUNnQ0FDZ0NGQkVEQUNBQkxRQTFCRUFnQVVFRE5nSXNJQUV0QURSRkRRRU1Bd3NnQVVFRU5nSXNDeUFCSUFJMkFoUWdBU0FCS0FJb1FRRnFOZ0lvSUFFb0FpUkJBVWNOQVNBQktBSVlRUUpIRFFFZ0FVRUJPZ0EyRHdzZ0FDZ0NDQ0lBSUFFZ0FpQURJQVFnQUNnQ0FDZ0NHQkVDQUFzTE1RQWdBQ0FCS0FJSVFRQVFDZ1JBSUFFZ0FpQURFQlVQQ3lBQUtBSUlJZ0FnQVNBQ0lBTWdBQ2dDQUNnQ0hCRUFBQXNZQUNBQUlBRW9BZ2hCQUJBS0JFQWdBU0FDSUFNUUZRc0xnQU1CQkg4akFFSHdBR3NpQWlRQUlBQW9BZ0FpQTBFRWF5Z0NBQ0VFSUFOQkNHc29BZ0FoQlNBQ1FnQTNBbEFnQWtJQU53SllJQUpDQURjQ1lDQUNRZ0EzQUdjZ0FrSUFOd0pJSUFKQkFEWUNSQ0FDUWV3Vk5nSkFJQUlnQURZQ1BDQUNJQUUyQWpnZ0FDQUZhaUVEQWtBZ0JDQUJRUUFRQ2dSQVFRQWdBeUFGR3lFQURBRUxJQUFnQTA0RVFDQUNRZ0EzQUM4Z0FrSUFOd0lZSUFKQ0FEY0NJQ0FDUWdBM0FpZ2dBa0lBTndJUUlBSkJBRFlDRENBQ0lBRTJBZ2dnQWlBQU5nSUVJQUlnQkRZQ0FDQUNRUUUyQWpBZ0JDQUNJQU1nQTBFQlFRQWdCQ2dDQUNnQ0ZCRURBQ0FDS0FJWURRRUxRUUFoQUNBRUlBSkJPR29nQTBFQlFRQWdCQ2dDQUNnQ0dCRUNBQUpBQWtBZ0FpZ0NYQTRDQUFFQ0N5QUNLQUpNUVFBZ0FpZ0NXRUVCUmh0QkFDQUNLQUpVUVFGR0cwRUFJQUlvQW1CQkFVWWJJUUFNQVFzZ0FpZ0NVRUVCUndSQUlBSW9BbUFOQVNBQ0tBSlVRUUZIRFFFZ0FpZ0NXRUVCUncwQkN5QUNLQUpJSVFBTElBSkI4QUJxSkFBZ0FBdVpBUUVDZnlNQVFVQnFJZ01rQUFKL1FRRWdBQ0FCUVFBUUNnMEFHa0VBSUFGRkRRQWFRUUFnQVVHY0ZoQWhJZ0ZGRFFBYUlBTkJER3BCTkJBUUlBTkJBVFlDT0NBRFFYODJBaFFnQXlBQU5nSVFJQU1nQVRZQ0NDQUJJQU5CQ0dvZ0FpZ0NBRUVCSUFFb0FnQW9BaHdSQUFBZ0F5Z0NJQ0lBUVFGR0JFQWdBaUFES0FJWU5nSUFDeUFBUVFGR0N5RUVJQU5CUUdza0FDQUVDd29BSUFBZ0FVRUFFQW9MQzdjU0FnQkJnQWdMcGhKMWJuTnBaMjVsWkNCemFHOXlkQUIxYm5OcFoyNWxaQ0JwYm5RQVpteHZZWFFBZFdsdWREWTBYM1FBZFc1emFXZHVaV1FnWTJoaGNnQmliMjlzQUhWdWMybG5ibVZrSUd4dmJtY0FjM1JrT2pwM2MzUnlhVzVuQUhOMFpEbzZjM1J5YVc1bkFITjBaRG82ZFRFMmMzUnlhVzVuQUhOMFpEbzZkVE15YzNSeWFXNW5BR1J2ZFdKc1pRQjJiMmxrQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQSE5vYjNKMFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4MWJuTnBaMjVsWkNCemFHOXlkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhhVzUwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkengxYm5OcFoyNWxaQ0JwYm5RK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEdac2IyRjBQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eDFhVzUwT0Y5MFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4cGJuUTRYM1ErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQSFZwYm5ReE5sOTBQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eHBiblF4Tmw5MFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4MWFXNTBOalJmZEQ0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4YVc1ME5qUmZkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhkV2x1ZERNeVgzUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BHbHVkRE15WDNRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEdOb1lYSStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BIVnVjMmxuYm1Wa0lHTm9ZWEkrQUhOMFpEbzZZbUZ6YVdOZmMzUnlhVzVuUEhWdWMybG5ibVZrSUdOb1lYSStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BITnBaMjVsWkNCamFHRnlQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eHNiMjVuUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkengxYm5OcFoyNWxaQ0JzYjI1blBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4a2IzVmliR1UrQUU1VGRETmZYekl4TW1KaGMybGpYM04wY21sdVowbGpUbE5mTVRGamFHRnlYM1J5WVdsMGMwbGpSVVZPVTE4NVlXeHNiMk5oZEc5eVNXTkZSVVZGQUFBQUFKUU1BQUF5QndBQVRsTjBNMTlmTWpFeVltRnphV05mYzNSeWFXNW5TV2hPVTE4eE1XTm9ZWEpmZEhKaGFYUnpTV2hGUlU1VFh6bGhiR3h2WTJGMGIzSkphRVZGUlVVQUFKUU1BQUI4QndBQVRsTjBNMTlmTWpFeVltRnphV05mYzNSeWFXNW5TWGRPVTE4eE1XTm9ZWEpmZEhKaGFYUnpTWGRGUlU1VFh6bGhiR3h2WTJGMGIzSkpkMFZGUlVVQUFKUU1BQURFQndBQVRsTjBNMTlmTWpFeVltRnphV05mYzNSeWFXNW5TVVJ6VGxOZk1URmphR0Z5WDNSeVlXbDBjMGxFYzBWRlRsTmZPV0ZzYkc5allYUnZja2xFYzBWRlJVVUFBQUNVREFBQURBZ0FBRTVUZEROZlh6SXhNbUpoYzJsalgzTjBjbWx1WjBsRWFVNVRYekV4WTJoaGNsOTBjbUZwZEhOSlJHbEZSVTVUWHpsaGJHeHZZMkYwYjNKSlJHbEZSVVZGQUFBQWxBd0FBRmdJQUFCT01UQmxiWE5qY21sd2RHVnVNM1poYkVVQUFKUU1BQUNrQ0FBQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSlkwVkZBQUNVREFBQXdBZ0FBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTV0ZGUlFBQWxBd0FBT2dJQUFCT01UQmxiWE5qY21sd2RHVnVNVEZ0WlcxdmNubGZkbWxsZDBsb1JVVUFBSlFNQUFBUUNRQUFUakV3WlcxelkzSnBjSFJsYmpFeGJXVnRiM0o1WDNacFpYZEpjMFZGQUFDVURBQUFPQWtBQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1hSRlJRQUFsQXdBQUdBSkFBQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbHBSVVVBQUpRTUFBQ0lDUUFBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKYWtWRkFBQ1VEQUFBc0FrQUFFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NXeEZSUUFBbEF3QUFOZ0pBQUJPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGx0UlVVQUFKUU1BQUFBQ2dBQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSmVFVkZBQUNVREFBQUtBb0FBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTWGxGUlFBQWxBd0FBRkFLQUFCT01UQmxiWE5qY21sd2RHVnVNVEZ0WlcxdmNubGZkbWxsZDBsbVJVVUFBSlFNQUFCNENnQUFUakV3WlcxelkzSnBjSFJsYmpFeGJXVnRiM0o1WDNacFpYZEpaRVZGQUFDVURBQUFvQW9BQUU0eE1GOWZZM2g0WVdKcGRqRXhObDlmYzJocGJWOTBlWEJsWDJsdVptOUZBQUFBQUx3TUFBRElDZ0FBSUEwQUFFNHhNRjlmWTNoNFlXSnBkakV4TjE5ZlkyeGhjM05mZEhsd1pWOXBibVp2UlFBQUFMd01BQUQ0Q2dBQTdBb0FBRTR4TUY5ZlkzaDRZV0pwZGpFeE4xOWZjR0poYzJWZmRIbHdaVjlwYm1adlJRQUFBTHdNQUFBb0N3QUE3QW9BQUU0eE1GOWZZM2g0WVdKcGRqRXhPVjlmY0c5cGJuUmxjbDkwZVhCbFgybHVabTlGQUx3TUFBQllDd0FBVEFzQUFBQUFBQURNQ3dBQUFnQUFBQU1BQUFBRUFBQUFCUUFBQUFZQUFBQk9NVEJmWDJONGVHRmlhWFl4TWpOZlgyWjFibVJoYldWdWRHRnNYM1I1Y0dWZmFXNW1iMFVBdkF3QUFLUUxBQURzQ2dBQWRnQUFBSkFMQUFEWUN3QUFZZ0FBQUpBTEFBRGtDd0FBWXdBQUFKQUxBQUR3Q3dBQWFBQUFBSkFMQUFEOEN3QUFZUUFBQUpBTEFBQUlEQUFBY3dBQUFKQUxBQUFVREFBQWRBQUFBSkFMQUFBZ0RBQUFhUUFBQUpBTEFBQXNEQUFBYWdBQUFKQUxBQUE0REFBQWJBQUFBSkFMQUFCRURBQUFiUUFBQUpBTEFBQlFEQUFBZUFBQUFKQUxBQUJjREFBQWVRQUFBSkFMQUFCb0RBQUFaZ0FBQUpBTEFBQjBEQUFBWkFBQUFKQUxBQUNBREFBQUFBQUFBQndMQUFBQ0FBQUFCd0FBQUFRQUFBQUZBQUFBQ0FBQUFBa0FBQUFLQUFBQUN3QUFBQUFBQUFBRURRQUFBZ0FBQUF3QUFBQUVBQUFBQlFBQUFBZ0FBQUFOQUFBQURnQUFBQThBQUFCT01UQmZYMk40ZUdGaWFYWXhNakJmWDNOcFgyTnNZWE56WDNSNWNHVmZhVzVtYjBVQUFBQUF2QXdBQU53TUFBQWNDd0FBVTNRNWRIbHdaVjlwYm1adkFBQUFBSlFNQUFBUURRQkJxQm9MQXpBUEFRPT0iO2lmKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKXt3YXNtQmluYXJ5RmlsZT1sb2NhdGVGaWxlKHdhc21CaW5hcnlGaWxlKTt9ZnVuY3Rpb24gZ2V0QmluYXJ5U3luYyhmaWxlKXtpZihmaWxlPT13YXNtQmluYXJ5RmlsZSYmd2FzbUJpbmFyeSl7cmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpfXZhciBiaW5hcnk9dHJ5UGFyc2VBc0RhdGFVUkkoZmlsZSk7aWYoYmluYXJ5KXtyZXR1cm4gYmluYXJ5fWlmKHJlYWRCaW5hcnkpe3JldHVybiByZWFkQmluYXJ5KGZpbGUpfXRocm93ICJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZCJ9ZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+Z2V0QmluYXJ5U3luYyhiaW5hcnlGaWxlKSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLGltcG9ydHMscmVjZWl2ZXIpe3JldHVybiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpLnRoZW4oYmluYXJ5PT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksaW1wb3J0cykpLnRoZW4ocmVjZWl2ZXIscmVhc29uPT57ZXJyKGBmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAke3JlYXNvbn1gKTthYm9ydChyZWFzb24pO30pfWZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoYmluYXJ5LGJpbmFyeUZpbGUsaW1wb3J0cyxjYWxsYmFjayl7cmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSxpbXBvcnRzLGNhbGxiYWNrKX1mdW5jdGlvbiBjcmVhdGVXYXNtKCl7dmFyIGluZm89eyJhIjp3YXNtSW1wb3J0c307ZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLG1vZHVsZSl7d2FzbUV4cG9ydHM9aW5zdGFuY2UuZXhwb3J0czt3YXNtTWVtb3J5PXdhc21FeHBvcnRzWyJrIl07dXBkYXRlTWVtb3J5Vmlld3MoKTthZGRPbkluaXQod2FzbUV4cG9ydHNbImwiXSk7cmVtb3ZlUnVuRGVwZW5kZW5jeSgpO3JldHVybiB3YXNtRXhwb3J0c31hZGRSdW5EZXBlbmRlbmN5KCk7ZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQocmVzdWx0KXtyZWNlaXZlSW5zdGFuY2UocmVzdWx0WyJpbnN0YW5jZSJdKTt9aWYoTW9kdWxlWyJpbnN0YW50aWF0ZVdhc20iXSl7dHJ5e3JldHVybiBNb2R1bGVbImluc3RhbnRpYXRlV2FzbSJdKGluZm8scmVjZWl2ZUluc3RhbmNlKX1jYXRjaChlKXtlcnIoYE1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6ICR7ZX1gKTtyZWFkeVByb21pc2VSZWplY3QoZSk7fX1pbnN0YW50aWF0ZUFzeW5jKHdhc21CaW5hcnksd2FzbUJpbmFyeUZpbGUsaW5mbyxyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCkuY2F0Y2gocmVhZHlQcm9taXNlUmVqZWN0KTtyZXR1cm4ge319dmFyIGNhbGxSdW50aW1lQ2FsbGJhY2tzPWNhbGxiYWNrcz0+e3doaWxlKGNhbGxiYWNrcy5sZW5ndGg+MCl7Y2FsbGJhY2tzLnNoaWZ0KCkoTW9kdWxlKTt9fTtNb2R1bGVbIm5vRXhpdFJ1bnRpbWUiXXx8dHJ1ZTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfYmlnaW50PShwcmltaXRpdmVUeXBlLG5hbWUsc2l6ZSxtaW5SYW5nZSxtYXhSYW5nZSk9Pnt9O3ZhciBlbWJpbmRfaW5pdF9jaGFyQ29kZXM9KCk9Pnt2YXIgY29kZXM9bmV3IEFycmF5KDI1Nik7Zm9yKHZhciBpPTA7aTwyNTY7KytpKXtjb2Rlc1tpXT1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpO31lbWJpbmRfY2hhckNvZGVzPWNvZGVzO307dmFyIGVtYmluZF9jaGFyQ29kZXM7dmFyIHJlYWRMYXRpbjFTdHJpbmc9cHRyPT57dmFyIHJldD0iIjt2YXIgYz1wdHI7d2hpbGUoSEVBUFU4W2NdKXtyZXQrPWVtYmluZF9jaGFyQ29kZXNbSEVBUFU4W2MrK11dO31yZXR1cm4gcmV0fTt2YXIgYXdhaXRpbmdEZXBlbmRlbmNpZXM9e307dmFyIHJlZ2lzdGVyZWRUeXBlcz17fTt2YXIgQmluZGluZ0Vycm9yO3ZhciB0aHJvd0JpbmRpbmdFcnJvcj1tZXNzYWdlPT57dGhyb3cgbmV3IEJpbmRpbmdFcnJvcihtZXNzYWdlKX07ZnVuY3Rpb24gc2hhcmVkUmVnaXN0ZXJUeXBlKHJhd1R5cGUscmVnaXN0ZXJlZEluc3RhbmNlLG9wdGlvbnM9e30pe3ZhciBuYW1lPXJlZ2lzdGVyZWRJbnN0YW5jZS5uYW1lO2lmKCFyYXdUeXBlKXt0aHJvd0JpbmRpbmdFcnJvcihgdHlwZSAiJHtuYW1lfSIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcmApO31pZihyZWdpc3RlcmVkVHlwZXMuaGFzT3duUHJvcGVydHkocmF3VHlwZSkpe2lmKG9wdGlvbnMuaWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9ucyl7cmV0dXJufWVsc2Uge3Rocm93QmluZGluZ0Vycm9yKGBDYW5ub3QgcmVnaXN0ZXIgdHlwZSAnJHtuYW1lfScgdHdpY2VgKTt9fXJlZ2lzdGVyZWRUeXBlc1tyYXdUeXBlXT1yZWdpc3RlcmVkSW5zdGFuY2U7aWYoYXdhaXRpbmdEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocmF3VHlwZSkpe3ZhciBjYWxsYmFja3M9YXdhaXRpbmdEZXBlbmRlbmNpZXNbcmF3VHlwZV07ZGVsZXRlIGF3YWl0aW5nRGVwZW5kZW5jaWVzW3Jhd1R5cGVdO2NhbGxiYWNrcy5mb3JFYWNoKGNiPT5jYigpKTt9fWZ1bmN0aW9uIHJlZ2lzdGVyVHlwZShyYXdUeXBlLHJlZ2lzdGVyZWRJbnN0YW5jZSxvcHRpb25zPXt9KXtpZighKCJhcmdQYWNrQWR2YW5jZSJpbiByZWdpc3RlcmVkSW5zdGFuY2UpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCJyZWdpc3RlclR5cGUgcmVnaXN0ZXJlZEluc3RhbmNlIHJlcXVpcmVzIGFyZ1BhY2tBZHZhbmNlIil9cmV0dXJuIHNoYXJlZFJlZ2lzdGVyVHlwZShyYXdUeXBlLHJlZ2lzdGVyZWRJbnN0YW5jZSxvcHRpb25zKX12YXIgR2VuZXJpY1dpcmVUeXBlU2l6ZT04O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9ib29sPShyYXdUeXBlLG5hbWUsdHJ1ZVZhbHVlLGZhbHNlVmFsdWUpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSI6ZnVuY3Rpb24od3Qpe3JldHVybiAhIXd0fSwidG9XaXJlVHlwZSI6ZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsbyl7cmV0dXJuIG8/dHJ1ZVZhbHVlOmZhbHNlVmFsdWV9LCJhcmdQYWNrQWR2YW5jZSI6R2VuZXJpY1dpcmVUeXBlU2l6ZSwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOmZ1bmN0aW9uKHBvaW50ZXIpe3JldHVybiB0aGlzWyJmcm9tV2lyZVR5cGUiXShIRUFQVThbcG9pbnRlcl0pfSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pO307dmFyIGVtdmFsX2ZyZWVsaXN0PVtdO3ZhciBlbXZhbF9oYW5kbGVzPVtdO3ZhciBfX2VtdmFsX2RlY3JlZj1oYW5kbGU9PntpZihoYW5kbGU+OSYmMD09PS0tZW12YWxfaGFuZGxlc1toYW5kbGUrMV0pe2VtdmFsX2hhbmRsZXNbaGFuZGxlXT11bmRlZmluZWQ7ZW12YWxfZnJlZWxpc3QucHVzaChoYW5kbGUpO319O3ZhciBjb3VudF9lbXZhbF9oYW5kbGVzPSgpPT5lbXZhbF9oYW5kbGVzLmxlbmd0aC8yLTUtZW12YWxfZnJlZWxpc3QubGVuZ3RoO3ZhciBpbml0X2VtdmFsPSgpPT57ZW12YWxfaGFuZGxlcy5wdXNoKDAsMSx1bmRlZmluZWQsMSxudWxsLDEsdHJ1ZSwxLGZhbHNlLDEpO01vZHVsZVsiY291bnRfZW12YWxfaGFuZGxlcyJdPWNvdW50X2VtdmFsX2hhbmRsZXM7fTt2YXIgRW12YWw9e3RvVmFsdWU6aGFuZGxlPT57aWYoIWhhbmRsZSl7dGhyb3dCaW5kaW5nRXJyb3IoIkNhbm5vdCB1c2UgZGVsZXRlZCB2YWwuIGhhbmRsZSA9ICIraGFuZGxlKTt9cmV0dXJuIGVtdmFsX2hhbmRsZXNbaGFuZGxlXX0sdG9IYW5kbGU6dmFsdWU9Pntzd2l0Y2godmFsdWUpe2Nhc2UgdW5kZWZpbmVkOnJldHVybiAyO2Nhc2UgbnVsbDpyZXR1cm4gNDtjYXNlIHRydWU6cmV0dXJuIDY7Y2FzZSBmYWxzZTpyZXR1cm4gODtkZWZhdWx0Ontjb25zdCBoYW5kbGU9ZW12YWxfZnJlZWxpc3QucG9wKCl8fGVtdmFsX2hhbmRsZXMubGVuZ3RoO2VtdmFsX2hhbmRsZXNbaGFuZGxlXT12YWx1ZTtlbXZhbF9oYW5kbGVzW2hhbmRsZSsxXT0xO3JldHVybiBoYW5kbGV9fX19O2Z1bmN0aW9uIHJlYWRQb2ludGVyKHBvaW50ZXIpe3JldHVybiB0aGlzWyJmcm9tV2lyZVR5cGUiXShIRUFQVTMyW3BvaW50ZXI+PjJdKX12YXIgRW1WYWxUeXBlPXtuYW1lOiJlbXNjcmlwdGVuOjp2YWwiLCJmcm9tV2lyZVR5cGUiOmhhbmRsZT0+e3ZhciBydj1FbXZhbC50b1ZhbHVlKGhhbmRsZSk7X19lbXZhbF9kZWNyZWYoaGFuZGxlKTtyZXR1cm4gcnZ9LCJ0b1dpcmVUeXBlIjooZGVzdHJ1Y3RvcnMsdmFsdWUpPT5FbXZhbC50b0hhbmRsZSh2YWx1ZSksImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6cmVhZFBvaW50ZXIsZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbD1yYXdUeXBlPT5yZWdpc3RlclR5cGUocmF3VHlwZSxFbVZhbFR5cGUpO3ZhciBmbG9hdFJlYWRWYWx1ZUZyb21Qb2ludGVyPShuYW1lLHdpZHRoKT0+e3N3aXRjaCh3aWR0aCl7Y2FzZSA0OnJldHVybiBmdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oSEVBUEYzMltwb2ludGVyPj4yXSl9O2Nhc2UgODpyZXR1cm4gZnVuY3Rpb24ocG9pbnRlcil7cmV0dXJuIHRoaXNbImZyb21XaXJlVHlwZSJdKEhFQVBGNjRbcG9pbnRlcj4+M10pfTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgZmxvYXQgd2lkdGggKCR7d2lkdGh9KTogJHtuYW1lfWApfX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0PShyYXdUeXBlLG5hbWUsc2l6ZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjp2YWx1ZT0+dmFsdWUsInRvV2lyZVR5cGUiOihkZXN0cnVjdG9ycyx2YWx1ZSk9PnZhbHVlLCJhcmdQYWNrQWR2YW5jZSI6R2VuZXJpY1dpcmVUeXBlU2l6ZSwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOmZsb2F0UmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSxzaXplKSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pO307dmFyIGludGVnZXJSZWFkVmFsdWVGcm9tUG9pbnRlcj0obmFtZSx3aWR0aCxzaWduZWQpPT57c3dpdGNoKHdpZHRoKXtjYXNlIDE6cmV0dXJuIHNpZ25lZD9wb2ludGVyPT5IRUFQOFtwb2ludGVyXTpwb2ludGVyPT5IRUFQVThbcG9pbnRlcl07Y2FzZSAyOnJldHVybiBzaWduZWQ/cG9pbnRlcj0+SEVBUDE2W3BvaW50ZXI+PjFdOnBvaW50ZXI9PkhFQVBVMTZbcG9pbnRlcj4+MV07Y2FzZSA0OnJldHVybiBzaWduZWQ/cG9pbnRlcj0+SEVBUDMyW3BvaW50ZXI+PjJdOnBvaW50ZXI9PkhFQVBVMzJbcG9pbnRlcj4+Ml07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVnZXIgd2lkdGggKCR7d2lkdGh9KTogJHtuYW1lfWApfX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXI9KHByaW1pdGl2ZVR5cGUsbmFtZSxzaXplLG1pblJhbmdlLG1heFJhbmdlKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTt2YXIgZnJvbVdpcmVUeXBlPXZhbHVlPT52YWx1ZTtpZihtaW5SYW5nZT09PTApe3ZhciBiaXRzaGlmdD0zMi04KnNpemU7ZnJvbVdpcmVUeXBlPXZhbHVlPT52YWx1ZTw8Yml0c2hpZnQ+Pj5iaXRzaGlmdDt9dmFyIGlzVW5zaWduZWRUeXBlPW5hbWUuaW5jbHVkZXMoInVuc2lnbmVkIik7dmFyIGNoZWNrQXNzZXJ0aW9ucz0odmFsdWUsdG9UeXBlTmFtZSk9Pnt9O3ZhciB0b1dpcmVUeXBlO2lmKGlzVW5zaWduZWRUeXBlKXt0b1dpcmVUeXBlPWZ1bmN0aW9uKGRlc3RydWN0b3JzLHZhbHVlKXtjaGVja0Fzc2VydGlvbnModmFsdWUsdGhpcy5uYW1lKTtyZXR1cm4gdmFsdWU+Pj4wfTt9ZWxzZSB7dG9XaXJlVHlwZT1mdW5jdGlvbihkZXN0cnVjdG9ycyx2YWx1ZSl7Y2hlY2tBc3NlcnRpb25zKHZhbHVlLHRoaXMubmFtZSk7cmV0dXJuIHZhbHVlfTt9cmVnaXN0ZXJUeXBlKHByaW1pdGl2ZVR5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjpmcm9tV2lyZVR5cGUsInRvV2lyZVR5cGUiOnRvV2lyZVR5cGUsImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6aW50ZWdlclJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsc2l6ZSxtaW5SYW5nZSE9PTApLGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSk7fTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXc9KHJhd1R5cGUsZGF0YVR5cGVJbmRleCxuYW1lKT0+e3ZhciB0eXBlTWFwcGluZz1bSW50OEFycmF5LFVpbnQ4QXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXldO3ZhciBUQT10eXBlTWFwcGluZ1tkYXRhVHlwZUluZGV4XTtmdW5jdGlvbiBkZWNvZGVNZW1vcnlWaWV3KGhhbmRsZSl7dmFyIHNpemU9SEVBUFUzMltoYW5kbGU+PjJdO3ZhciBkYXRhPUhFQVBVMzJbaGFuZGxlKzQ+PjJdO3JldHVybiBuZXcgVEEoSEVBUDguYnVmZmVyLGRhdGEsc2l6ZSl9bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSI6ZGVjb2RlTWVtb3J5VmlldywiYXJnUGFja0FkdmFuY2UiOkdlbmVyaWNXaXJlVHlwZVNpemUsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjpkZWNvZGVNZW1vcnlWaWV3fSx7aWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9uczp0cnVlfSk7fTt2YXIgc3RyaW5nVG9VVEY4QXJyYXk9KHN0cixoZWFwLG91dElkeCxtYXhCeXRlc1RvV3JpdGUpPT57aWYoIShtYXhCeXRlc1RvV3JpdGU+MCkpcmV0dXJuIDA7dmFyIHN0YXJ0SWR4PW91dElkeDt2YXIgZW5kSWR4PW91dElkeCttYXhCeXRlc1RvV3JpdGUtMTtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgdT1zdHIuY2hhckNvZGVBdChpKTtpZih1Pj01NTI5NiYmdTw9NTczNDMpe3ZhciB1MT1zdHIuY2hhckNvZGVBdCgrK2kpO3U9NjU1MzYrKCh1JjEwMjMpPDwxMCl8dTEmMTAyMzt9aWYodTw9MTI3KXtpZihvdXRJZHg+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT11O31lbHNlIGlmKHU8PTIwNDcpe2lmKG91dElkeCsxPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MTkyfHU+PjY7aGVhcFtvdXRJZHgrK109MTI4fHUmNjM7fWVsc2UgaWYodTw9NjU1MzUpe2lmKG91dElkeCsyPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MjI0fHU+PjEyO2hlYXBbb3V0SWR4KytdPTEyOHx1Pj42JjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzO31lbHNlIHtpZihvdXRJZHgrMz49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTI0MHx1Pj4xODtoZWFwW291dElkeCsrXT0xMjh8dT4+MTImNjM7aGVhcFtvdXRJZHgrK109MTI4fHU+PjYmNjM7aGVhcFtvdXRJZHgrK109MTI4fHUmNjM7fX1oZWFwW291dElkeF09MDtyZXR1cm4gb3V0SWR4LXN0YXJ0SWR4fTt2YXIgc3RyaW5nVG9VVEY4PShzdHIsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSk9PnN0cmluZ1RvVVRGOEFycmF5KHN0cixIRUFQVTgsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSk7dmFyIGxlbmd0aEJ5dGVzVVRGOD1zdHI9Pnt2YXIgbGVuPTA7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIGM9c3RyLmNoYXJDb2RlQXQoaSk7aWYoYzw9MTI3KXtsZW4rKzt9ZWxzZSBpZihjPD0yMDQ3KXtsZW4rPTI7fWVsc2UgaWYoYz49NTUyOTYmJmM8PTU3MzQzKXtsZW4rPTQ7KytpO31lbHNlIHtsZW4rPTM7fX1yZXR1cm4gbGVufTt2YXIgVVRGOERlY29kZXI9dHlwZW9mIFRleHREZWNvZGVyIT0idW5kZWZpbmVkIj9uZXcgVGV4dERlY29kZXIoInV0ZjgiKTp1bmRlZmluZWQ7dmFyIFVURjhBcnJheVRvU3RyaW5nPShoZWFwT3JBcnJheSxpZHgsbWF4Qnl0ZXNUb1JlYWQpPT57dmFyIGVuZElkeD1pZHgrbWF4Qnl0ZXNUb1JlYWQ7dmFyIGVuZFB0cj1pZHg7d2hpbGUoaGVhcE9yQXJyYXlbZW5kUHRyXSYmIShlbmRQdHI+PWVuZElkeCkpKytlbmRQdHI7aWYoZW5kUHRyLWlkeD4xNiYmaGVhcE9yQXJyYXkuYnVmZmVyJiZVVEY4RGVjb2Rlcil7cmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZShoZWFwT3JBcnJheS5zdWJhcnJheShpZHgsZW5kUHRyKSl9dmFyIHN0cj0iIjt3aGlsZShpZHg8ZW5kUHRyKXt2YXIgdTA9aGVhcE9yQXJyYXlbaWR4KytdO2lmKCEodTAmMTI4KSl7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtjb250aW51ZX12YXIgdTE9aGVhcE9yQXJyYXlbaWR4KytdJjYzO2lmKCh1MCYyMjQpPT0xOTIpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgodTAmMzEpPDw2fHUxKTtjb250aW51ZX12YXIgdTI9aGVhcE9yQXJyYXlbaWR4KytdJjYzO2lmKCh1MCYyNDApPT0yMjQpe3UwPSh1MCYxNSk8PDEyfHUxPDw2fHUyO31lbHNlIHt1MD0odTAmNyk8PDE4fHUxPDwxMnx1Mjw8NnxoZWFwT3JBcnJheVtpZHgrK10mNjM7fWlmKHUwPDY1NTM2KXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUodTApO31lbHNlIHt2YXIgY2g9dTAtNjU1MzY7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGNoPj4xMCw1NjMyMHxjaCYxMDIzKTt9fXJldHVybiBzdHJ9O3ZhciBVVEY4VG9TdHJpbmc9KHB0cixtYXhCeXRlc1RvUmVhZCk9PnB0cj9VVEY4QXJyYXlUb1N0cmluZyhIRUFQVTgscHRyLG1heEJ5dGVzVG9SZWFkKToiIjt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZz0ocmF3VHlwZSxuYW1lKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTt2YXIgc3RkU3RyaW5nSXNVVEY4PW5hbWU9PT0ic3RkOjpzdHJpbmciO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSIodmFsdWUpe3ZhciBsZW5ndGg9SEVBUFUzMlt2YWx1ZT4+Ml07dmFyIHBheWxvYWQ9dmFsdWUrNDt2YXIgc3RyO2lmKHN0ZFN0cmluZ0lzVVRGOCl7dmFyIGRlY29kZVN0YXJ0UHRyPXBheWxvYWQ7Zm9yKHZhciBpPTA7aTw9bGVuZ3RoOysraSl7dmFyIGN1cnJlbnRCeXRlUHRyPXBheWxvYWQraTtpZihpPT1sZW5ndGh8fEhFQVBVOFtjdXJyZW50Qnl0ZVB0cl09PTApe3ZhciBtYXhSZWFkPWN1cnJlbnRCeXRlUHRyLWRlY29kZVN0YXJ0UHRyO3ZhciBzdHJpbmdTZWdtZW50PVVURjhUb1N0cmluZyhkZWNvZGVTdGFydFB0cixtYXhSZWFkKTtpZihzdHI9PT11bmRlZmluZWQpe3N0cj1zdHJpbmdTZWdtZW50O31lbHNlIHtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoMCk7c3RyKz1zdHJpbmdTZWdtZW50O31kZWNvZGVTdGFydFB0cj1jdXJyZW50Qnl0ZVB0cisxO319fWVsc2Uge3ZhciBhPW5ldyBBcnJheShsZW5ndGgpO2Zvcih2YXIgaT0wO2k8bGVuZ3RoOysraSl7YVtpXT1TdHJpbmcuZnJvbUNoYXJDb2RlKEhFQVBVOFtwYXlsb2FkK2ldKTt9c3RyPWEuam9pbigiIik7fV9mcmVlKHZhbHVlKTtyZXR1cm4gc3RyfSwidG9XaXJlVHlwZSIoZGVzdHJ1Y3RvcnMsdmFsdWUpe2lmKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe3ZhbHVlPW5ldyBVaW50OEFycmF5KHZhbHVlKTt9dmFyIGxlbmd0aDt2YXIgdmFsdWVJc09mVHlwZVN0cmluZz10eXBlb2YgdmFsdWU9PSJzdHJpbmciO2lmKCEodmFsdWVJc09mVHlwZVN0cmluZ3x8dmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5fHx2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5fHx2YWx1ZSBpbnN0YW5jZW9mIEludDhBcnJheSkpe3Rocm93QmluZGluZ0Vycm9yKCJDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIHN0ZDo6c3RyaW5nIik7fWlmKHN0ZFN0cmluZ0lzVVRGOCYmdmFsdWVJc09mVHlwZVN0cmluZyl7bGVuZ3RoPWxlbmd0aEJ5dGVzVVRGOCh2YWx1ZSk7fWVsc2Uge2xlbmd0aD12YWx1ZS5sZW5ndGg7fXZhciBiYXNlPV9tYWxsb2MoNCtsZW5ndGgrMSk7dmFyIHB0cj1iYXNlKzQ7SEVBUFUzMltiYXNlPj4yXT1sZW5ndGg7aWYoc3RkU3RyaW5nSXNVVEY4JiZ2YWx1ZUlzT2ZUeXBlU3RyaW5nKXtzdHJpbmdUb1VURjgodmFsdWUscHRyLGxlbmd0aCsxKTt9ZWxzZSB7aWYodmFsdWVJc09mVHlwZVN0cmluZyl7Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXt2YXIgY2hhckNvZGU9dmFsdWUuY2hhckNvZGVBdChpKTtpZihjaGFyQ29kZT4yNTUpe19mcmVlKHB0cik7dGhyb3dCaW5kaW5nRXJyb3IoIlN0cmluZyBoYXMgVVRGLTE2IGNvZGUgdW5pdHMgdGhhdCBkbyBub3QgZml0IGluIDggYml0cyIpO31IRUFQVThbcHRyK2ldPWNoYXJDb2RlO319ZWxzZSB7Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXtIRUFQVThbcHRyK2ldPXZhbHVlW2ldO319fWlmKGRlc3RydWN0b3JzIT09bnVsbCl7ZGVzdHJ1Y3RvcnMucHVzaChfZnJlZSxiYXNlKTt9cmV0dXJuIGJhc2V9LCJhcmdQYWNrQWR2YW5jZSI6R2VuZXJpY1dpcmVUeXBlU2l6ZSwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOnJlYWRQb2ludGVyLGRlc3RydWN0b3JGdW5jdGlvbihwdHIpe19mcmVlKHB0cik7fX0pO307dmFyIFVURjE2RGVjb2Rlcj10eXBlb2YgVGV4dERlY29kZXIhPSJ1bmRlZmluZWQiP25ldyBUZXh0RGVjb2RlcigidXRmLTE2bGUiKTp1bmRlZmluZWQ7dmFyIFVURjE2VG9TdHJpbmc9KHB0cixtYXhCeXRlc1RvUmVhZCk9Pnt2YXIgZW5kUHRyPXB0cjt2YXIgaWR4PWVuZFB0cj4+MTt2YXIgbWF4SWR4PWlkeCttYXhCeXRlc1RvUmVhZC8yO3doaWxlKCEoaWR4Pj1tYXhJZHgpJiZIRUFQVTE2W2lkeF0pKytpZHg7ZW5kUHRyPWlkeDw8MTtpZihlbmRQdHItcHRyPjMyJiZVVEYxNkRlY29kZXIpcmV0dXJuIFVURjE2RGVjb2Rlci5kZWNvZGUoSEVBUFU4LnN1YmFycmF5KHB0cixlbmRQdHIpKTt2YXIgc3RyPSIiO2Zvcih2YXIgaT0wOyEoaT49bWF4Qnl0ZXNUb1JlYWQvMik7KytpKXt2YXIgY29kZVVuaXQ9SEVBUDE2W3B0citpKjI+PjFdO2lmKGNvZGVVbml0PT0wKWJyZWFrO3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZShjb2RlVW5pdCk7fXJldHVybiBzdHJ9O3ZhciBzdHJpbmdUb1VURjE2PShzdHIsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSk9PnttYXhCeXRlc1RvV3JpdGU/Pz0yMTQ3NDgzNjQ3O2lmKG1heEJ5dGVzVG9Xcml0ZTwyKXJldHVybiAwO21heEJ5dGVzVG9Xcml0ZS09Mjt2YXIgc3RhcnRQdHI9b3V0UHRyO3ZhciBudW1DaGFyc1RvV3JpdGU9bWF4Qnl0ZXNUb1dyaXRlPHN0ci5sZW5ndGgqMj9tYXhCeXRlc1RvV3JpdGUvMjpzdHIubGVuZ3RoO2Zvcih2YXIgaT0wO2k8bnVtQ2hhcnNUb1dyaXRlOysraSl7dmFyIGNvZGVVbml0PXN0ci5jaGFyQ29kZUF0KGkpO0hFQVAxNltvdXRQdHI+PjFdPWNvZGVVbml0O291dFB0cis9Mjt9SEVBUDE2W291dFB0cj4+MV09MDtyZXR1cm4gb3V0UHRyLXN0YXJ0UHRyfTt2YXIgbGVuZ3RoQnl0ZXNVVEYxNj1zdHI9PnN0ci5sZW5ndGgqMjt2YXIgVVRGMzJUb1N0cmluZz0ocHRyLG1heEJ5dGVzVG9SZWFkKT0+e3ZhciBpPTA7dmFyIHN0cj0iIjt3aGlsZSghKGk+PW1heEJ5dGVzVG9SZWFkLzQpKXt2YXIgdXRmMzI9SEVBUDMyW3B0citpKjQ+PjJdO2lmKHV0ZjMyPT0wKWJyZWFrOysraTtpZih1dGYzMj49NjU1MzYpe3ZhciBjaD11dGYzMi02NTUzNjtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Y2g+PjEwLDU2MzIwfGNoJjEwMjMpO31lbHNlIHtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUodXRmMzIpO319cmV0dXJuIHN0cn07dmFyIHN0cmluZ1RvVVRGMzI9KHN0cixvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKT0+e21heEJ5dGVzVG9Xcml0ZT8/PTIxNDc0ODM2NDc7aWYobWF4Qnl0ZXNUb1dyaXRlPDQpcmV0dXJuIDA7dmFyIHN0YXJ0UHRyPW91dFB0cjt2YXIgZW5kUHRyPXN0YXJ0UHRyK21heEJ5dGVzVG9Xcml0ZS00O2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciBjb2RlVW5pdD1zdHIuY2hhckNvZGVBdChpKTtpZihjb2RlVW5pdD49NTUyOTYmJmNvZGVVbml0PD01NzM0Myl7dmFyIHRyYWlsU3Vycm9nYXRlPXN0ci5jaGFyQ29kZUF0KCsraSk7Y29kZVVuaXQ9NjU1MzYrKChjb2RlVW5pdCYxMDIzKTw8MTApfHRyYWlsU3Vycm9nYXRlJjEwMjM7fUhFQVAzMltvdXRQdHI+PjJdPWNvZGVVbml0O291dFB0cis9NDtpZihvdXRQdHIrND5lbmRQdHIpYnJlYWt9SEVBUDMyW291dFB0cj4+Ml09MDtyZXR1cm4gb3V0UHRyLXN0YXJ0UHRyfTt2YXIgbGVuZ3RoQnl0ZXNVVEYzMj1zdHI9Pnt2YXIgbGVuPTA7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIGNvZGVVbml0PXN0ci5jaGFyQ29kZUF0KGkpO2lmKGNvZGVVbml0Pj01NTI5NiYmY29kZVVuaXQ8PTU3MzQzKSsraTtsZW4rPTQ7fXJldHVybiBsZW59O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZz0ocmF3VHlwZSxjaGFyU2l6ZSxuYW1lKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTt2YXIgZGVjb2RlU3RyaW5nLGVuY29kZVN0cmluZyxyZWFkQ2hhckF0LGxlbmd0aEJ5dGVzVVRGO2lmKGNoYXJTaXplPT09Mil7ZGVjb2RlU3RyaW5nPVVURjE2VG9TdHJpbmc7ZW5jb2RlU3RyaW5nPXN0cmluZ1RvVVRGMTY7bGVuZ3RoQnl0ZXNVVEY9bGVuZ3RoQnl0ZXNVVEYxNjtyZWFkQ2hhckF0PXBvaW50ZXI9PkhFQVBVMTZbcG9pbnRlcj4+MV07fWVsc2UgaWYoY2hhclNpemU9PT00KXtkZWNvZGVTdHJpbmc9VVRGMzJUb1N0cmluZztlbmNvZGVTdHJpbmc9c3RyaW5nVG9VVEYzMjtsZW5ndGhCeXRlc1VURj1sZW5ndGhCeXRlc1VURjMyO3JlYWRDaGFyQXQ9cG9pbnRlcj0+SEVBUFUzMltwb2ludGVyPj4yXTt9cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjp2YWx1ZT0+e3ZhciBsZW5ndGg9SEVBUFUzMlt2YWx1ZT4+Ml07dmFyIHN0cjt2YXIgZGVjb2RlU3RhcnRQdHI9dmFsdWUrNDtmb3IodmFyIGk9MDtpPD1sZW5ndGg7KytpKXt2YXIgY3VycmVudEJ5dGVQdHI9dmFsdWUrNCtpKmNoYXJTaXplO2lmKGk9PWxlbmd0aHx8cmVhZENoYXJBdChjdXJyZW50Qnl0ZVB0cik9PTApe3ZhciBtYXhSZWFkQnl0ZXM9Y3VycmVudEJ5dGVQdHItZGVjb2RlU3RhcnRQdHI7dmFyIHN0cmluZ1NlZ21lbnQ9ZGVjb2RlU3RyaW5nKGRlY29kZVN0YXJ0UHRyLG1heFJlYWRCeXRlcyk7aWYoc3RyPT09dW5kZWZpbmVkKXtzdHI9c3RyaW5nU2VnbWVudDt9ZWxzZSB7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApO3N0cis9c3RyaW5nU2VnbWVudDt9ZGVjb2RlU3RhcnRQdHI9Y3VycmVudEJ5dGVQdHIrY2hhclNpemU7fX1fZnJlZSh2YWx1ZSk7cmV0dXJuIHN0cn0sInRvV2lyZVR5cGUiOihkZXN0cnVjdG9ycyx2YWx1ZSk9PntpZighKHR5cGVvZiB2YWx1ZT09InN0cmluZyIpKXt0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgJHtuYW1lfWApO312YXIgbGVuZ3RoPWxlbmd0aEJ5dGVzVVRGKHZhbHVlKTt2YXIgcHRyPV9tYWxsb2MoNCtsZW5ndGgrY2hhclNpemUpO0hFQVBVMzJbcHRyPj4yXT1sZW5ndGgvY2hhclNpemU7ZW5jb2RlU3RyaW5nKHZhbHVlLHB0cis0LGxlbmd0aCtjaGFyU2l6ZSk7aWYoZGVzdHJ1Y3RvcnMhPT1udWxsKXtkZXN0cnVjdG9ycy5wdXNoKF9mcmVlLHB0cik7fXJldHVybiBwdHJ9LCJhcmdQYWNrQWR2YW5jZSI6R2VuZXJpY1dpcmVUeXBlU2l6ZSwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOnJlYWRQb2ludGVyLGRlc3RydWN0b3JGdW5jdGlvbihwdHIpe19mcmVlKHB0cik7fX0pO307dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX3ZvaWQ9KHJhd1R5cGUsbmFtZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse2lzVm9pZDp0cnVlLG5hbWU6bmFtZSwiYXJnUGFja0FkdmFuY2UiOjAsImZyb21XaXJlVHlwZSI6KCk9PnVuZGVmaW5lZCwidG9XaXJlVHlwZSI6KGRlc3RydWN0b3JzLG8pPT51bmRlZmluZWR9KTt9O3ZhciBnZXRIZWFwTWF4PSgpPT4yMTQ3NDgzNjQ4O3ZhciBncm93TWVtb3J5PXNpemU9Pnt2YXIgYj13YXNtTWVtb3J5LmJ1ZmZlcjt2YXIgcGFnZXM9KHNpemUtYi5ieXRlTGVuZ3RoKzY1NTM1KS82NTUzNjt0cnl7d2FzbU1lbW9yeS5ncm93KHBhZ2VzKTt1cGRhdGVNZW1vcnlWaWV3cygpO3JldHVybiAxfWNhdGNoKGUpe319O3ZhciBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcD1yZXF1ZXN0ZWRTaXplPT57dmFyIG9sZFNpemU9SEVBUFU4Lmxlbmd0aDtyZXF1ZXN0ZWRTaXplPj4+PTA7dmFyIG1heEhlYXBTaXplPWdldEhlYXBNYXgoKTtpZihyZXF1ZXN0ZWRTaXplPm1heEhlYXBTaXplKXtyZXR1cm4gZmFsc2V9dmFyIGFsaWduVXA9KHgsbXVsdGlwbGUpPT54KyhtdWx0aXBsZS14JW11bHRpcGxlKSVtdWx0aXBsZTtmb3IodmFyIGN1dERvd249MTtjdXREb3duPD00O2N1dERvd24qPTIpe3ZhciBvdmVyR3Jvd25IZWFwU2l6ZT1vbGRTaXplKigxKy4yL2N1dERvd24pO292ZXJHcm93bkhlYXBTaXplPU1hdGgubWluKG92ZXJHcm93bkhlYXBTaXplLHJlcXVlc3RlZFNpemUrMTAwNjYzMjk2KTt2YXIgbmV3U2l6ZT1NYXRoLm1pbihtYXhIZWFwU2l6ZSxhbGlnblVwKE1hdGgubWF4KHJlcXVlc3RlZFNpemUsb3Zlckdyb3duSGVhcFNpemUpLDY1NTM2KSk7dmFyIHJlcGxhY2VtZW50PWdyb3dNZW1vcnkobmV3U2l6ZSk7aWYocmVwbGFjZW1lbnQpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9O2VtYmluZF9pbml0X2NoYXJDb2RlcygpO0JpbmRpbmdFcnJvcj1Nb2R1bGVbIkJpbmRpbmdFcnJvciJdPWNsYXNzIEJpbmRpbmdFcnJvciBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKG1lc3NhZ2Upe3N1cGVyKG1lc3NhZ2UpO3RoaXMubmFtZT0iQmluZGluZ0Vycm9yIjt9fTtNb2R1bGVbIkludGVybmFsRXJyb3IiXT1jbGFzcyBJbnRlcm5hbEVycm9yIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IobWVzc2FnZSl7c3VwZXIobWVzc2FnZSk7dGhpcy5uYW1lPSJJbnRlcm5hbEVycm9yIjt9fTtpbml0X2VtdmFsKCk7dmFyIHdhc21JbXBvcnRzPXtmOl9fZW1iaW5kX3JlZ2lzdGVyX2JpZ2ludCxpOl9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2wsaDpfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbCxlOl9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0LGI6X19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcixhOl9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3LGQ6X19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZyxjOl9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nLGo6X19lbWJpbmRfcmVnaXN0ZXJfdm9pZCxnOl9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwfTt2YXIgd2FzbUV4cG9ydHM9Y3JlYXRlV2FzbSgpO01vZHVsZVsiX3BhY2siXT0oYTAsYTEsYTIsYTMsYTQsYTUsYTYsYTcsYTgsYTksYTEwKT0+KE1vZHVsZVsiX3BhY2siXT13YXNtRXhwb3J0c1sibSJdKShhMCxhMSxhMixhMyxhNCxhNSxhNixhNyxhOCxhOSxhMTApO3ZhciBfbWFsbG9jPU1vZHVsZVsiX21hbGxvYyJdPWEwPT4oX21hbGxvYz1Nb2R1bGVbIl9tYWxsb2MiXT13YXNtRXhwb3J0c1sibyJdKShhMCk7dmFyIF9mcmVlPU1vZHVsZVsiX2ZyZWUiXT1hMD0+KF9mcmVlPU1vZHVsZVsiX2ZyZWUiXT13YXNtRXhwb3J0c1sicCJdKShhMCk7dmFyIGNhbGxlZFJ1bjtkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9ZnVuY3Rpb24gcnVuQ2FsbGVyKCl7aWYoIWNhbGxlZFJ1bilydW4oKTtpZighY2FsbGVkUnVuKWRlcGVuZGVuY2llc0Z1bGZpbGxlZD1ydW5DYWxsZXI7fTtmdW5jdGlvbiBydW4oKXtpZihydW5EZXBlbmRlbmNpZXM+MCl7cmV0dXJufXByZVJ1bigpO2lmKHJ1bkRlcGVuZGVuY2llcz4wKXtyZXR1cm59ZnVuY3Rpb24gZG9SdW4oKXtpZihjYWxsZWRSdW4pcmV0dXJuO2NhbGxlZFJ1bj10cnVlO01vZHVsZVsiY2FsbGVkUnVuIl09dHJ1ZTtpZihBQk9SVClyZXR1cm47aW5pdFJ1bnRpbWUoKTtyZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7aWYoTW9kdWxlWyJvblJ1bnRpbWVJbml0aWFsaXplZCJdKU1vZHVsZVsib25SdW50aW1lSW5pdGlhbGl6ZWQiXSgpO3Bvc3RSdW4oKTt9aWYoTW9kdWxlWyJzZXRTdGF0dXMiXSl7TW9kdWxlWyJzZXRTdGF0dXMiXSgiUnVubmluZy4uLiIpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7TW9kdWxlWyJzZXRTdGF0dXMiXSgiIik7fSwxKTtkb1J1bigpO30sMSk7fWVsc2Uge2RvUnVuKCk7fX1pZihNb2R1bGVbInByZUluaXQiXSl7aWYodHlwZW9mIE1vZHVsZVsicHJlSW5pdCJdPT0iZnVuY3Rpb24iKU1vZHVsZVsicHJlSW5pdCJdPVtNb2R1bGVbInByZUluaXQiXV07d2hpbGUoTW9kdWxlWyJwcmVJbml0Il0ubGVuZ3RoPjApe01vZHVsZVsicHJlSW5pdCJdLnBvcCgpKCk7fX1ydW4oKTsKCgogICAgcmV0dXJuIG1vZHVsZUFyZy5yZWFkeQogIH0KICApOwogIH0pKCk7CgogIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55CiAgbGV0IHdhc21Nb2R1bGU7CiAgYXN5bmMgZnVuY3Rpb24gaW5pdFdhc20oKSB7CiAgICAgIHdhc21Nb2R1bGUgPSBhd2FpdCBsb2FkV2FzbSgpOwogIH0KICBsZXQgYWxsb2NhdGVkVmVydGV4Q291bnQgPSAwOwogIGNvbnN0IHVwZGF0ZVF1ZXVlID0gbmV3IEFycmF5KCk7CiAgbGV0IHJ1bm5pbmcgPSBmYWxzZTsKICBsZXQgbG9hZGluZyA9IGZhbHNlOwogIGxldCBwb3NpdGlvbnNQdHI7CiAgbGV0IHJvdGF0aW9uc1B0cjsKICBsZXQgc2NhbGVzUHRyOwogIGxldCBjb2xvcnNQdHI7CiAgbGV0IHNlbGVjdGlvblB0cjsKICBsZXQgZGF0YVB0cjsKICBsZXQgd29ybGRQb3NpdGlvbnNQdHI7CiAgbGV0IHdvcmxkUm90YXRpb25zUHRyOwogIGxldCB3b3JsZFNjYWxlc1B0cjsKICBjb25zdCBwYWNrID0gYXN5bmMgKHNwbGF0KSA9PiB7CiAgICAgIHdoaWxlIChsb2FkaW5nKSB7CiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7CiAgICAgIH0KICAgICAgaWYgKCF3YXNtTW9kdWxlKSB7CiAgICAgICAgICBsb2FkaW5nID0gdHJ1ZTsKICAgICAgICAgIGF3YWl0IGluaXRXYXNtKCk7CiAgICAgICAgICBsb2FkaW5nID0gZmFsc2U7CiAgICAgIH0KICAgICAgY29uc3QgdGFyZ2V0QWxsb2NhdGVkVmVydGV4Q291bnQgPSBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKHNwbGF0LnZlcnRleENvdW50KSkpOwogICAgICBpZiAodGFyZ2V0QWxsb2NhdGVkVmVydGV4Q291bnQgPiBhbGxvY2F0ZWRWZXJ0ZXhDb3VudCkgewogICAgICAgICAgaWYgKGFsbG9jYXRlZFZlcnRleENvdW50ID4gMCkgewogICAgICAgICAgICAgIHdhc21Nb2R1bGUuX2ZyZWUocG9zaXRpb25zUHRyKTsKICAgICAgICAgICAgICB3YXNtTW9kdWxlLl9mcmVlKHJvdGF0aW9uc1B0cik7CiAgICAgICAgICAgICAgd2FzbU1vZHVsZS5fZnJlZShzY2FsZXNQdHIpOwogICAgICAgICAgICAgIHdhc21Nb2R1bGUuX2ZyZWUoY29sb3JzUHRyKTsKICAgICAgICAgICAgICB3YXNtTW9kdWxlLl9mcmVlKHNlbGVjdGlvblB0cik7CiAgICAgICAgICAgICAgd2FzbU1vZHVsZS5fZnJlZShkYXRhUHRyKTsKICAgICAgICAgICAgICB3YXNtTW9kdWxlLl9mcmVlKHdvcmxkUG9zaXRpb25zUHRyKTsKICAgICAgICAgICAgICB3YXNtTW9kdWxlLl9mcmVlKHdvcmxkUm90YXRpb25zUHRyKTsKICAgICAgICAgICAgICB3YXNtTW9kdWxlLl9mcmVlKHdvcmxkU2NhbGVzUHRyKTsKICAgICAgICAgIH0KICAgICAgICAgIGFsbG9jYXRlZFZlcnRleENvdW50ID0gdGFyZ2V0QWxsb2NhdGVkVmVydGV4Q291bnQ7CiAgICAgICAgICBwb3NpdGlvbnNQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoMyAqIGFsbG9jYXRlZFZlcnRleENvdW50ICogNCk7CiAgICAgICAgICByb3RhdGlvbnNQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoNCAqIGFsbG9jYXRlZFZlcnRleENvdW50ICogNCk7CiAgICAgICAgICBzY2FsZXNQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoMyAqIGFsbG9jYXRlZFZlcnRleENvdW50ICogNCk7CiAgICAgICAgICBjb2xvcnNQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoNCAqIGFsbG9jYXRlZFZlcnRleENvdW50KTsKICAgICAgICAgIHNlbGVjdGlvblB0ciA9IHdhc21Nb2R1bGUuX21hbGxvYyhhbGxvY2F0ZWRWZXJ0ZXhDb3VudCk7CiAgICAgICAgICBkYXRhUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKDggKiBhbGxvY2F0ZWRWZXJ0ZXhDb3VudCAqIDQpOwogICAgICAgICAgd29ybGRQb3NpdGlvbnNQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoMyAqIGFsbG9jYXRlZFZlcnRleENvdW50ICogNCk7CiAgICAgICAgICB3b3JsZFJvdGF0aW9uc1B0ciA9IHdhc21Nb2R1bGUuX21hbGxvYyg0ICogYWxsb2NhdGVkVmVydGV4Q291bnQgKiA0KTsKICAgICAgICAgIHdvcmxkU2NhbGVzUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKDMgKiBhbGxvY2F0ZWRWZXJ0ZXhDb3VudCAqIDQpOwogICAgICB9CiAgICAgIHdhc21Nb2R1bGUuSEVBUEYzMi5zZXQoc3BsYXQucG9zaXRpb25zLCBwb3NpdGlvbnNQdHIgLyA0KTsKICAgICAgd2FzbU1vZHVsZS5IRUFQRjMyLnNldChzcGxhdC5yb3RhdGlvbnMsIHJvdGF0aW9uc1B0ciAvIDQpOwogICAgICB3YXNtTW9kdWxlLkhFQVBGMzIuc2V0KHNwbGF0LnNjYWxlcywgc2NhbGVzUHRyIC8gNCk7CiAgICAgIHdhc21Nb2R1bGUuSEVBUFU4LnNldChzcGxhdC5jb2xvcnMsIGNvbG9yc1B0cik7CiAgICAgIHdhc21Nb2R1bGUuSEVBUFU4LnNldChzcGxhdC5zZWxlY3Rpb24sIHNlbGVjdGlvblB0cik7CiAgICAgIHdhc21Nb2R1bGUuX3BhY2soc3BsYXQuc2VsZWN0ZWQsIHNwbGF0LnZlcnRleENvdW50LCBwb3NpdGlvbnNQdHIsIHJvdGF0aW9uc1B0ciwgc2NhbGVzUHRyLCBjb2xvcnNQdHIsIHNlbGVjdGlvblB0ciwgZGF0YVB0ciwgd29ybGRQb3NpdGlvbnNQdHIsIHdvcmxkUm90YXRpb25zUHRyLCB3b3JsZFNjYWxlc1B0cik7CiAgICAgIGNvbnN0IG91dERhdGEgPSBuZXcgVWludDMyQXJyYXkod2FzbU1vZHVsZS5IRUFQVTMyLmJ1ZmZlciwgZGF0YVB0ciwgc3BsYXQudmVydGV4Q291bnQgKiA4KTsKICAgICAgY29uc3QgZGV0YWNoZWREYXRhID0gbmV3IFVpbnQzMkFycmF5KG91dERhdGEuc2xpY2UoKS5idWZmZXIpOwogICAgICBjb25zdCB3b3JsZFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkod2FzbU1vZHVsZS5IRUFQRjMyLmJ1ZmZlciwgd29ybGRQb3NpdGlvbnNQdHIsIHNwbGF0LnZlcnRleENvdW50ICogMyk7CiAgICAgIGNvbnN0IGRldGFjaGVkV29ybGRQb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHdvcmxkUG9zaXRpb25zLnNsaWNlKCkuYnVmZmVyKTsKICAgICAgY29uc3Qgd29ybGRSb3RhdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHdhc21Nb2R1bGUuSEVBUEYzMi5idWZmZXIsIHdvcmxkUm90YXRpb25zUHRyLCBzcGxhdC52ZXJ0ZXhDb3VudCAqIDQpOwogICAgICBjb25zdCBkZXRhY2hlZFdvcmxkUm90YXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSh3b3JsZFJvdGF0aW9ucy5zbGljZSgpLmJ1ZmZlcik7CiAgICAgIGNvbnN0IHdvcmxkU2NhbGVzID0gbmV3IEZsb2F0MzJBcnJheSh3YXNtTW9kdWxlLkhFQVBGMzIuYnVmZmVyLCB3b3JsZFNjYWxlc1B0ciwgc3BsYXQudmVydGV4Q291bnQgKiAzKTsKICAgICAgY29uc3QgZGV0YWNoZWRXb3JsZFNjYWxlcyA9IG5ldyBGbG9hdDMyQXJyYXkod29ybGRTY2FsZXMuc2xpY2UoKS5idWZmZXIpOwogICAgICBjb25zdCByZXNwb25zZSA9IHsKICAgICAgICAgIGRhdGE6IGRldGFjaGVkRGF0YSwKICAgICAgICAgIHdvcmxkUG9zaXRpb25zOiBkZXRhY2hlZFdvcmxkUG9zaXRpb25zLAogICAgICAgICAgd29ybGRSb3RhdGlvbnM6IGRldGFjaGVkV29ybGRSb3RhdGlvbnMsCiAgICAgICAgICB3b3JsZFNjYWxlczogZGV0YWNoZWRXb3JsZFNjYWxlcywKICAgICAgICAgIG9mZnNldDogc3BsYXQub2Zmc2V0LAogICAgICAgICAgdmVydGV4Q291bnQ6IHNwbGF0LnZlcnRleENvdW50LAogICAgICAgICAgcG9zaXRpb25zOiBzcGxhdC5wb3NpdGlvbnMuYnVmZmVyLAogICAgICAgICAgcm90YXRpb25zOiBzcGxhdC5yb3RhdGlvbnMuYnVmZmVyLAogICAgICAgICAgc2NhbGVzOiBzcGxhdC5zY2FsZXMuYnVmZmVyLAogICAgICAgICAgY29sb3JzOiBzcGxhdC5jb2xvcnMuYnVmZmVyLAogICAgICAgICAgc2VsZWN0aW9uOiBzcGxhdC5zZWxlY3Rpb24uYnVmZmVyLAogICAgICB9OwogICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgcmVzcG9uc2U6IHJlc3BvbnNlIH0sIFsKICAgICAgICAgIHJlc3BvbnNlLmRhdGEuYnVmZmVyLAogICAgICAgICAgcmVzcG9uc2Uud29ybGRQb3NpdGlvbnMuYnVmZmVyLAogICAgICAgICAgcmVzcG9uc2Uud29ybGRSb3RhdGlvbnMuYnVmZmVyLAogICAgICAgICAgcmVzcG9uc2Uud29ybGRTY2FsZXMuYnVmZmVyLAogICAgICAgICAgcmVzcG9uc2UucG9zaXRpb25zLAogICAgICAgICAgcmVzcG9uc2Uucm90YXRpb25zLAogICAgICAgICAgcmVzcG9uc2Uuc2NhbGVzLAogICAgICAgICAgcmVzcG9uc2UuY29sb3JzLAogICAgICAgICAgcmVzcG9uc2Uuc2VsZWN0aW9uLAogICAgICBdKTsKICAgICAgcnVubmluZyA9IGZhbHNlOwogIH07CiAgY29uc3QgcGFja1Rocm90dGxlZCA9ICgpID0+IHsKICAgICAgaWYgKHVwZGF0ZVF1ZXVlLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybjsKICAgICAgaWYgKCFydW5uaW5nKSB7CiAgICAgICAgICBydW5uaW5nID0gdHJ1ZTsKICAgICAgICAgIGNvbnN0IHNwbGF0ID0gdXBkYXRlUXVldWUuc2hpZnQoKTsKICAgICAgICAgIHBhY2soc3BsYXQpOwogICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlOwogICAgICAgICAgICAgIHBhY2tUaHJvdHRsZWQoKTsKICAgICAgICAgIH0sIDApOwogICAgICB9CiAgfTsKICBzZWxmLm9ubWVzc2FnZSA9IChlKSA9PiB7CiAgICAgIGlmIChlLmRhdGEuc3BsYXQpIHsKICAgICAgICAgIGNvbnN0IHNwbGF0ID0gZS5kYXRhLnNwbGF0OwogICAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGV4aXN0aW5nXSBvZiB1cGRhdGVRdWV1ZS5lbnRyaWVzKCkpIHsKICAgICAgICAgICAgICBpZiAoZXhpc3Rpbmcub2Zmc2V0ID09PSBzcGxhdC5vZmZzZXQpIHsKICAgICAgICAgICAgICAgICAgdXBkYXRlUXVldWVbaW5kZXhdID0gc3BsYXQ7CiAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICB1cGRhdGVRdWV1ZS5wdXNoKHNwbGF0KTsKICAgICAgICAgIHBhY2tUaHJvdHRsZWQoKTsKICAgICAgfQogIH07Cgp9KSgpOwovLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhV29ya2VyLmpzLm1hcAoK", null, false);
var E = function(A2 = {}) {
  var Q2, F2, U2 = A2;
  U2.ready = new Promise((A3, U3) => {
    Q2 = A3, F2 = U3;
  });
  var B2, l2 = Object.assign({}, U2), t2 = "";
  t2 = (t2 = self.location.href).startsWith("blob:") ? "" : t2.substr(0, t2.replace(/[?#].*/, "").lastIndexOf("/") + 1), B2 = (A3) => {
    var Q3 = new XMLHttpRequest();
    return Q3.open("GET", A3, false), Q3.responseType = "arraybuffer", Q3.send(null), new Uint8Array(Q3.response);
  }, U2.print || console.log.bind(console);
  var d2, n2, V2 = U2.printErr || console.error.bind(console);
  function Z2(A3) {
    if (y2(A3))
      return function(A4) {
        for (var Q3 = atob(A4), F3 = new Uint8Array(Q3.length), U3 = 0; U3 < Q3.length; ++U3)
          F3[U3] = Q3.charCodeAt(U3);
        return F3;
      }(A3.slice(G2.length));
  }
  Object.assign(U2, l2), l2 = null, U2.arguments && U2.arguments, U2.thisProgram && U2.thisProgram, U2.quit && U2.quit, U2.wasmBinary && (d2 = U2.wasmBinary), "object" != typeof WebAssembly && b2("no native wasm support detected");
  var I2, e2, R2, a2, g2, i2, c2, C2, W2 = false;
  function h2() {
    var A3 = n2.buffer;
    U2.HEAP8 = I2 = new Int8Array(A3), U2.HEAP16 = R2 = new Int16Array(A3), U2.HEAPU8 = e2 = new Uint8Array(A3), U2.HEAPU16 = a2 = new Uint16Array(A3), U2.HEAP32 = g2 = new Int32Array(A3), U2.HEAPU32 = i2 = new Uint32Array(A3), U2.HEAPF32 = c2 = new Float32Array(A3), U2.HEAPF64 = C2 = new Float64Array(A3);
  }
  var s2 = [], o2 = [], J2 = [], r2 = 0, E2 = null;
  function b2(A3) {
    var _a;
    (_a = U2.onAbort) == null ? void 0 : _a.call(U2, A3), V2(A3 = "Aborted(" + A3 + ")"), W2 = true, A3 += ". Build with -sASSERTIONS for more info.";
    var Q3 = new WebAssembly.RuntimeError(A3);
    throw F2(Q3), Q3;
  }
  var m2, N2, G2 = "data:application/octet-stream;base64,", y2 = (A3) => A3.startsWith(G2);
  function S2(A3) {
    return Promise.resolve().then(() => function(A4) {
      if (A4 == m2 && d2)
        return new Uint8Array(d2);
      var Q3 = Z2(A4);
      if (Q3)
        return Q3;
      if (B2)
        return B2(A4);
      throw "both async and sync fetching of the wasm failed";
    }(A3));
  }
  function X2(A3, Q3, F3, U3) {
    return function(A4, Q4, F4) {
      return S2(A4).then((A5) => WebAssembly.instantiate(A5, Q4)).then(F4, (A5) => {
        V2(`failed to asynchronously prepare wasm: ${A5}`), b2(A5);
      });
    }(Q3, F3, U3);
  }
  y2(m2 = "data:application/octet-stream;base64,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eV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAAAAAJQMAAAyBwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAAJQMAAB8BwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAAJQMAADEBwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAACUDAAADAgAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAAlAwAAFgIAABOMTBlbXNjcmlwdGVuM3ZhbEUAAJQMAACkCAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAACUDAAAwAgAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAAlAwAAOgIAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAAJQMAAAQCQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAACUDAAAOAkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQAAlAwAAGAJAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUAAJQMAACICQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAACUDAAAsAkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQAAlAwAANgJAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUAAJQMAAAACgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJeEVFAACUDAAAKAoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXlFRQAAlAwAAFAKAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lmRUUAAJQMAAB4CgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAACUDAAAoAoAAE4xMF9fY3h4YWJpdjExNl9fc2hpbV90eXBlX2luZm9FAAAAALwMAADICgAAIA0AAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQAAALwMAAD4CgAA7AoAAE4xMF9fY3h4YWJpdjExN19fcGJhc2VfdHlwZV9pbmZvRQAAALwMAAAoCwAA7AoAAE4xMF9fY3h4YWJpdjExOV9fcG9pbnRlcl90eXBlX2luZm9FALwMAABYCwAATAsAAAAAAADMCwAAAgAAAAMAAAAEAAAABQAAAAYAAABOMTBfX2N4eGFiaXYxMjNfX2Z1bmRhbWVudGFsX3R5cGVfaW5mb0UAvAwAAKQLAADsCgAAdgAAAJALAADYCwAAYgAAAJALAADkCwAAYwAAAJALAADwCwAAaAAAAJALAAD8CwAAYQAAAJALAAAIDAAAcwAAAJALAAAUDAAAdAAAAJALAAAgDAAAaQAAAJALAAAsDAAAagAAAJALAAA4DAAAbAAAAJALAABEDAAAbQAAAJALAABQDAAAeAAAAJALAABcDAAAeQAAAJALAABoDAAAZgAAAJALAAB0DAAAZAAAAJALAACADAAAAAAAABwLAAACAAAABwAAAAQAAAAFAAAACAAAAAkAAAAKAAAACwAAAAAAAAAEDQAAAgAAAAwAAAAEAAAABQAAAAgAAAANAAAADgAAAA8AAABOMTBfX2N4eGFiaXYxMjBfX3NpX2NsYXNzX3R5cGVfaW5mb0UAAAAAvAwAANwMAAAcCwAAU3Q5dHlwZV9pbmZvAAAAAJQMAAAQDQBBqBoLAzAPAQ==") || (N2 = m2, m2 = U2.locateFile ? U2.locateFile(N2, t2) : t2 + N2);
  var Y2 = (A3) => {
    for (; A3.length > 0; )
      A3.shift()(U2);
  };
  U2.noExitRuntime;
  var p2, k2, u = (A3) => {
    for (var Q3 = "", F3 = A3; e2[F3]; )
      Q3 += p2[e2[F3++]];
    return Q3;
  }, T = {}, H = {}, D = (A3) => {
    throw new k2(A3);
  };
  function w(A3, Q3, F3 = {}) {
    if (!("argPackAdvance" in Q3))
      throw new TypeError("registerType registeredInstance requires argPackAdvance");
    return function(A4, Q4, F4 = {}) {
      var U3 = Q4.name;
      if (A4 || D(`type "${U3}" must have a positive integer typeid pointer`), H.hasOwnProperty(A4)) {
        if (F4.ignoreDuplicateRegistrations)
          return;
        D(`Cannot register type '${U3}' twice`);
      }
      if (H[A4] = Q4, T.hasOwnProperty(A4)) {
        var B3 = T[A4];
        delete T[A4], B3.forEach((A5) => A5());
      }
    }(A3, Q3, F3);
  }
  var x = [], f = [], M = () => f.length / 2 - 5 - x.length, v = (A3) => (A3 || D("Cannot use deleted val. handle = " + A3), f[A3]), z = (A3) => {
    switch (A3) {
      case void 0:
        return 2;
      case null:
        return 4;
      case true:
        return 6;
      case false:
        return 8;
      default: {
        const Q3 = x.pop() || f.length;
        return f[Q3] = A3, f[Q3 + 1] = 1, Q3;
      }
    }
  };
  function K(A3) {
    return this.fromWireType(i2[A3 >> 2]);
  }
  var j = { name: "emscripten::val", fromWireType: (A3) => {
    var Q3 = v(A3);
    return ((A4) => {
      A4 > 9 && 0 == --f[A4 + 1] && (f[A4] = void 0, x.push(A4));
    })(A3), Q3;
  }, toWireType: (A3, Q3) => z(Q3), argPackAdvance: 8, readValueFromPointer: K, destructorFunction: null }, O = (A3, Q3) => {
    switch (Q3) {
      case 4:
        return function(A4) {
          return this.fromWireType(c2[A4 >> 2]);
        };
      case 8:
        return function(A4) {
          return this.fromWireType(C2[A4 >> 3]);
        };
      default:
        throw new TypeError(`invalid float width (${Q3}): ${A3}`);
    }
  }, L = (A3, Q3, F3) => {
    switch (Q3) {
      case 1:
        return F3 ? (A4) => I2[A4] : (A4) => e2[A4];
      case 2:
        return F3 ? (A4) => R2[A4 >> 1] : (A4) => a2[A4 >> 1];
      case 4:
        return F3 ? (A4) => g2[A4 >> 2] : (A4) => i2[A4 >> 2];
      default:
        throw new TypeError(`invalid integer width (${Q3}): ${A3}`);
    }
  }, P = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, _ = (A3, Q3) => A3 ? ((A4, Q4, F3) => {
    for (var U3 = Q4 + F3, B3 = Q4; A4[B3] && !(B3 >= U3); )
      ++B3;
    if (B3 - Q4 > 16 && A4.buffer && P)
      return P.decode(A4.subarray(Q4, B3));
    for (var l3 = ""; Q4 < B3; ) {
      var t3 = A4[Q4++];
      if (128 & t3) {
        var d3 = 63 & A4[Q4++];
        if (192 != (224 & t3)) {
          var n3 = 63 & A4[Q4++];
          if ((t3 = 224 == (240 & t3) ? (15 & t3) << 12 | d3 << 6 | n3 : (7 & t3) << 18 | d3 << 12 | n3 << 6 | 63 & A4[Q4++]) < 65536)
            l3 += String.fromCharCode(t3);
          else {
            var V3 = t3 - 65536;
            l3 += String.fromCharCode(55296 | V3 >> 10, 56320 | 1023 & V3);
          }
        } else
          l3 += String.fromCharCode((31 & t3) << 6 | d3);
      } else
        l3 += String.fromCharCode(t3);
    }
    return l3;
  })(e2, A3, Q3) : "", q = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0, $ = (A3, Q3) => {
    for (var F3 = A3, U3 = F3 >> 1, B3 = U3 + Q3 / 2; !(U3 >= B3) && a2[U3]; )
      ++U3;
    if ((F3 = U3 << 1) - A3 > 32 && q)
      return q.decode(e2.subarray(A3, F3));
    for (var l3 = "", t3 = 0; !(t3 >= Q3 / 2); ++t3) {
      var d3 = R2[A3 + 2 * t3 >> 1];
      if (0 == d3)
        break;
      l3 += String.fromCharCode(d3);
    }
    return l3;
  }, AA = (A3, Q3, F3) => {
    if (F3 ?? (F3 = 2147483647), F3 < 2)
      return 0;
    for (var U3 = Q3, B3 = (F3 -= 2) < 2 * A3.length ? F3 / 2 : A3.length, l3 = 0; l3 < B3; ++l3) {
      var t3 = A3.charCodeAt(l3);
      R2[Q3 >> 1] = t3, Q3 += 2;
    }
    return R2[Q3 >> 1] = 0, Q3 - U3;
  }, QA = (A3) => 2 * A3.length, FA = (A3, Q3) => {
    for (var F3 = 0, U3 = ""; !(F3 >= Q3 / 4); ) {
      var B3 = g2[A3 + 4 * F3 >> 2];
      if (0 == B3)
        break;
      if (++F3, B3 >= 65536) {
        var l3 = B3 - 65536;
        U3 += String.fromCharCode(55296 | l3 >> 10, 56320 | 1023 & l3);
      } else
        U3 += String.fromCharCode(B3);
    }
    return U3;
  }, UA = (A3, Q3, F3) => {
    if (F3 ?? (F3 = 2147483647), F3 < 4)
      return 0;
    for (var U3 = Q3, B3 = U3 + F3 - 4, l3 = 0; l3 < A3.length; ++l3) {
      var t3 = A3.charCodeAt(l3);
      if (t3 >= 55296 && t3 <= 57343 && (t3 = 65536 + ((1023 & t3) << 10) | 1023 & A3.charCodeAt(++l3)), g2[Q3 >> 2] = t3, (Q3 += 4) + 4 > B3)
        break;
    }
    return g2[Q3 >> 2] = 0, Q3 - U3;
  }, BA = (A3) => {
    for (var Q3 = 0, F3 = 0; F3 < A3.length; ++F3) {
      var U3 = A3.charCodeAt(F3);
      U3 >= 55296 && U3 <= 57343 && ++F3, Q3 += 4;
    }
    return Q3;
  }, lA = (A3) => {
    var Q3 = (A3 - n2.buffer.byteLength + 65535) / 65536;
    try {
      return n2.grow(Q3), h2(), 1;
    } catch (A4) {
    }
  };
  (() => {
    for (var A3 = new Array(256), Q3 = 0; Q3 < 256; ++Q3)
      A3[Q3] = String.fromCharCode(Q3);
    p2 = A3;
  })(), k2 = U2.BindingError = class extends Error {
    constructor(A3) {
      super(A3), this.name = "BindingError";
    }
  }, U2.InternalError = class extends Error {
    constructor(A3) {
      super(A3), this.name = "InternalError";
    }
  }, f.push(0, 1, void 0, 1, null, 1, true, 1, false, 1), U2.count_emval_handles = M;
  var tA = { f: (A3, Q3, F3, U3, B3) => {
  }, i: (A3, Q3, F3, U3) => {
    w(A3, { name: Q3 = u(Q3), fromWireType: function(A4) {
      return !!A4;
    }, toWireType: function(A4, Q4) {
      return Q4 ? F3 : U3;
    }, argPackAdvance: 8, readValueFromPointer: function(A4) {
      return this.fromWireType(e2[A4]);
    }, destructorFunction: null });
  }, h: (A3) => w(A3, j), e: (A3, Q3, F3) => {
    w(A3, { name: Q3 = u(Q3), fromWireType: (A4) => A4, toWireType: (A4, Q4) => Q4, argPackAdvance: 8, readValueFromPointer: O(Q3, F3), destructorFunction: null });
  }, b: (A3, Q3, F3, U3, B3) => {
    Q3 = u(Q3);
    var l3 = (A4) => A4;
    if (0 === U3) {
      var t3 = 32 - 8 * F3;
      l3 = (A4) => A4 << t3 >>> t3;
    }
    var d3 = Q3.includes("unsigned");
    w(A3, { name: Q3, fromWireType: l3, toWireType: d3 ? function(A4, Q4) {
      return this.name, Q4 >>> 0;
    } : function(A4, Q4) {
      return this.name, Q4;
    }, argPackAdvance: 8, readValueFromPointer: L(Q3, F3, 0 !== U3), destructorFunction: null });
  }, a: (A3, Q3, F3) => {
    var U3 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][Q3];
    function B3(A4) {
      var Q4 = i2[A4 >> 2], F4 = i2[A4 + 4 >> 2];
      return new U3(I2.buffer, F4, Q4);
    }
    w(A3, { name: F3 = u(F3), fromWireType: B3, argPackAdvance: 8, readValueFromPointer: B3 }, { ignoreDuplicateRegistrations: true });
  }, d: (A3, Q3) => {
    var F3 = "std::string" === (Q3 = u(Q3));
    w(A3, { name: Q3, fromWireType(A4) {
      var Q4, U3 = i2[A4 >> 2], B3 = A4 + 4;
      if (F3)
        for (var l3 = B3, t3 = 0; t3 <= U3; ++t3) {
          var d3 = B3 + t3;
          if (t3 == U3 || 0 == e2[d3]) {
            var n3 = _(l3, d3 - l3);
            void 0 === Q4 ? Q4 = n3 : (Q4 += String.fromCharCode(0), Q4 += n3), l3 = d3 + 1;
          }
        }
      else {
        var V3 = new Array(U3);
        for (t3 = 0; t3 < U3; ++t3)
          V3[t3] = String.fromCharCode(e2[B3 + t3]);
        Q4 = V3.join("");
      }
      return ZA(A4), Q4;
    }, toWireType(A4, Q4) {
      var U3;
      Q4 instanceof ArrayBuffer && (Q4 = new Uint8Array(Q4));
      var B3 = "string" == typeof Q4;
      B3 || Q4 instanceof Uint8Array || Q4 instanceof Uint8ClampedArray || Q4 instanceof Int8Array || D("Cannot pass non-string to std::string"), U3 = F3 && B3 ? ((A5) => {
        for (var Q5 = 0, F4 = 0; F4 < A5.length; ++F4) {
          var U4 = A5.charCodeAt(F4);
          U4 <= 127 ? Q5++ : U4 <= 2047 ? Q5 += 2 : U4 >= 55296 && U4 <= 57343 ? (Q5 += 4, ++F4) : Q5 += 3;
        }
        return Q5;
      })(Q4) : Q4.length;
      var l3 = VA(4 + U3 + 1), t3 = l3 + 4;
      if (i2[l3 >> 2] = U3, F3 && B3)
        ((A5, Q5, F4, U4) => {
          if (!(U4 > 0))
            return 0;
          for (var B4 = F4 + U4 - 1, l4 = 0; l4 < A5.length; ++l4) {
            var t4 = A5.charCodeAt(l4);
            if (t4 >= 55296 && t4 <= 57343 && (t4 = 65536 + ((1023 & t4) << 10) | 1023 & A5.charCodeAt(++l4)), t4 <= 127) {
              if (F4 >= B4)
                break;
              Q5[F4++] = t4;
            } else if (t4 <= 2047) {
              if (F4 + 1 >= B4)
                break;
              Q5[F4++] = 192 | t4 >> 6, Q5[F4++] = 128 | 63 & t4;
            } else if (t4 <= 65535) {
              if (F4 + 2 >= B4)
                break;
              Q5[F4++] = 224 | t4 >> 12, Q5[F4++] = 128 | t4 >> 6 & 63, Q5[F4++] = 128 | 63 & t4;
            } else {
              if (F4 + 3 >= B4)
                break;
              Q5[F4++] = 240 | t4 >> 18, Q5[F4++] = 128 | t4 >> 12 & 63, Q5[F4++] = 128 | t4 >> 6 & 63, Q5[F4++] = 128 | 63 & t4;
            }
          }
          Q5[F4] = 0;
        })(Q4, e2, t3, U3 + 1);
      else if (B3)
        for (var d3 = 0; d3 < U3; ++d3) {
          var n3 = Q4.charCodeAt(d3);
          n3 > 255 && (ZA(t3), D("String has UTF-16 code units that do not fit in 8 bits")), e2[t3 + d3] = n3;
        }
      else
        for (d3 = 0; d3 < U3; ++d3)
          e2[t3 + d3] = Q4[d3];
      return null !== A4 && A4.push(ZA, l3), l3;
    }, argPackAdvance: 8, readValueFromPointer: K, destructorFunction(A4) {
      ZA(A4);
    } });
  }, c: (A3, Q3, F3) => {
    var U3, B3, l3, t3;
    F3 = u(F3), 2 === Q3 ? (U3 = $, B3 = AA, t3 = QA, l3 = (A4) => a2[A4 >> 1]) : 4 === Q3 && (U3 = FA, B3 = UA, t3 = BA, l3 = (A4) => i2[A4 >> 2]), w(A3, { name: F3, fromWireType: (A4) => {
      for (var F4, B4 = i2[A4 >> 2], t4 = A4 + 4, d3 = 0; d3 <= B4; ++d3) {
        var n3 = A4 + 4 + d3 * Q3;
        if (d3 == B4 || 0 == l3(n3)) {
          var V3 = U3(t4, n3 - t4);
          void 0 === F4 ? F4 = V3 : (F4 += String.fromCharCode(0), F4 += V3), t4 = n3 + Q3;
        }
      }
      return ZA(A4), F4;
    }, toWireType: (A4, U4) => {
      "string" != typeof U4 && D(`Cannot pass non-string to C++ string type ${F3}`);
      var l4 = t3(U4), d3 = VA(4 + l4 + Q3);
      return i2[d3 >> 2] = l4 / Q3, B3(U4, d3 + 4, l4 + Q3), null !== A4 && A4.push(ZA, d3), d3;
    }, argPackAdvance: 8, readValueFromPointer: K, destructorFunction(A4) {
      ZA(A4);
    } });
  }, j: (A3, Q3) => {
    w(A3, { isVoid: true, name: Q3 = u(Q3), argPackAdvance: 0, fromWireType: () => {
    }, toWireType: (A4, Q4) => {
    } });
  }, g: (A3) => {
    var Q3 = e2.length, F3 = 2147483648;
    if ((A3 >>>= 0) > F3)
      return false;
    for (var U3, B3, l3 = 1; l3 <= 4; l3 *= 2) {
      var t3 = Q3 * (1 + 0.2 / l3);
      t3 = Math.min(t3, A3 + 100663296);
      var d3 = Math.min(F3, (U3 = Math.max(A3, t3)) + ((B3 = 65536) - U3 % B3) % B3);
      if (lA(d3))
        return true;
    }
    return false;
  } }, dA = function() {
    var _a;
    var A3 = { a: tA };
    function Q3(A4, Q4) {
      var F3;
      return dA = A4.exports, n2 = dA.k, h2(), F3 = dA.l, o2.unshift(F3), function(A5) {
        var _a2;
        if (r2--, (_a2 = U2.monitorRunDependencies) == null ? void 0 : _a2.call(U2, r2), 0 == r2 && E2) {
          var Q5 = E2;
          E2 = null, Q5();
        }
      }(), dA;
    }
    if (r2++, (_a = U2.monitorRunDependencies) == null ? void 0 : _a.call(U2, r2), U2.instantiateWasm)
      try {
        return U2.instantiateWasm(A3, Q3);
      } catch (A4) {
        V2(`Module.instantiateWasm callback failed with error: ${A4}`), F2(A4);
      }
    return X2(0, m2, A3, function(A4) {
      Q3(A4.instance);
    }).catch(F2), {};
  }();
  U2._pack = (A3, Q3, F3, B3, l3, t3, d3, n3, V3, Z3, I3) => (U2._pack = dA.m)(A3, Q3, F3, B3, l3, t3, d3, n3, V3, Z3, I3);
  var nA, VA = U2._malloc = (A3) => (VA = U2._malloc = dA.o)(A3), ZA = U2._free = (A3) => (ZA = U2._free = dA.p)(A3);
  function IA() {
    function A3() {
      nA || (nA = true, U2.calledRun = true, W2 || (Y2(o2), Q2(U2), U2.onRuntimeInitialized && U2.onRuntimeInitialized(), function() {
        if (U2.postRun)
          for ("function" == typeof U2.postRun && (U2.postRun = [U2.postRun]); U2.postRun.length; )
            A4 = U2.postRun.shift(), J2.unshift(A4);
        var A4;
        Y2(J2);
      }()));
    }
    r2 > 0 || (function() {
      if (U2.preRun)
        for ("function" == typeof U2.preRun && (U2.preRun = [U2.preRun]); U2.preRun.length; )
          A4 = U2.preRun.shift(), s2.unshift(A4);
      var A4;
      Y2(s2);
    }(), r2 > 0 || (U2.setStatus ? (U2.setStatus("Running..."), setTimeout(function() {
      setTimeout(function() {
        U2.setStatus("");
      }, 1), A3();
    }, 1)) : A3()));
  }
  if (E2 = function A3() {
    nA || IA(), nA || (E2 = A3);
  }, U2.preInit)
    for ("function" == typeof U2.preInit && (U2.preInit = [U2.preInit]); U2.preInit.length > 0; )
      U2.preInit.pop()();
  return IA(), A2.ready;
};
var b = class {
  constructor(A2) {
    this.dataChanged = false, this.transformsChanged = false, this._updating = /* @__PURE__ */ new Set(), this._dirty = /* @__PURE__ */ new Set();
    let Q2 = 0, F2 = 0;
    this._splatIndices = /* @__PURE__ */ new Map(), this._offsets = /* @__PURE__ */ new Map();
    const U2 = /* @__PURE__ */ new Map();
    for (const B3 of A2.objects)
      B3 instanceof I && (this._splatIndices.set(B3, F2), this._offsets.set(B3, Q2), U2.set(Q2, B3), Q2 += B3.data.vertexCount, F2++);
    this._vertexCount = Q2, this._width = 2048, this._height = Math.ceil(2 * this.vertexCount / this.width), this._data = new Uint32Array(this.width * this.height * 4), this._transformsWidth = 5, this._transformsHeight = U2.size, this._transforms = new Float32Array(this._transformsWidth * this._transformsHeight * 4), this._transformIndicesWidth = 1024, this._transformIndicesHeight = Math.ceil(this.vertexCount / this._transformIndicesWidth), this._transformIndices = new Uint32Array(this._transformIndicesWidth * this._transformIndicesHeight), this._positions = new Float32Array(3 * this.vertexCount), this._rotations = new Float32Array(4 * this.vertexCount), this._scales = new Float32Array(3 * this.vertexCount), this._worker = new r();
    const B2 = (A3) => {
      const Q3 = this._splatIndices.get(A3);
      this._transforms.set(A3.transform.buffer, 20 * Q3), this._transforms[20 * Q3 + 16] = A3.selected ? 1 : 0, A3.positionChanged = false, A3.rotationChanged = false, A3.scaleChanged = false, A3.selectedChanged = false, this.transformsChanged = true;
    };
    let l2;
    this._worker.onmessage = (A3) => {
      if (A3.data.response) {
        const Q3 = A3.data.response, F3 = U2.get(Q3.offset);
        B2(F3);
        const l3 = this._splatIndices.get(F3);
        for (let A4 = 0; A4 < F3.data.vertexCount; A4++)
          this._transformIndices[Q3.offset + A4] = l3;
        this._data.set(Q3.data, 8 * Q3.offset), F3.data.reattach(Q3.positions, Q3.rotations, Q3.scales, Q3.colors, Q3.selection), this._positions.set(Q3.worldPositions, 3 * Q3.offset), this._rotations.set(Q3.worldRotations, 4 * Q3.offset), this._scales.set(Q3.worldScales, 3 * Q3.offset), this._updating.delete(F3), F3.selectedChanged = false, this.dataChanged = true;
      }
    }, async function() {
      l2 = await E();
    }();
    const t2 = (A3) => {
      if (!l2)
        return void async function() {
          for (; !l2; )
            await new Promise((A4) => setTimeout(A4, 0));
        }().then(() => {
          t2(A3);
        });
      B2(A3);
      const Q3 = l2._malloc(3 * A3.data.vertexCount * 4), F3 = l2._malloc(4 * A3.data.vertexCount * 4), U3 = l2._malloc(3 * A3.data.vertexCount * 4), d3 = l2._malloc(4 * A3.data.vertexCount), n2 = l2._malloc(A3.data.vertexCount), V2 = l2._malloc(8 * A3.data.vertexCount * 4), Z2 = l2._malloc(3 * A3.data.vertexCount * 4), I2 = l2._malloc(4 * A3.data.vertexCount * 4), e2 = l2._malloc(3 * A3.data.vertexCount * 4);
      l2.HEAPF32.set(A3.data.positions, Q3 / 4), l2.HEAPF32.set(A3.data.rotations, F3 / 4), l2.HEAPF32.set(A3.data.scales, U3 / 4), l2.HEAPU8.set(A3.data.colors, d3), l2.HEAPU8.set(A3.data.selection, n2), l2._pack(A3.selected, A3.data.vertexCount, Q3, F3, U3, d3, n2, V2, Z2, I2, e2);
      const R2 = new Uint32Array(l2.HEAPU32.buffer, V2, 8 * A3.data.vertexCount), a2 = new Float32Array(l2.HEAPF32.buffer, Z2, 3 * A3.data.vertexCount), g2 = new Float32Array(l2.HEAPF32.buffer, I2, 4 * A3.data.vertexCount), i2 = new Float32Array(l2.HEAPF32.buffer, e2, 3 * A3.data.vertexCount), c2 = this._splatIndices.get(A3), C2 = this._offsets.get(A3);
      for (let Q4 = 0; Q4 < A3.data.vertexCount; Q4++)
        this._transformIndices[C2 + Q4] = c2;
      this._data.set(R2, 8 * C2), this._positions.set(a2, 3 * C2), this._rotations.set(g2, 4 * C2), this._scales.set(i2, 3 * C2), l2._free(Q3), l2._free(F3), l2._free(U3), l2._free(d3), l2._free(n2), l2._free(V2), l2._free(Z2), l2._free(I2), l2._free(e2), this.dataChanged = true;
    }, d2 = (A3) => {
      if ((A3.positionChanged || A3.rotationChanged || A3.scaleChanged || A3.selectedChanged) && B2(A3), !A3.data.changed || A3.data.detached)
        return;
      const Q3 = { position: new Float32Array(A3.position.flat()), rotation: new Float32Array(A3.rotation.flat()), scale: new Float32Array(A3.scale.flat()), selected: A3.selected, vertexCount: A3.data.vertexCount, positions: A3.data.positions, rotations: A3.data.rotations, scales: A3.data.scales, colors: A3.data.colors, selection: A3.data.selection, offset: this._offsets.get(A3) };
      this._worker.postMessage({ splat: Q3 }, [Q3.position.buffer, Q3.rotation.buffer, Q3.scale.buffer, Q3.positions.buffer, Q3.rotations.buffer, Q3.scales.buffer, Q3.colors.buffer, Q3.selection.buffer]), this._updating.add(A3), A3.data.detached = true;
    };
    this.getSplat = (A3) => {
      let Q3 = null;
      for (const [F3, U3] of this._offsets) {
        if (!(A3 >= U3))
          break;
        Q3 = F3;
      }
      return Q3;
    }, this.getLocalIndex = (A3, Q3) => Q3 - this._offsets.get(A3), this.markDirty = (A3) => {
      this._dirty.add(A3);
    }, this.rebuild = () => {
      for (const A3 of this._dirty)
        d2(A3);
      this._dirty.clear();
    }, this.dispose = () => {
      this._worker.terminate();
    };
    for (const A3 of this._splatIndices.keys())
      t2(A3);
  }
  get offsets() {
    return this._offsets;
  }
  get data() {
    return this._data;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get transforms() {
    return this._transforms;
  }
  get transformsWidth() {
    return this._transformsWidth;
  }
  get transformsHeight() {
    return this._transformsHeight;
  }
  get transformIndices() {
    return this._transformIndices;
  }
  get transformIndicesWidth() {
    return this._transformIndicesWidth;
  }
  get transformIndicesHeight() {
    return this._transformIndicesHeight;
  }
  get positions() {
    return this._positions;
  }
  get rotations() {
    return this._rotations;
  }
  get scales() {
    return this._scales;
  }
  get vertexCount() {
    return this._vertexCount;
  }
  get needsRebuild() {
    return this._dirty.size > 0;
  }
  get updating() {
    return this._updating.size > 0;
  }
};
var m = class {
  constructor(A2 = 0, Q2 = 0, F2 = 0, U2 = 255) {
    this.r = A2, this.g = Q2, this.b = F2, this.a = U2;
  }
  flat() {
    return [this.r, this.g, this.b, this.a];
  }
  flatNorm() {
    return [this.r / 255, this.g / 255, this.b / 255, this.a / 255];
  }
  toHexString() {
    return "#" + this.flat().map((A2) => A2.toString(16).padStart(2, "0")).join("");
  }
  toString() {
    return `[${this.flat().join(", ")}]`;
  }
};
var N = class extends J {
  constructor(A2, Q2) {
    super(A2, Q2), this._outlineThickness = 10, this._outlineColor = new m(255, 165, 0, 255), this._renderData = null, this._depthIndex = new Uint32Array(), this._chunks = null, this._splatTexture = null;
    const F2 = A2.canvas, U2 = A2.gl;
    let B2, l2, t2, d2, n2, V2, Z2, e2, R2, a2, g2, i2, c2, C2, W2, h2;
    this._resize = () => {
      this._camera && (this._camera.data.setSize(F2.width, F2.height), this._camera.update(), l2 = U2.getUniformLocation(this.program, "projection"), U2.uniformMatrix4fv(l2, false, this._camera.data.projectionMatrix.buffer), t2 = U2.getUniformLocation(this.program, "viewport"), U2.uniform2fv(t2, new Float32Array([F2.width, F2.height])));
    };
    const s2 = () => {
      B2 = new o(), B2.onmessage = (A3) => {
        if (A3.data.depthIndex) {
          const { depthIndex: Q3, chunks: F3 } = A3.data;
          this._depthIndex = Q3, this._chunks = F3, U2.bindBuffer(U2.ARRAY_BUFFER, h2), U2.bufferData(U2.ARRAY_BUFFER, Q3, U2.STATIC_DRAW);
        }
      };
    };
    this._initialize = () => {
      if (this._scene && this._camera) {
        this._resize(), this._scene.addEventListener("objectAdded", J2), this._scene.addEventListener("objectRemoved", r2);
        for (const A3 of this._scene.objects)
          A3 instanceof I && A3.addEventListener("objectChanged", E2);
        this._renderData = new b(this._scene), d2 = U2.getUniformLocation(this.program, "focal"), U2.uniform2fv(d2, new Float32Array([this._camera.data.fx, this._camera.data.fy])), n2 = U2.getUniformLocation(this.program, "view"), U2.uniformMatrix4fv(n2, false, this._camera.data.viewMatrix.buffer), R2 = U2.getUniformLocation(this.program, "outlineThickness"), U2.uniform1f(R2, this.outlineThickness), a2 = U2.getUniformLocation(this.program, "outlineColor"), U2.uniform4fv(a2, new Float32Array(this.outlineColor.flatNorm())), this._splatTexture = U2.createTexture(), V2 = U2.getUniformLocation(this.program, "u_texture"), U2.uniform1i(V2, 0), c2 = U2.createTexture(), Z2 = U2.getUniformLocation(this.program, "u_transforms"), U2.uniform1i(Z2, 1), C2 = U2.createTexture(), e2 = U2.getUniformLocation(this.program, "u_transformIndices"), U2.uniform1i(e2, 2), W2 = U2.createBuffer(), U2.bindBuffer(U2.ARRAY_BUFFER, W2), U2.bufferData(U2.ARRAY_BUFFER, new Float32Array([-2, -2, 2, -2, 2, 2, -2, 2]), U2.STATIC_DRAW), g2 = U2.getAttribLocation(this.program, "position"), U2.enableVertexAttribArray(g2), U2.vertexAttribPointer(g2, 2, U2.FLOAT, false, 0, 0), h2 = U2.createBuffer(), i2 = U2.getAttribLocation(this.program, "index"), U2.enableVertexAttribArray(i2), U2.bindBuffer(U2.ARRAY_BUFFER, h2), s2();
      } else
        console.error("Cannot render without scene and camera");
    };
    const J2 = (A3) => {
      const Q3 = A3;
      Q3.object instanceof I && Q3.object.addEventListener("objectChanged", E2), this.dispose();
    }, r2 = (A3) => {
      const Q3 = A3;
      Q3.object instanceof I && Q3.object.removeEventListener("objectChanged", E2), this.dispose();
    }, E2 = (A3) => {
      const Q3 = A3;
      Q3.object instanceof I && this._renderData && this._renderData.markDirty(Q3.object);
    };
    this._render = () => {
      if (this._scene && this._camera && this.renderData) {
        if (this.renderData.needsRebuild && this.renderData.rebuild(), this.renderData.dataChanged || this.renderData.transformsChanged) {
          this.renderData.dataChanged && (U2.activeTexture(U2.TEXTURE0), U2.bindTexture(U2.TEXTURE_2D, this.splatTexture), U2.texParameteri(U2.TEXTURE_2D, U2.TEXTURE_WRAP_S, U2.CLAMP_TO_EDGE), U2.texParameteri(U2.TEXTURE_2D, U2.TEXTURE_WRAP_T, U2.CLAMP_TO_EDGE), U2.texParameteri(U2.TEXTURE_2D, U2.TEXTURE_MIN_FILTER, U2.NEAREST), U2.texParameteri(U2.TEXTURE_2D, U2.TEXTURE_MAG_FILTER, U2.NEAREST), U2.texImage2D(U2.TEXTURE_2D, 0, U2.RGBA32UI, this.renderData.width, this.renderData.height, 0, U2.RGBA_INTEGER, U2.UNSIGNED_INT, this.renderData.data)), this.renderData.transformsChanged && (U2.activeTexture(U2.TEXTURE1), U2.bindTexture(U2.TEXTURE_2D, c2), U2.texParameteri(U2.TEXTURE_2D, U2.TEXTURE_WRAP_S, U2.CLAMP_TO_EDGE), U2.texParameteri(U2.TEXTURE_2D, U2.TEXTURE_WRAP_T, U2.CLAMP_TO_EDGE), U2.texParameteri(U2.TEXTURE_2D, U2.TEXTURE_MIN_FILTER, U2.NEAREST), U2.texParameteri(U2.TEXTURE_2D, U2.TEXTURE_MAG_FILTER, U2.NEAREST), U2.texImage2D(U2.TEXTURE_2D, 0, U2.RGBA32F, this.renderData.transformsWidth, this.renderData.transformsHeight, 0, U2.RGBA, U2.FLOAT, this.renderData.transforms), U2.activeTexture(U2.TEXTURE2), U2.bindTexture(U2.TEXTURE_2D, C2), U2.texParameteri(U2.TEXTURE_2D, U2.TEXTURE_WRAP_S, U2.CLAMP_TO_EDGE), U2.texParameteri(U2.TEXTURE_2D, U2.TEXTURE_WRAP_T, U2.CLAMP_TO_EDGE), U2.texParameteri(U2.TEXTURE_2D, U2.TEXTURE_MIN_FILTER, U2.NEAREST), U2.texParameteri(U2.TEXTURE_2D, U2.TEXTURE_MAG_FILTER, U2.NEAREST), U2.texImage2D(U2.TEXTURE_2D, 0, U2.R32UI, this.renderData.transformIndicesWidth, this.renderData.transformIndicesHeight, 0, U2.RED_INTEGER, U2.UNSIGNED_INT, this.renderData.transformIndices));
          const A3 = new Float32Array(this.renderData.positions.slice().buffer), Q3 = new Float32Array(this.renderData.transforms.slice().buffer), F3 = new Uint32Array(this.renderData.transformIndices.slice().buffer);
          B2.postMessage({ sortData: { positions: A3, transforms: Q3, transformIndices: F3, vertexCount: this.renderData.vertexCount } }, [A3.buffer, Q3.buffer, F3.buffer]), this.renderData.dataChanged = false, this.renderData.transformsChanged = false;
        }
        this._camera.update(), B2.postMessage({ viewProj: this._camera.data.viewProj.buffer }), U2.viewport(0, 0, F2.width, F2.height), U2.clearColor(0, 0, 0, 0), U2.clear(U2.COLOR_BUFFER_BIT), U2.disable(U2.DEPTH_TEST), U2.enable(U2.BLEND), U2.blendFuncSeparate(U2.ONE_MINUS_DST_ALPHA, U2.ONE, U2.ONE_MINUS_DST_ALPHA, U2.ONE), U2.blendEquationSeparate(U2.FUNC_ADD, U2.FUNC_ADD), U2.uniformMatrix4fv(l2, false, this._camera.data.projectionMatrix.buffer), U2.uniformMatrix4fv(n2, false, this._camera.data.viewMatrix.buffer), U2.bindBuffer(U2.ARRAY_BUFFER, W2), U2.vertexAttribPointer(g2, 2, U2.FLOAT, false, 0, 0), U2.bindBuffer(U2.ARRAY_BUFFER, h2), U2.bufferData(U2.ARRAY_BUFFER, this.depthIndex, U2.STATIC_DRAW), U2.vertexAttribIPointer(i2, 1, U2.INT, 0, 0), U2.vertexAttribDivisor(i2, 1), U2.drawArraysInstanced(U2.TRIANGLE_FAN, 0, 4, this.renderData.vertexCount);
      } else
        console.error("Cannot render without scene and camera");
    }, this._dispose = () => {
      if (this._scene && this._camera && this.renderData) {
        this._scene.removeEventListener("objectAdded", J2), this._scene.removeEventListener("objectRemoved", r2);
        for (const A3 of this._scene.objects)
          A3 instanceof I && A3.removeEventListener("objectChanged", E2);
        B2.terminate(), this.renderData.dispose(), U2.deleteTexture(this.splatTexture), U2.deleteTexture(c2), U2.deleteTexture(C2), U2.deleteBuffer(h2), U2.deleteBuffer(W2);
      } else
        console.error("Cannot dispose without scene and camera");
    }, this._setOutlineThickness = (A3) => {
      this._outlineThickness = A3, this._initialized && U2.uniform1f(R2, A3);
    }, this._setOutlineColor = (A3) => {
      this._outlineColor = A3, this._initialized && U2.uniform4fv(a2, new Float32Array(A3.flatNorm()));
    };
  }
  get renderData() {
    return this._renderData;
  }
  get depthIndex() {
    return this._depthIndex;
  }
  get chunks() {
    return this._chunks;
  }
  get splatTexture() {
    return this._splatTexture;
  }
  get outlineThickness() {
    return this._outlineThickness;
  }
  set outlineThickness(A2) {
    this._setOutlineThickness(A2);
  }
  get outlineColor() {
    return this._outlineColor;
  }
  set outlineColor(A2) {
    this._setOutlineColor(A2);
  }
  _getVertexSource() {
    return "#version 300 es\nprecision highp float;\nprecision highp int;\n\nuniform highp usampler2D u_texture;\nuniform highp sampler2D u_transforms;\nuniform highp usampler2D u_transformIndices;\nuniform mat4 projection, view;\nuniform vec2 focal;\nuniform vec2 viewport;\n\nuniform bool useDepthFade;\nuniform float depthFade;\n\nin vec2 position;\nin int index;\n\nout vec4 vColor;\nout vec2 vPosition;\nout float vSize;\nout float vSelected;\n\nvoid main () {\n    uvec4 cen = texelFetch(u_texture, ivec2((uint(index) & 0x3ffu) << 1, uint(index) >> 10), 0);\n    float selected = float((cen.w >> 24) & 0xffu);\n\n    uint transformIndex = texelFetch(u_transformIndices, ivec2(uint(index) & 0x3ffu, uint(index) >> 10), 0).x;\n    mat4 transform = mat4(\n        texelFetch(u_transforms, ivec2(0, transformIndex), 0),\n        texelFetch(u_transforms, ivec2(1, transformIndex), 0),\n        texelFetch(u_transforms, ivec2(2, transformIndex), 0),\n        texelFetch(u_transforms, ivec2(3, transformIndex), 0)\n    );\n\n    if (selected < 0.5) {\n        selected = texelFetch(u_transforms, ivec2(4, transformIndex), 0).x;\n    }\n\n    mat4 viewTransform = view * transform;\n\n    vec4 cam = viewTransform * vec4(uintBitsToFloat(cen.xyz), 1);\n    vec4 pos2d = projection * cam;\n\n    float clip = 1.2 * pos2d.w;\n    if (pos2d.z < -pos2d.w || pos2d.z > pos2d.w || pos2d.x < -clip || pos2d.x > clip || pos2d.y < -clip || pos2d.y > clip) {\n        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n        return;\n    }\n\n    uvec4 cov = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 1) | 1u, uint(index) >> 10), 0);\n    vec2 u1 = unpackHalf2x16(cov.x), u2 = unpackHalf2x16(cov.y), u3 = unpackHalf2x16(cov.z);\n    mat3 Vrk = mat3(u1.x, u1.y, u2.x, u1.y, u2.y, u3.x, u2.x, u3.x, u3.y);\n\n    mat3 J = mat3(\n        focal.x / cam.z, 0., -(focal.x * cam.x) / (cam.z * cam.z), \n        0., -focal.y / cam.z, (focal.y * cam.y) / (cam.z * cam.z), \n        0., 0., 0.\n    );\n\n    mat3 T = transpose(mat3(viewTransform)) * J;\n    mat3 cov2d = transpose(T) * Vrk * T;\n\n    float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;\n    float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));\n    float lambda1 = mid + radius, lambda2 = mid - radius;\n\n    if (lambda2 < 0.0) return;\n    vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));\n    vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;\n    vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);\n\n    vColor = vec4((cov.w) & 0xffu, (cov.w >> 8) & 0xffu, (cov.w >> 16) & 0xffu, (cov.w >> 24) & 0xffu) / 255.0;\n    vPosition = position;\n    vSize = length(majorAxis);\n    vSelected = selected;\n\n    float scalingFactor = 1.0;\n\n    if (useDepthFade) {\n        float depthNorm = (pos2d.z / pos2d.w + 1.0) / 2.0;\n        float near = 0.1; float far = 100.0;\n        float normalizedDepth = (2.0 * near) / (far + near - depthNorm * (far - near));\n        float start = max(normalizedDepth - 0.1, 0.0);\n        float end = min(normalizedDepth + 0.1, 1.0);\n        scalingFactor = clamp((depthFade - start) / (end - start), 0.0, 1.0);\n    }\n\n    vec2 vCenter = vec2(pos2d) / pos2d.w;\n    gl_Position = vec4(\n        vCenter \n        + position.x * majorAxis * scalingFactor / viewport\n        + position.y * minorAxis * scalingFactor / viewport, 0.0, 1.0);\n}\n";
  }
  _getFragmentSource() {
    return "#version 300 es\nprecision highp float;\n\nuniform float outlineThickness;\nuniform vec4 outlineColor;\n\nin vec4 vColor;\nin vec2 vPosition;\nin float vSize;\nin float vSelected;\n\nout vec4 fragColor;\n\nvoid main () {\n    float A = -dot(vPosition, vPosition);\n\n    if (A < -4.0) discard;\n\n    if (vSelected < 0.5) {\n        float B = exp(A) * vColor.a;\n        fragColor = vec4(B * vColor.rgb, B);\n        return;\n    }\n\n    float outlineThreshold = -4.0 + (outlineThickness / vSize);\n\n    if (A < outlineThreshold) {\n        fragColor = outlineColor;\n    } \n    else {\n        float B = exp(A) * vColor.a;\n        fragColor = vec4(B * vColor.rgb, B);\n    }\n}\n";
  }
};
var G = class {
  constructor(A2 = 1) {
    let Q2, F2, U2, B2, l2 = 0, t2 = false;
    this.initialize = (A3) => {
      if (!(A3 instanceof N))
        throw new Error("FadeInPass requires a RenderProgram");
      l2 = A3.started ? 1 : 0, t2 = true, Q2 = A3, F2 = A3.renderer.gl, U2 = F2.getUniformLocation(Q2.program, "useDepthFade"), F2.uniform1i(U2, 1), B2 = F2.getUniformLocation(Q2.program, "depthFade"), F2.uniform1f(B2, l2);
    }, this.render = () => {
      var d2;
      t2 && !(null === (d2 = Q2.renderData) || void 0 === d2 ? void 0 : d2.updating) && (F2.useProgram(Q2.program), l2 = Math.min(l2 + 0.01 * A2, 1), l2 >= 1 && (t2 = false, F2.uniform1i(U2, 0)), F2.uniform1f(B2, l2));
    };
  }
  dispose() {
  }
};
var y = class {
  constructor(A2 = null, Q2 = null) {
    this._backgroundColor = new m();
    const F2 = A2 || document.createElement("canvas");
    A2 || (F2.style.display = "block", F2.style.boxSizing = "border-box", F2.style.width = "100%", F2.style.height = "100%", F2.style.margin = "0", F2.style.padding = "0", document.body.appendChild(F2)), F2.style.background = this._backgroundColor.toHexString(), this._canvas = F2, this._gl = F2.getContext("webgl2", { antialias: false });
    const U2 = Q2 || [];
    Q2 || U2.push(new G()), this._renderProgram = new N(this, U2);
    const B2 = [this._renderProgram];
    this.resize = () => {
      const A3 = F2.clientWidth, Q3 = F2.clientHeight;
      F2.width === A3 && F2.height === Q3 || this.setSize(A3, Q3);
    }, this.setSize = (A3, Q3) => {
      F2.width = A3, F2.height = Q3, this._gl.viewport(0, 0, F2.width, F2.height);
      for (const A4 of B2)
        A4.resize();
    }, this.render = (A3, Q3) => {
      for (const F3 of B2)
        F3.render(A3, Q3);
    }, this.dispose = () => {
      for (const A3 of B2)
        A3.dispose();
    }, this.addProgram = (A3) => {
      B2.push(A3);
    }, this.removeProgram = (A3) => {
      const Q3 = B2.indexOf(A3);
      if (Q3 < 0)
        throw new Error("Program not found");
      B2.splice(Q3, 1);
    }, this.resize();
  }
  get canvas() {
    return this._canvas;
  }
  get gl() {
    return this._gl;
  }
  get renderProgram() {
    return this._renderProgram;
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(A2) {
    this._backgroundColor = A2, this._canvas.style.background = A2.toHexString();
  }
};
var S = class {
  constructor(F2, U2, B2 = 0.5, l2 = 0.5, t2 = 5, d2 = true, V2 = new A()) {
    this.minAngle = -90, this.maxAngle = 90, this.minZoom = 0.1, this.maxZoom = 30, this.orbitSpeed = 1, this.panSpeed = 1, this.zoomSpeed = 1, this.dampening = 0.12, this.setCameraTarget = () => {
    };
    let Z2 = V2.clone(), I2 = Z2.clone(), e2 = B2, R2 = l2, a2 = t2, g2 = false, i2 = false, c2 = 0, C2 = 0, W2 = 0;
    const h2 = {};
    let s2 = false;
    F2.addEventListener("objectChanged", () => {
      if (s2)
        return;
      const Q2 = F2.rotation.toEuler();
      e2 = -Q2.y, R2 = -Q2.x;
      const U3 = F2.position.x - a2 * Math.sin(e2) * Math.cos(R2), B3 = F2.position.y + a2 * Math.sin(R2), l3 = F2.position.z + a2 * Math.cos(e2) * Math.cos(R2);
      I2 = new A(U3, B3, l3);
    }), this.setCameraTarget = (Q2) => {
      const U3 = Q2.x - F2.position.x, B3 = Q2.y - F2.position.y, l3 = Q2.z - F2.position.z;
      a2 = Math.sqrt(U3 * U3 + B3 * B3 + l3 * l3), R2 = Math.atan2(B3, Math.sqrt(U3 * U3 + l3 * l3)), e2 = -Math.atan2(U3, l3), I2 = new A(Q2.x, Q2.y, Q2.z);
    };
    const o2 = () => 0.1 + 0.9 * (a2 - this.minZoom) / (this.maxZoom - this.minZoom), J2 = (A2) => {
      h2[A2.code] = true, "ArrowUp" === A2.code && (h2.KeyW = true), "ArrowDown" === A2.code && (h2.KeyS = true), "ArrowLeft" === A2.code && (h2.KeyA = true), "ArrowRight" === A2.code && (h2.KeyD = true);
    }, r2 = (A2) => {
      h2[A2.code] = false, "ArrowUp" === A2.code && (h2.KeyW = false), "ArrowDown" === A2.code && (h2.KeyS = false), "ArrowLeft" === A2.code && (h2.KeyA = false), "ArrowRight" === A2.code && (h2.KeyD = false);
    }, E2 = (A2) => {
      Y2(A2), g2 = true, i2 = 2 === A2.button, C2 = A2.clientX, W2 = A2.clientY, window.addEventListener("mouseup", b2);
    }, b2 = (A2) => {
      Y2(A2), g2 = false, i2 = false, window.removeEventListener("mouseup", b2);
    }, m2 = (Q2) => {
      if (Y2(Q2), !g2 || !F2)
        return;
      const U3 = Q2.clientX - C2, B3 = Q2.clientY - W2;
      if (i2) {
        const Q3 = o2(), l3 = -U3 * this.panSpeed * 0.01 * Q3, t3 = -B3 * this.panSpeed * 0.01 * Q3, d3 = n.RotationFromQuaternion(F2.rotation).buffer, V3 = new A(d3[0], d3[3], d3[6]), Z3 = new A(d3[1], d3[4], d3[7]);
        I2 = I2.add(V3.multiply(l3)), I2 = I2.add(Z3.multiply(t3));
      } else
        e2 -= U3 * this.orbitSpeed * 3e-3, R2 += B3 * this.orbitSpeed * 3e-3, R2 = Math.min(Math.max(R2, this.minAngle * Math.PI / 180), this.maxAngle * Math.PI / 180);
      C2 = Q2.clientX, W2 = Q2.clientY;
    }, N2 = (A2) => {
      Y2(A2);
      const Q2 = o2();
      a2 += A2.deltaY * this.zoomSpeed * 0.025 * Q2, a2 = Math.min(Math.max(a2, this.minZoom), this.maxZoom);
    }, G2 = (A2) => {
      if (Y2(A2), 1 === A2.touches.length)
        g2 = true, i2 = false, C2 = A2.touches[0].clientX, W2 = A2.touches[0].clientY, c2 = 0;
      else if (2 === A2.touches.length) {
        g2 = true, i2 = true, C2 = (A2.touches[0].clientX + A2.touches[1].clientX) / 2, W2 = (A2.touches[0].clientY + A2.touches[1].clientY) / 2;
        const Q2 = A2.touches[0].clientX - A2.touches[1].clientX, F3 = A2.touches[0].clientY - A2.touches[1].clientY;
        c2 = Math.sqrt(Q2 * Q2 + F3 * F3);
      }
    }, y2 = (A2) => {
      Y2(A2), g2 = false, i2 = false;
    }, S2 = (Q2) => {
      if (Y2(Q2), g2 && F2)
        if (i2) {
          const U3 = o2(), B3 = Q2.touches[0].clientX - Q2.touches[1].clientX, l3 = Q2.touches[0].clientY - Q2.touches[1].clientY, t3 = Math.sqrt(B3 * B3 + l3 * l3);
          a2 += (c2 - t3) * this.zoomSpeed * 0.1 * U3, a2 = Math.min(Math.max(a2, this.minZoom), this.maxZoom), c2 = t3;
          const d3 = (Q2.touches[0].clientX + Q2.touches[1].clientX) / 2, V3 = (Q2.touches[0].clientY + Q2.touches[1].clientY) / 2, Z3 = d3 - C2, e3 = V3 - W2, R3 = n.RotationFromQuaternion(F2.rotation).buffer, g3 = new A(R3[0], R3[3], R3[6]), i3 = new A(R3[1], R3[4], R3[7]);
          I2 = I2.add(g3.multiply(-Z3 * this.panSpeed * 0.025 * U3)), I2 = I2.add(i3.multiply(-e3 * this.panSpeed * 0.025 * U3)), C2 = d3, W2 = V3;
        } else {
          const A2 = Q2.touches[0].clientX - C2, F3 = Q2.touches[0].clientY - W2;
          e2 -= A2 * this.orbitSpeed * 3e-3, R2 += F3 * this.orbitSpeed * 3e-3, R2 = Math.min(Math.max(R2, this.minAngle * Math.PI / 180), this.maxAngle * Math.PI / 180), C2 = Q2.touches[0].clientX, W2 = Q2.touches[0].clientY;
        }
    }, X2 = (A2, Q2, F3) => (1 - F3) * A2 + F3 * Q2;
    this.update = () => {
      s2 = true, B2 = X2(B2, e2, this.dampening), l2 = X2(l2, R2, this.dampening), t2 = X2(t2, a2, this.dampening), Z2 = Z2.lerp(I2, this.dampening);
      const U3 = Z2.x + t2 * Math.sin(B2) * Math.cos(l2), d3 = Z2.y - t2 * Math.sin(l2), V3 = Z2.z - t2 * Math.cos(B2) * Math.cos(l2);
      F2.position = new A(U3, d3, V3);
      const g3 = Z2.subtract(F2.position).normalize(), i3 = Math.asin(-g3.y), c3 = Math.atan2(g3.x, g3.z);
      F2.rotation = Q.FromEuler(new A(i3, c3, 0));
      const C3 = 0.025, W3 = 0.01, o3 = n.RotationFromQuaternion(F2.rotation).buffer, J3 = new A(-o3[2], -o3[5], -o3[8]), r3 = new A(o3[0], o3[3], o3[6]);
      h2.KeyS && (I2 = I2.add(J3.multiply(C3))), h2.KeyW && (I2 = I2.subtract(J3.multiply(C3))), h2.KeyA && (I2 = I2.subtract(r3.multiply(C3))), h2.KeyD && (I2 = I2.add(r3.multiply(C3))), h2.KeyE && (e2 += W3), h2.KeyQ && (e2 -= W3), h2.KeyR && (R2 += W3), h2.KeyF && (R2 -= W3), s2 = false;
    };
    const Y2 = (A2) => {
      A2.preventDefault(), A2.stopPropagation();
    };
    this.dispose = () => {
      U2.removeEventListener("dragenter", Y2), U2.removeEventListener("dragover", Y2), U2.removeEventListener("dragleave", Y2), U2.removeEventListener("contextmenu", Y2), U2.removeEventListener("mousedown", E2), U2.removeEventListener("mousemove", m2), U2.removeEventListener("wheel", N2), U2.removeEventListener("touchstart", G2), U2.removeEventListener("touchend", y2), U2.removeEventListener("touchmove", S2), d2 && (window.removeEventListener("keydown", J2), window.removeEventListener("keyup", r2));
    }, d2 && (window.addEventListener("keydown", J2), window.addEventListener("keyup", r2)), U2.addEventListener("dragenter", Y2), U2.addEventListener("dragover", Y2), U2.addEventListener("dragleave", Y2), U2.addEventListener("contextmenu", Y2), U2.addEventListener("mousedown", E2), U2.addEventListener("mousemove", m2), U2.addEventListener("wheel", N2), U2.addEventListener("touchstart", G2), U2.addEventListener("touchend", y2), U2.addEventListener("touchmove", S2), this.update();
  }
};
var X = class {
  constructor(A2, Q2) {
    this.normal = A2, this.point = Q2;
  }
  intersect(A2, Q2) {
    const F2 = this.normal.dot(Q2);
    if (Math.abs(F2) < 1e-4)
      return null;
    const U2 = this.normal.dot(this.point.subtract(A2)) / F2;
    return U2 < 0 ? null : A2.add(Q2.multiply(U2));
  }
};
var Y = class {
  initialize(A2) {
  }
  render() {
  }
  dispose() {
  }
};
var p = function(A2 = {}) {
  var Q2, F2, U2 = A2;
  U2.ready = new Promise((A3, U3) => {
    Q2 = A3, F2 = U3;
  });
  var B2 = Object.assign({}, U2), l2 = "";
  "undefined" != typeof document && document.currentScript && (l2 = document.currentScript.src), l2 = l2.startsWith("blob:") ? "" : l2.substr(0, l2.replace(/[?#].*/, "").lastIndexOf("/") + 1), U2.print || console.log.bind(console);
  var t2, d2, n2 = U2.printErr || console.error.bind(console);
  function V2(A3) {
    if (G2(A3))
      return function(A4) {
        for (var Q3 = atob(A4), F3 = new Uint8Array(Q3.length), U3 = 0; U3 < Q3.length; ++U3)
          F3[U3] = Q3.charCodeAt(U3);
        return F3;
      }(A3.slice(N2.length));
  }
  Object.assign(U2, B2), B2 = null, U2.arguments && U2.arguments, U2.thisProgram && U2.thisProgram, U2.quit && U2.quit, U2.wasmBinary && (t2 = U2.wasmBinary), "object" != typeof WebAssembly && E2("no native wasm support detected");
  var Z2, I2, e2, R2, a2, g2, i2, c2, C2 = false;
  function W2() {
    var A3 = d2.buffer;
    U2.HEAP8 = Z2 = new Int8Array(A3), U2.HEAP16 = e2 = new Int16Array(A3), U2.HEAPU8 = I2 = new Uint8Array(A3), U2.HEAPU16 = R2 = new Uint16Array(A3), U2.HEAP32 = a2 = new Int32Array(A3), U2.HEAPU32 = g2 = new Uint32Array(A3), U2.HEAPF32 = i2 = new Float32Array(A3), U2.HEAPF64 = c2 = new Float64Array(A3);
  }
  var h2 = [], s2 = [], o2 = [], J2 = 0, r2 = null;
  function E2(A3) {
    var _a;
    (_a = U2.onAbort) == null ? void 0 : _a.call(U2, A3), n2(A3 = "Aborted(" + A3 + ")"), C2 = true, A3 += ". Build with -sASSERTIONS for more info.";
    var Q3 = new WebAssembly.RuntimeError(A3);
    throw F2(Q3), Q3;
  }
  var b2, m2, N2 = "data:application/octet-stream;base64,", G2 = (A3) => A3.startsWith(N2);
  function y2(A3) {
    return Promise.resolve().then(() => function(A4) {
      if (A4 == b2 && t2)
        return new Uint8Array(t2);
      var Q3 = V2(A4);
      if (Q3)
        return Q3;
      throw "both async and sync fetching of the wasm failed";
    }(A3));
  }
  function S2(A3, Q3, F3, U3) {
    return function(A4, Q4, F4) {
      return y2(A4).then((A5) => WebAssembly.instantiate(A5, Q4)).then(F4, (A5) => {
        n2(`failed to asynchronously prepare wasm: ${A5}`), E2(A5);
      });
    }(Q3, F3, U3);
  }
  G2(b2 = "data:application/octet-stream;base64,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CyACQfAAaiQAIAALtQEBBH8jAEFAaiIDJAACf0EBIAAgAUEAEAoNABpBACABRQ0AGkEAIAFBnBYQICIBRQ0AGiADQQxqIQRBNCEFA0AgBEEAOgAAIARBAWohBCAFQQFrIgUNAAsgA0EBNgI4IANBfzYCFCADIAA2AhAgAyABNgIIIAEgA0EIaiACKAIAQQEgASgCACgCHBEAACADKAIgIgBBAUYEQCACIAMoAhg2AgALIABBAUYLIQYgA0FAayQAIAYLCgAgACABQQAQCgsLtxICAEGACAumEnVuc2lnbmVkIHNob3J0AHVuc2lnbmVkIGludABmbG9hdAB1aW50NjRfdAB1bnNpZ25lZCBjaGFyAGJvb2wAdW5zaWduZWQgbG9uZwBzdGQ6OndzdHJpbmcAc3RkOjpzdHJpbmcAc3RkOjp1MTZzdHJpbmcAc3RkOjp1MzJzdHJpbmcAZG91YmxlAHZvaWQAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4ATlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAAAAAlAwAADIHAABOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQAAlAwAAHwHAABOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQAAlAwAAMQHAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRHNOU18xMWNoYXJfdHJhaXRzSURzRUVOU185YWxsb2NhdG9ySURzRUVFRQAAAJQMAAAMCAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURpTlNfMTFjaGFyX3RyYWl0c0lEaUVFTlNfOWFsbG9jYXRvcklEaUVFRUUAAACUDAAAWAgAAE4xMGVtc2NyaXB0ZW4zdmFsRQAAlAwAAKQIAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUAAJQMAADACAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAACUDAAA6AgAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQAAlAwAABAJAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAAJQMAAA4CQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAACUDAAAYAkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAAlAwAAIgJAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAAJQMAACwCQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAACUDAAA2AkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAAlAwAAAAKAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l4RUUAAJQMAAAoCgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJeUVFAACUDAAAUAoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQAAlAwAAHgKAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUAAJQMAACgCgAATjEwX19jeHhhYml2MTE2X19zaGltX3R5cGVfaW5mb0UAAAAAvAwAAMgKAAAgDQAATjEwX19jeHhhYml2MTE3X19jbGFzc190eXBlX2luZm9FAAAAvAwAAPgKAADsCgAATjEwX19jeHhhYml2MTE3X19wYmFzZV90eXBlX2luZm9FAAAAvAwAACgLAADsCgAATjEwX19jeHhhYml2MTE5X19wb2ludGVyX3R5cGVfaW5mb0UAvAwAAFgLAABMCwAAAAAAAMwLAAACAAAAAwAAAAQAAAAFAAAABgAAAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQC8DAAApAsAAOwKAAB2AAAAkAsAANgLAABiAAAAkAsAAOQLAABjAAAAkAsAAPALAABoAAAAkAsAAPwLAABhAAAAkAsAAAgMAABzAAAAkAsAABQMAAB0AAAAkAsAACAMAABpAAAAkAsAACwMAABqAAAAkAsAADgMAABsAAAAkAsAAEQMAABtAAAAkAsAAFAMAAB4AAAAkAsAAFwMAAB5AAAAkAsAAGgMAABmAAAAkAsAAHQMAABkAAAAkAsAAIAMAAAAAAAAHAsAAAIAAAAHAAAABAAAAAUAAAAIAAAACQAAAAoAAAALAAAAAAAAAAQNAAACAAAADAAAAAQAAAAFAAAACAAAAA0AAAAOAAAADwAAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAAC8DAAA3AwAABwLAABTdDl0eXBlX2luZm8AAAAAlAwAABANAEGoGgsD4A8B") || (m2 = b2, b2 = U2.locateFile ? U2.locateFile(m2, l2) : l2 + m2);
  var X2 = (A3) => {
    for (; A3.length > 0; )
      A3.shift()(U2);
  };
  U2.noExitRuntime;
  var Y2, p2, k2 = (A3) => {
    for (var Q3 = "", F3 = A3; I2[F3]; )
      Q3 += Y2[I2[F3++]];
    return Q3;
  }, u = {}, T = {}, H = (A3) => {
    throw new p2(A3);
  };
  function D(A3, Q3, F3 = {}) {
    if (!("argPackAdvance" in Q3))
      throw new TypeError("registerType registeredInstance requires argPackAdvance");
    return function(A4, Q4, F4 = {}) {
      var U3 = Q4.name;
      if (A4 || H(`type "${U3}" must have a positive integer typeid pointer`), T.hasOwnProperty(A4)) {
        if (F4.ignoreDuplicateRegistrations)
          return;
        H(`Cannot register type '${U3}' twice`);
      }
      if (T[A4] = Q4, u.hasOwnProperty(A4)) {
        var B3 = u[A4];
        delete u[A4], B3.forEach((A5) => A5());
      }
    }(A3, Q3, F3);
  }
  var w = [], x = [], f = () => x.length / 2 - 5 - w.length, M = (A3) => (A3 || H("Cannot use deleted val. handle = " + A3), x[A3]), v = (A3) => {
    switch (A3) {
      case void 0:
        return 2;
      case null:
        return 4;
      case true:
        return 6;
      case false:
        return 8;
      default: {
        const Q3 = w.pop() || x.length;
        return x[Q3] = A3, x[Q3 + 1] = 1, Q3;
      }
    }
  };
  function z(A3) {
    return this.fromWireType(g2[A3 >> 2]);
  }
  var K = { name: "emscripten::val", fromWireType: (A3) => {
    var Q3 = M(A3);
    return ((A4) => {
      A4 > 9 && 0 == --x[A4 + 1] && (x[A4] = void 0, w.push(A4));
    })(A3), Q3;
  }, toWireType: (A3, Q3) => v(Q3), argPackAdvance: 8, readValueFromPointer: z, destructorFunction: null }, j = (A3, Q3) => {
    switch (Q3) {
      case 4:
        return function(A4) {
          return this.fromWireType(i2[A4 >> 2]);
        };
      case 8:
        return function(A4) {
          return this.fromWireType(c2[A4 >> 3]);
        };
      default:
        throw new TypeError(`invalid float width (${Q3}): ${A3}`);
    }
  }, O = (A3, Q3, F3) => {
    switch (Q3) {
      case 1:
        return F3 ? (A4) => Z2[A4] : (A4) => I2[A4];
      case 2:
        return F3 ? (A4) => e2[A4 >> 1] : (A4) => R2[A4 >> 1];
      case 4:
        return F3 ? (A4) => a2[A4 >> 2] : (A4) => g2[A4 >> 2];
      default:
        throw new TypeError(`invalid integer width (${Q3}): ${A3}`);
    }
  }, L = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, P = (A3, Q3) => A3 ? ((A4, Q4, F3) => {
    for (var U3 = Q4 + F3, B3 = Q4; A4[B3] && !(B3 >= U3); )
      ++B3;
    if (B3 - Q4 > 16 && A4.buffer && L)
      return L.decode(A4.subarray(Q4, B3));
    for (var l3 = ""; Q4 < B3; ) {
      var t3 = A4[Q4++];
      if (128 & t3) {
        var d3 = 63 & A4[Q4++];
        if (192 != (224 & t3)) {
          var n3 = 63 & A4[Q4++];
          if ((t3 = 224 == (240 & t3) ? (15 & t3) << 12 | d3 << 6 | n3 : (7 & t3) << 18 | d3 << 12 | n3 << 6 | 63 & A4[Q4++]) < 65536)
            l3 += String.fromCharCode(t3);
          else {
            var V3 = t3 - 65536;
            l3 += String.fromCharCode(55296 | V3 >> 10, 56320 | 1023 & V3);
          }
        } else
          l3 += String.fromCharCode((31 & t3) << 6 | d3);
      } else
        l3 += String.fromCharCode(t3);
    }
    return l3;
  })(I2, A3, Q3) : "", _ = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0, q = (A3, Q3) => {
    for (var F3 = A3, U3 = F3 >> 1, B3 = U3 + Q3 / 2; !(U3 >= B3) && R2[U3]; )
      ++U3;
    if ((F3 = U3 << 1) - A3 > 32 && _)
      return _.decode(I2.subarray(A3, F3));
    for (var l3 = "", t3 = 0; !(t3 >= Q3 / 2); ++t3) {
      var d3 = e2[A3 + 2 * t3 >> 1];
      if (0 == d3)
        break;
      l3 += String.fromCharCode(d3);
    }
    return l3;
  }, $ = (A3, Q3, F3) => {
    if (F3 ?? (F3 = 2147483647), F3 < 2)
      return 0;
    for (var U3 = Q3, B3 = (F3 -= 2) < 2 * A3.length ? F3 / 2 : A3.length, l3 = 0; l3 < B3; ++l3) {
      var t3 = A3.charCodeAt(l3);
      e2[Q3 >> 1] = t3, Q3 += 2;
    }
    return e2[Q3 >> 1] = 0, Q3 - U3;
  }, AA = (A3) => 2 * A3.length, QA = (A3, Q3) => {
    for (var F3 = 0, U3 = ""; !(F3 >= Q3 / 4); ) {
      var B3 = a2[A3 + 4 * F3 >> 2];
      if (0 == B3)
        break;
      if (++F3, B3 >= 65536) {
        var l3 = B3 - 65536;
        U3 += String.fromCharCode(55296 | l3 >> 10, 56320 | 1023 & l3);
      } else
        U3 += String.fromCharCode(B3);
    }
    return U3;
  }, FA = (A3, Q3, F3) => {
    if (F3 ?? (F3 = 2147483647), F3 < 4)
      return 0;
    for (var U3 = Q3, B3 = U3 + F3 - 4, l3 = 0; l3 < A3.length; ++l3) {
      var t3 = A3.charCodeAt(l3);
      if (t3 >= 55296 && t3 <= 57343 && (t3 = 65536 + ((1023 & t3) << 10) | 1023 & A3.charCodeAt(++l3)), a2[Q3 >> 2] = t3, (Q3 += 4) + 4 > B3)
        break;
    }
    return a2[Q3 >> 2] = 0, Q3 - U3;
  }, UA = (A3) => {
    for (var Q3 = 0, F3 = 0; F3 < A3.length; ++F3) {
      var U3 = A3.charCodeAt(F3);
      U3 >= 55296 && U3 <= 57343 && ++F3, Q3 += 4;
    }
    return Q3;
  }, BA = (A3) => {
    var Q3 = (A3 - d2.buffer.byteLength + 65535) / 65536;
    try {
      return d2.grow(Q3), W2(), 1;
    } catch (A4) {
    }
  };
  (() => {
    for (var A3 = new Array(256), Q3 = 0; Q3 < 256; ++Q3)
      A3[Q3] = String.fromCharCode(Q3);
    Y2 = A3;
  })(), p2 = U2.BindingError = class extends Error {
    constructor(A3) {
      super(A3), this.name = "BindingError";
    }
  }, U2.InternalError = class extends Error {
    constructor(A3) {
      super(A3), this.name = "InternalError";
    }
  }, x.push(0, 1, void 0, 1, null, 1, true, 1, false, 1), U2.count_emval_handles = f;
  var lA = { f: (A3, Q3, F3, U3, B3) => {
  }, i: (A3, Q3, F3, U3) => {
    D(A3, { name: Q3 = k2(Q3), fromWireType: function(A4) {
      return !!A4;
    }, toWireType: function(A4, Q4) {
      return Q4 ? F3 : U3;
    }, argPackAdvance: 8, readValueFromPointer: function(A4) {
      return this.fromWireType(I2[A4]);
    }, destructorFunction: null });
  }, h: (A3) => D(A3, K), e: (A3, Q3, F3) => {
    D(A3, { name: Q3 = k2(Q3), fromWireType: (A4) => A4, toWireType: (A4, Q4) => Q4, argPackAdvance: 8, readValueFromPointer: j(Q3, F3), destructorFunction: null });
  }, b: (A3, Q3, F3, U3, B3) => {
    Q3 = k2(Q3);
    var l3 = (A4) => A4;
    if (0 === U3) {
      var t3 = 32 - 8 * F3;
      l3 = (A4) => A4 << t3 >>> t3;
    }
    var d3 = Q3.includes("unsigned");
    D(A3, { name: Q3, fromWireType: l3, toWireType: d3 ? function(A4, Q4) {
      return this.name, Q4 >>> 0;
    } : function(A4, Q4) {
      return this.name, Q4;
    }, argPackAdvance: 8, readValueFromPointer: O(Q3, F3, 0 !== U3), destructorFunction: null });
  }, a: (A3, Q3, F3) => {
    var U3 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][Q3];
    function B3(A4) {
      var Q4 = g2[A4 >> 2], F4 = g2[A4 + 4 >> 2];
      return new U3(Z2.buffer, F4, Q4);
    }
    D(A3, { name: F3 = k2(F3), fromWireType: B3, argPackAdvance: 8, readValueFromPointer: B3 }, { ignoreDuplicateRegistrations: true });
  }, d: (A3, Q3) => {
    var F3 = "std::string" === (Q3 = k2(Q3));
    D(A3, { name: Q3, fromWireType(A4) {
      var Q4, U3 = g2[A4 >> 2], B3 = A4 + 4;
      if (F3)
        for (var l3 = B3, t3 = 0; t3 <= U3; ++t3) {
          var d3 = B3 + t3;
          if (t3 == U3 || 0 == I2[d3]) {
            var n3 = P(l3, d3 - l3);
            void 0 === Q4 ? Q4 = n3 : (Q4 += String.fromCharCode(0), Q4 += n3), l3 = d3 + 1;
          }
        }
      else {
        var V3 = new Array(U3);
        for (t3 = 0; t3 < U3; ++t3)
          V3[t3] = String.fromCharCode(I2[B3 + t3]);
        Q4 = V3.join("");
      }
      return VA(A4), Q4;
    }, toWireType(A4, Q4) {
      var U3;
      Q4 instanceof ArrayBuffer && (Q4 = new Uint8Array(Q4));
      var B3 = "string" == typeof Q4;
      B3 || Q4 instanceof Uint8Array || Q4 instanceof Uint8ClampedArray || Q4 instanceof Int8Array || H("Cannot pass non-string to std::string"), U3 = F3 && B3 ? ((A5) => {
        for (var Q5 = 0, F4 = 0; F4 < A5.length; ++F4) {
          var U4 = A5.charCodeAt(F4);
          U4 <= 127 ? Q5++ : U4 <= 2047 ? Q5 += 2 : U4 >= 55296 && U4 <= 57343 ? (Q5 += 4, ++F4) : Q5 += 3;
        }
        return Q5;
      })(Q4) : Q4.length;
      var l3 = nA(4 + U3 + 1), t3 = l3 + 4;
      if (g2[l3 >> 2] = U3, F3 && B3)
        ((A5, Q5, F4, U4) => {
          if (!(U4 > 0))
            return 0;
          for (var B4 = F4 + U4 - 1, l4 = 0; l4 < A5.length; ++l4) {
            var t4 = A5.charCodeAt(l4);
            if (t4 >= 55296 && t4 <= 57343 && (t4 = 65536 + ((1023 & t4) << 10) | 1023 & A5.charCodeAt(++l4)), t4 <= 127) {
              if (F4 >= B4)
                break;
              Q5[F4++] = t4;
            } else if (t4 <= 2047) {
              if (F4 + 1 >= B4)
                break;
              Q5[F4++] = 192 | t4 >> 6, Q5[F4++] = 128 | 63 & t4;
            } else if (t4 <= 65535) {
              if (F4 + 2 >= B4)
                break;
              Q5[F4++] = 224 | t4 >> 12, Q5[F4++] = 128 | t4 >> 6 & 63, Q5[F4++] = 128 | 63 & t4;
            } else {
              if (F4 + 3 >= B4)
                break;
              Q5[F4++] = 240 | t4 >> 18, Q5[F4++] = 128 | t4 >> 12 & 63, Q5[F4++] = 128 | t4 >> 6 & 63, Q5[F4++] = 128 | 63 & t4;
            }
          }
          Q5[F4] = 0;
        })(Q4, I2, t3, U3 + 1);
      else if (B3)
        for (var d3 = 0; d3 < U3; ++d3) {
          var n3 = Q4.charCodeAt(d3);
          n3 > 255 && (VA(t3), H("String has UTF-16 code units that do not fit in 8 bits")), I2[t3 + d3] = n3;
        }
      else
        for (d3 = 0; d3 < U3; ++d3)
          I2[t3 + d3] = Q4[d3];
      return null !== A4 && A4.push(VA, l3), l3;
    }, argPackAdvance: 8, readValueFromPointer: z, destructorFunction(A4) {
      VA(A4);
    } });
  }, c: (A3, Q3, F3) => {
    var U3, B3, l3, t3;
    F3 = k2(F3), 2 === Q3 ? (U3 = q, B3 = $, t3 = AA, l3 = (A4) => R2[A4 >> 1]) : 4 === Q3 && (U3 = QA, B3 = FA, t3 = UA, l3 = (A4) => g2[A4 >> 2]), D(A3, { name: F3, fromWireType: (A4) => {
      for (var F4, B4 = g2[A4 >> 2], t4 = A4 + 4, d3 = 0; d3 <= B4; ++d3) {
        var n3 = A4 + 4 + d3 * Q3;
        if (d3 == B4 || 0 == l3(n3)) {
          var V3 = U3(t4, n3 - t4);
          void 0 === F4 ? F4 = V3 : (F4 += String.fromCharCode(0), F4 += V3), t4 = n3 + Q3;
        }
      }
      return VA(A4), F4;
    }, toWireType: (A4, U4) => {
      "string" != typeof U4 && H(`Cannot pass non-string to C++ string type ${F3}`);
      var l4 = t3(U4), d3 = nA(4 + l4 + Q3);
      return g2[d3 >> 2] = l4 / Q3, B3(U4, d3 + 4, l4 + Q3), null !== A4 && A4.push(VA, d3), d3;
    }, argPackAdvance: 8, readValueFromPointer: z, destructorFunction(A4) {
      VA(A4);
    } });
  }, j: (A3, Q3) => {
    D(A3, { isVoid: true, name: Q3 = k2(Q3), argPackAdvance: 0, fromWireType: () => {
    }, toWireType: (A4, Q4) => {
    } });
  }, g: (A3) => {
    var Q3 = I2.length, F3 = 2147483648;
    if ((A3 >>>= 0) > F3)
      return false;
    for (var U3, B3, l3 = 1; l3 <= 4; l3 *= 2) {
      var t3 = Q3 * (1 + 0.2 / l3);
      t3 = Math.min(t3, A3 + 100663296);
      var d3 = Math.min(F3, (U3 = Math.max(A3, t3)) + ((B3 = 65536) - U3 % B3) % B3);
      if (BA(d3))
        return true;
    }
    return false;
  } }, tA = function() {
    var _a;
    var A3 = { a: lA };
    function Q3(A4, Q4) {
      var F3;
      return tA = A4.exports, d2 = tA.k, W2(), F3 = tA.l, s2.unshift(F3), function(A5) {
        var _a2;
        if (J2--, (_a2 = U2.monitorRunDependencies) == null ? void 0 : _a2.call(U2, J2), 0 == J2 && r2) {
          var Q5 = r2;
          r2 = null, Q5();
        }
      }(), tA;
    }
    if (J2++, (_a = U2.monitorRunDependencies) == null ? void 0 : _a.call(U2, J2), U2.instantiateWasm)
      try {
        return U2.instantiateWasm(A3, Q3);
      } catch (A4) {
        n2(`Module.instantiateWasm callback failed with error: ${A4}`), F2(A4);
      }
    return S2(0, b2, A3, function(A4) {
      Q3(A4.instance);
    }).catch(F2), {};
  }();
  U2._evaluate = (A3, Q3, F3, B3, l3, t3, d3, n3, V3, Z3, I3, e3, R3) => (U2._evaluate = tA.m)(A3, Q3, F3, B3, l3, t3, d3, n3, V3, Z3, I3, e3, R3);
  var dA, nA = U2._malloc = (A3) => (nA = U2._malloc = tA.o)(A3), VA = U2._free = (A3) => (VA = U2._free = tA.p)(A3);
  function ZA() {
    function A3() {
      dA || (dA = true, U2.calledRun = true, C2 || (X2(s2), Q2(U2), U2.onRuntimeInitialized && U2.onRuntimeInitialized(), function() {
        if (U2.postRun)
          for ("function" == typeof U2.postRun && (U2.postRun = [U2.postRun]); U2.postRun.length; )
            A4 = U2.postRun.shift(), o2.unshift(A4);
        var A4;
        X2(o2);
      }()));
    }
    J2 > 0 || (function() {
      if (U2.preRun)
        for ("function" == typeof U2.preRun && (U2.preRun = [U2.preRun]); U2.preRun.length; )
          A4 = U2.preRun.shift(), h2.unshift(A4);
      var A4;
      X2(h2);
    }(), J2 > 0 || (U2.setStatus ? (U2.setStatus("Running..."), setTimeout(function() {
      setTimeout(function() {
        U2.setStatus("");
      }, 1), A3();
    }, 1)) : A3()));
  }
  if (r2 = function A3() {
    dA || ZA(), dA || (r2 = A3);
  }, U2.preInit)
    for ("function" == typeof U2.preInit && (U2.preInit = [U2.preInit]); U2.preInit.length > 0; )
      U2.preInit.pop()();
  return ZA(), A2.ready;
};
var k = class {
  constructor(A2) {
    let Q2;
    (async () => {
      Q2 = await p();
    })();
    let F2, U2, B2, l2, t2, d2, n2, V2, Z2, I2, e2, R2 = 0, a2 = 0;
    this.testPoint = (g2, i2) => {
      if (!Q2)
        throw new Error("Wasm module not loaded");
      if (!A2.camera)
        throw new Error("Camera not set");
      if (!A2.renderData || !A2.depthIndex || !A2.chunks)
        return null;
      const c2 = A2.renderData, C2 = A2.depthIndex, W2 = A2.chunks, h2 = Math.pow(2, Math.ceil(Math.log2(c2.vertexCount)));
      var s2;
      (s2 = h2) > R2 && (R2 > 0 && (Q2._free(F2), Q2._free(B2), Q2._free(l2), Q2._free(t2), Q2._free(d2), Q2._free(n2), Q2._free(V2), Q2._free(Z2), Q2._free(I2), Q2._free(e2)), R2 = s2, F2 = Q2._malloc(64), B2 = Q2._malloc(4 * R2), l2 = Q2._malloc(3 * R2 * 4), t2 = Q2._malloc(4 * R2 * 4), d2 = Q2._malloc(3 * R2 * 4), n2 = Q2._malloc(4 * R2), V2 = Q2._malloc(R2), Z2 = Q2._malloc(12), I2 = Q2._malloc(12), e2 = Q2._malloc(4));
      const o2 = Math.pow(2, Math.ceil(Math.log2(c2.transforms.length / 20)));
      var J2;
      (J2 = o2) > a2 && (a2 > 0 && Q2._free(U2), a2 = J2, U2 = Q2._malloc(20 * a2 * 4));
      const r2 = (g2 + 1) / 2, E2 = (i2 + 1) / 2, b2 = Math.floor(15 * r2) + 15 * Math.floor(15 * E2), m2 = A2.camera, N2 = m2.screenPointToRay(g2, i2);
      Q2.HEAPF32.set(m2.data.viewMatrix.buffer, F2 / 4), Q2.HEAPU32.set(c2.transformIndices, B2 / 4), Q2.HEAPF32.set(c2.positions, l2 / 4), Q2.HEAPF32.set(c2.rotations, t2 / 4), Q2.HEAPF32.set(c2.scales, d2 / 4), Q2.HEAPU32.set(C2, n2 / 4), Q2.HEAPU8.set(W2, V2), Q2.HEAPF32.set(m2.position.flat(), Z2 / 4), Q2.HEAPF32.set(N2.flat(), I2 / 4), Q2.HEAPF32.set(c2.transforms, U2 / 4), Q2._evaluate(F2, U2, B2, l2, t2, d2, n2, V2, c2.vertexCount, b2, Z2, I2, e2);
      const G2 = Q2.HEAPU32[e2 / 4];
      if (4294967295 !== G2) {
        return c2.getSplat(G2);
      }
      return null;
    };
  }
};
export {
  a as Camera,
  e as CameraData,
  m as Color32,
  G as FadeInPass,
  k as IntersectionTester,
  C as Loader,
  n as Matrix3,
  U as Matrix4,
  d as Object3D,
  S as OrbitControls,
  W as PLYLoader,
  X as Plane,
  Q as Quaternion,
  b as RenderData,
  N as RenderProgram,
  g as Scene,
  Y as ShaderPass,
  J as ShaderProgram,
  I as Splat,
  V as SplatData,
  A as Vector3,
  R as Vector4,
  y as WebGLRenderer
};
//# sourceMappingURL=gsplat.js.map
